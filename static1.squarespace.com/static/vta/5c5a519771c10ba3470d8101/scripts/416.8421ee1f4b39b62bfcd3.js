/*! For license information please see 416.8421ee1f4b39b62bfcd3.js.LICENSE.txt */
(self.webpackChunknew_bedford_framework = self.webpackChunknew_bedford_framework || []).push([
    [416], {
        51318: function(e, t, i) {
            "use strict";
            i.d(t, {
                si: function() {
                    return O
                },
                e$: function() {
                    return R
                },
                z6: function() {
                    return N
                },
                L9: function() {
                    return jo
                },
                Jf: function() {
                    return c
                },
                SW: function() {
                    return M
                },
                zH: function() {
                    return n
                },
                yo: function() {
                    return s
                },
                uc: function() {
                    return o
                },
                Tl: function() {
                    return l
                }
            });
            i(94226), i(72877), i(42770), i(73855);
            var r = function(e, t) {
                    return e.replace("{variant}", t)
                },
                n = function(e, t) {
                    return t || r(e, "thumbnail")
                },
                s = function(e) {
                    return r(e.alexandriaUrl, "playlist.m3u8")
                },
                a = {
                    Production: "PRODUCTION",
                    Staging: "STAGING",
                    QA: "QA",
                    Dev: "DEV"
                },
                o = function() {
                    var e, t, i, r = null !== (e = null !== (t = null === (i = window.Static) || void 0 === i || null === (i = i.SQUARESPACE_CONTEXT) || void 0 === i ? void 0 : i.appDomain) && void 0 !== t ? t : window.location.host) && void 0 !== e ? e : "";
                    return /dev\.(sqsp|squarespace)\.net$/.test(r) || /localhost(:[0-9]+)?$/.test(r) ? a.Dev : /qa[0-9]+\.(sqsp|squarespace)\.net$/.test(r) ? a.QA : /stage\.(sqsp|squarespace)\.net$/.test(r) ? a.Staging : a.Production
                },
                l = "2.4.0",
                c = {
                    None: "none",
                    Minimal: "minimal",
                    Full: "full"
                },
                d = "VIDEO_ABORTED_BY_USER",
                u = "VIDEO_COULD_NOT_BE_ACCESSED",
                h = "VIDEO_COULD_NOT_BE_DECODED",
                f = "VIDEO_COULD_NOT_BE_PLAYED",
                m = "VIDEO_PLAYBACK_DRIVER_UNSUPPORTED",
                p = "VIDEO_PLAYER_INVALID_CONFIGURATION",
                g = "VIDEO_PLAYER_UNKNOWN_MEDIA_ERROR",
                y = "VIDEO_PLAYER_UNEXPECTED_ERROR",
                v = "VIDEO_PLAYER_UNAUTHORIZED",
                b = i(23029),
                T = i(92901),
                E = i(56822),
                A = i(53954),
                w = i(85501);

            function _(e, t, i) {
                return t = (0, A.A)(t), (0, E.A)(e, k() ? Reflect.construct(t, i || [], (0, A.A)(e).constructor) : t.apply(e, i))
            }

            function k() {
                try {
                    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})))
                } catch (e) {}
                return (k = function() {
                    return !!e
                })()
            }
            var S = function(e) {
                    function t(e, i) {
                        var r;
                        return (0, b.A)(this, t), (r = _(this, t, [i])).code = e, r.name = "VideoPlayerError", r
                    }
                    return (0, w.A)(t, e), (0, T.A)(t, null, [{
                        key: "fromError",
                        value: function(e) {
                            var i;
                            return e instanceof t ? e : e instanceof MediaError ? this.fromMediaError(e) : new t(y, null !== (i = null == e ? void 0 : e.message) && void 0 !== i ? i : void 0)
                        }
                    }, {
                        key: "fromMediaError",
                        value: function(e) {
                            var i, r = t.mapMediaErrorCode(e);
                            return new t(r, null !== (i = null == e ? void 0 : e.message) && void 0 !== i ? i : void 0)
                        }
                    }, {
                        key: "fromPlayerMedia",
                        value: function(e) {
                            var i = e instanceof HTMLVideoElement ? e.error : void 0;
                            return null === i ? new t(g) : i ? t.fromMediaError(i) : new t(y)
                        }
                    }, {
                        key: "mapMediaErrorCode",
                        value: function(e) {
                            switch (e.code) {
                                case MediaError.MEDIA_ERR_ABORTED:
                                    return d;
                                case MediaError.MEDIA_ERR_NETWORK:
                                    return u;
                                case MediaError.MEDIA_ERR_DECODE:
                                    return h;
                                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                    return f;
                                default:
                                    return g
                            }
                        }
                    }])
                }((0, i(28614).A)(Error)),
                L = i(64467),
                R = {
                    Watching: "watching",
                    Paused: "paused",
                    Seeked: "seeked",
                    Ended: "ended",
                    Abandoned: "abandoned"
                };

            function D(e, t) {
                var i = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }

            function C(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var i = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? D(Object(i), !0).forEach((function(t) {
                        (0, L.A)(e, t, i[t])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : D(Object(i)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                    }))
                }
                return e
            }
            var I = (0, T.A)((function e() {
                (0, b.A)(this, e)
            }), null, [{
                key: "makeSegmentForNewSession",
                value: function(e, t) {
                    return {
                        viewSessionId: e,
                        startPosition: t,
                        progressStartPosition: t,
                        progressEndPosition: t
                    }
                }
            }, {
                key: "startPositionUpdated",
                value: function(e, t) {
                    return C(C({}, e), {}, {
                        progressStartPosition: t,
                        progressEndPosition: t
                    })
                }
            }, {
                key: "endPositionUpdated",
                value: function(e, t) {
                    return C(C({}, e), {}, {
                        progressEndPosition: t
                    })
                }
            }]);

            function P(e, t) {
                var i = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }

            function x(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var i = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? P(Object(i), !0).forEach((function(t) {
                        (0, L.A)(e, t, i[t])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : P(Object(i)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                    }))
                }
                return e
            }
            var O = function() {
                function e(t) {
                    var i = this;
                    (0, b.A)(this, e), (0, L.A)(this, "hasPlayed", !1), (0, L.A)(this, "onPlay", (function() {
                        i.hasPlayed = !0
                    })), (0, L.A)(this, "onTimeUpdate", (function(t, r) {
                        e.isSeeking(t, i.segmentData) ? i.onSeeked(t, r) : (i.segmentData = I.endPositionUpdated(i.segmentData, t), e.shouldReportSegment(i.segmentData) && (i.options.onSendProgressEvent(x(x({}, i.segmentData), {}, {
                            progressTriggerReason: R.Watching,
                            currentPosition: t
                        })), i.segmentData = I.startPositionUpdated(i.segmentData, t)))
                    })), (0, L.A)(this, "onPause", (function(e, t) {
                        e >= t || (i.segmentData = I.endPositionUpdated(i.segmentData, e), i.options.onSendProgressEvent(x(x({}, i.segmentData), {}, {
                            progressTriggerReason: R.Paused,
                            currentPosition: e
                        })), i.segmentData = I.startPositionUpdated(i.segmentData, e))
                    })), (0, L.A)(this, "onEnd", (function(e) {
                        i.segmentData = I.endPositionUpdated(i.segmentData, e), i.options.onSendProgressEvent(x(x({}, i.segmentData), {}, {
                            progressTriggerReason: R.Ended,
                            currentPosition: e
                        }))
                    })), (0, L.A)(this, "onPlayerAbandoned", (function() {
                        i.segmentData.progressEndPosition - i.segmentData.progressStartPosition > 0 && (i.options.onSendProgressEvent(x(x({}, i.segmentData), {}, {
                            progressTriggerReason: R.Abandoned,
                            currentPosition: i.segmentData.progressEndPosition
                        })), i.segmentData = I.startPositionUpdated(i.segmentData, i.segmentData.progressEndPosition))
                    })), (0, L.A)(this, "onNewViewSessionId", (function(e) {
                        i.viewSessionId = e
                    })), this.options = t, this.viewSessionId = t.initialViewSessionId, this.segmentData = I.makeSegmentForNewSession(this.viewSessionId, 0)
                }
                return (0, T.A)(e, [{
                    key: "onSeeked",
                    value: function(e, t) {
                        if (this.hasPlayed) {
                            var i = e / t,
                                r = this.segmentData.progressEndPosition / t >= 1;
                            r && 0 === i || this.options.onSendProgressEvent(x(x({}, this.segmentData), {}, {
                                progressTriggerReason: R.Seeked,
                                currentPosition: e
                            })), this.segmentData = I.startPositionUpdated(this.segmentData, e), r && i < 1 && (this.viewSessionId = this.options.requestNewSession(), this.segmentData = I.makeSegmentForNewSession(this.viewSessionId, e))
                        } else this.segmentData = I.makeSegmentForNewSession(this.viewSessionId, e)
                    }
                }], [{
                    key: "shouldReportSegment",
                    value: function(t) {
                        return t.progressEndPosition - t.progressStartPosition >= e.ReportAfterSecondsViewed
                    }
                }, {
                    key: "isSeeking",
                    value: function(t, i) {
                        return Math.abs(t - i.progressEndPosition) >= e.SeekTimeBufferInSeconds
                    }
                }])
            }();
            (0, L.A)(O, "SeekTimeBufferInSeconds", 1.5), (0, L.A)(O, "ReportAfterSecondsViewed", 10);
            var M = (0, T.A)((function e(t) {
                    var i = this;
                    (0, b.A)(this, e), (0, L.A)(this, "isPlayerReady", !1), (0, L.A)(this, "hasViewedPlayer", !1), (0, L.A)(this, "onReady", (function() {
                        i.isPlayerReady = !0
                    })), (0, L.A)(this, "onPlayerViewed", (function() {
                        !i.hasViewedPlayer && i.isPlayerReady && (i.options.onSendViewEvent({
                            viewSessionId: i.viewSessionId
                        }), i.hasViewedPlayer = !0)
                    })), (0, L.A)(this, "onNewViewSessionId", (function(e) {
                        i.viewSessionId = e
                    })), this.options = t, this.viewSessionId = t.initialViewSessionId
                })),
                N = (0, T.A)((function e() {
                    (0, b.A)(this, e)
                }), [{
                    key: "makeEventHooks",
                    value: function() {
                        var e = this;
                        return {
                            onReady: function() {
                                return e.onReady()
                            },
                            onPlay: function(t, i) {
                                return e.onPlay(t, i)
                            },
                            onTimeUpdate: function(t, i) {
                                return e.onTimeUpdate(t, i)
                            },
                            onPause: function(t, i) {
                                return e.onPause(t, i)
                            },
                            onEnd: function(t, i) {
                                return e.onEnd(t, i)
                            },
                            onSeek: function(t, i) {
                                return e.onSeek(t, i)
                            },
                            onPaywallCtaClick: function() {
                                return e.onPaywallCtaClick()
                            }
                        }
                    }
                }, {
                    key: "onReady",
                    value: function() {
                        this.trackers.forEach((function(e) {
                            var t;
                            return null === (t = e.onReady) || void 0 === t ? void 0 : t.call(e)
                        }))
                    }
                }, {
                    key: "onPlay",
                    value: function(e, t) {
                        this.trackers.forEach((function(i) {
                            var r;
                            return null === (r = i.onPlay) || void 0 === r ? void 0 : r.call(i, e, t)
                        }))
                    }
                }, {
                    key: "onTimeUpdate",
                    value: function(e, t) {
                        this.trackers.forEach((function(i) {
                            var r;
                            return null === (r = i.onTimeUpdate) || void 0 === r ? void 0 : r.call(i, e, t)
                        }))
                    }
                }, {
                    key: "onPause",
                    value: function(e, t) {
                        this.trackers.forEach((function(i) {
                            var r;
                            return null === (r = i.onPause) || void 0 === r ? void 0 : r.call(i, e, t)
                        }))
                    }
                }, {
                    key: "onEnd",
                    value: function(e, t) {
                        this.trackers.forEach((function(i) {
                            var r;
                            return null === (r = i.onEnd) || void 0 === r ? void 0 : r.call(i, e, t)
                        }))
                    }
                }, {
                    key: "onSeek",
                    value: function(e, t) {
                        this.trackers.forEach((function(i) {
                            var r;
                            return null === (r = i.onSeek) || void 0 === r ? void 0 : r.call(i, e, t)
                        }))
                    }
                }, {
                    key: "onPaywallCtaClick",
                    value: function() {
                        this.trackers.forEach((function(e) {
                            var t;
                            return null === (t = e.onPaywallCtaClick) || void 0 === t ? void 0 : t.call(e)
                        }))
                    }
                }, {
                    key: "onNewSessionId",
                    value: function(e) {
                        this.trackers.forEach((function(t) {
                            var i;
                            return null === (i = t.onNewViewSessionId) || void 0 === i ? void 0 : i.call(t, e)
                        }))
                    }
                }]),
                F = i(45458),
                B = i(10467),
                U = i(54756),
                $ = i.n(U),
                H = i(34330),
                j = i.n(H),
                G = {
                    PlayLarge: "play-large",
                    Restart: "restart",
                    Rewind: "rewind",
                    Play: "play",
                    FastForward: "fast-forward",
                    Progress: "progress",
                    CurrentTime: "current-time",
                    Duration: "duration",
                    Mute: "mute",
                    Volume: "volume",
                    Captions: "captions",
                    Settings: "settings",
                    PiP: "pip",
                    AirPlay: "airplay",
                    Download: "download",
                    Fullscreen: "fullscreen"
                },
                V = {
                    Play: "play",
                    Time: "time",
                    Mute: "mute",
                    Volume: "volume",
                    Settings: "settings",
                    Fullscreen: "fullscreen",
                    Progress: "progress",
                    LoadingIndicator: "loading-indicator",
                    NavigationIndicators: "navigation-indicators"
                },
                q = (0, L.A)((0, L.A)((0, L.A)({}, c.None, []), c.Minimal, [V.Play, V.Progress, V.LoadingIndicator]), c.Full, Object.values(V)),
                K = "speed",
                W = [.5, .75, 1, 1.25, 1.5, 1.75, 2],
                Y = (0, T.A)((function e(t, i, r) {
                    var n = this;
                    (0, b.A)(this, e), (0, L.A)(this, "embedVideoAspectRatio", 16 / 9), (0, L.A)(this, "embedWrapperClassName", "video-player__embed--fixed-width"), this.videoPlayerElement = t, this.player = i, this.isExternalProvider = r, r && i.once("ready", (function() {
                        n.embedWrapper = i.elements.wrapper, n.forceEmbedAspectRatio(), n.resizeObserver = new ResizeObserver((function() {
                            return n.forceEmbedAspectRatio()
                        })), n.resizeObserver.observe(t)
                    }))
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.resizeObserver) || void 0 === e || e.disconnect(), this.clearEmbedWrapperStyles()
                    }
                }, {
                    key: "forceEmbedAspectRatio",
                    value: function() {
                        var e = this.videoPlayerElement.clientWidth,
                            t = this.videoPlayerElement.clientHeight,
                            i = Math.round(t * this.embedVideoAspectRatio);
                        e > i ? this.setEmbedWrapperStyles(i) : this.clearEmbedWrapperStyles()
                    }
                }, {
                    key: "setEmbedWrapperStyles",
                    value: function(e) {
                        this.embedWrapper && (this.embedWrapper.classList.add(this.embedWrapperClassName), this.embedWrapper.style.width = "".concat(e, "px"))
                    }
                }, {
                    key: "clearEmbedWrapperStyles",
                    value: function() {
                        this.embedWrapper && (this.embedWrapper.classList.remove(this.embedWrapperClassName), this.embedWrapper.style.width = "")
                    }
                }]);

            function z(e, t) {
                var i = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }

            function X(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var i = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? z(Object(i), !0).forEach((function(t) {
                        (0, L.A)(e, t, i[t])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : z(Object(i)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                    }))
                }
                return e
            }
            var Q = {
                    YouTube: "youtube",
                    Vimeo: "vimeo"
                },
                J = X(X({}, Q), {
                    HlsJs: "hls-js",
                    NativeHls: "native-hls"
                });

            function Z(e) {
                return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
            }
            var ee, te, ie, re, ne, se = {
                exports: {}
            };
            ee = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, te = /^(?=([^\/?#]*))\1([^]*)$/, ie = /(?:\/|^)\.(?=\/)/g, re = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, se.exports = ne = {
                buildAbsoluteURL: function(e, t, i) {
                    if (i = i || {}, e = e.trim(), !(t = t.trim())) {
                        if (!i.alwaysNormalize) return e;
                        var r = ne.parseURL(e);
                        if (!r) throw new Error("Error trying to parse base URL.");
                        return r.path = ne.normalizePath(r.path), ne.buildURLFromParts(r)
                    }
                    var n = ne.parseURL(t);
                    if (!n) throw new Error("Error trying to parse relative URL.");
                    if (n.scheme) return i.alwaysNormalize ? (n.path = ne.normalizePath(n.path), ne.buildURLFromParts(n)) : t;
                    var s = ne.parseURL(e);
                    if (!s) throw new Error("Error trying to parse base URL.");
                    if (!s.netLoc && s.path && "/" !== s.path[0]) {
                        var a = te.exec(s.path);
                        s.netLoc = a[1], s.path = a[2]
                    }
                    s.netLoc && !s.path && (s.path = "/");
                    var o = {
                        scheme: s.scheme,
                        netLoc: n.netLoc,
                        path: null,
                        params: n.params,
                        query: n.query,
                        fragment: n.fragment
                    };
                    if (!n.netLoc && (o.netLoc = s.netLoc, "/" !== n.path[0]))
                        if (n.path) {
                            var l = s.path,
                                c = l.substring(0, l.lastIndexOf("/") + 1) + n.path;
                            o.path = ne.normalizePath(c)
                        } else o.path = s.path, n.params || (o.params = s.params, n.query || (o.query = s.query));
                    return null === o.path && (o.path = i.alwaysNormalize ? ne.normalizePath(n.path) : n.path), ne.buildURLFromParts(o)
                },
                parseURL: function(e) {
                    var t = ee.exec(e);
                    return t ? {
                        scheme: t[1] || "",
                        netLoc: t[2] || "",
                        path: t[3] || "",
                        params: t[4] || "",
                        query: t[5] || "",
                        fragment: t[6] || ""
                    } : null
                },
                normalizePath: function(e) {
                    for (e = e.split("").reverse().join("").replace(ie, ""); e.length !== (e = e.replace(re, "")).length;);
                    return e.split("").reverse().join("")
                },
                buildURLFromParts: function(e) {
                    return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
                }
            };
            var ae = se.exports;

            function oe(e, t) {
                var i = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }

            function le(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var i = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? oe(Object(i), !0).forEach((function(t) {
                        ce(e, t, i[t])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : oe(Object(i)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                    }))
                }
                return e
            }

            function ce(e, t, i) {
                return (t = function(e) {
                    var t = function(e, t) {
                        if ("object" != typeof e || null === e) return e;
                        var i = e[Symbol.toPrimitive];
                        if (void 0 !== i) {
                            var r = i.call(e, t || "default");
                            if ("object" != typeof r) return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === t ? String : Number)(e)
                    }(e, "string");
                    return "symbol" == typeof t ? t : String(t)
                }(t)) in e ? Object.defineProperty(e, t, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = i, e
            }

            function de() {
                return de = Object.assign ? Object.assign.bind() : function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var i = arguments[t];
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
                    }
                    return e
                }, de.apply(this, arguments)
            }
            const ue = Number.isFinite || function(e) {
                    return "number" == typeof e && isFinite(e)
                },
                he = Number.isSafeInteger || function(e) {
                    return "number" == typeof e && Math.abs(e) <= fe
                },
                fe = Number.MAX_SAFE_INTEGER || 9007199254740991;
            let me = function(e) {
                    return e.MEDIA_ATTACHING = "hlsMediaAttaching", e.MEDIA_ATTACHED = "hlsMediaAttached", e.MEDIA_DETACHING = "hlsMediaDetaching", e.MEDIA_DETACHED = "hlsMediaDetached", e.BUFFER_RESET = "hlsBufferReset", e.BUFFER_CODECS = "hlsBufferCodecs", e.BUFFER_CREATED = "hlsBufferCreated", e.BUFFER_APPENDING = "hlsBufferAppending", e.BUFFER_APPENDED = "hlsBufferAppended", e.BUFFER_EOS = "hlsBufferEos", e.BUFFER_FLUSHING = "hlsBufferFlushing", e.BUFFER_FLUSHED = "hlsBufferFlushed", e.MANIFEST_LOADING = "hlsManifestLoading", e.MANIFEST_LOADED = "hlsManifestLoaded", e.MANIFEST_PARSED = "hlsManifestParsed", e.LEVEL_SWITCHING = "hlsLevelSwitching", e.LEVEL_SWITCHED = "hlsLevelSwitched", e.LEVEL_LOADING = "hlsLevelLoading", e.LEVEL_LOADED = "hlsLevelLoaded", e.LEVEL_UPDATED = "hlsLevelUpdated", e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", e.LEVELS_UPDATED = "hlsLevelsUpdated", e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", e.CUES_PARSED = "hlsCuesParsed", e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", e.INIT_PTS_FOUND = "hlsInitPtsFound", e.FRAG_LOADING = "hlsFragLoading", e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", e.FRAG_LOADED = "hlsFragLoaded", e.FRAG_DECRYPTED = "hlsFragDecrypted", e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", e.FRAG_PARSED = "hlsFragParsed", e.FRAG_BUFFERED = "hlsFragBuffered", e.FRAG_CHANGED = "hlsFragChanged", e.FPS_DROP = "hlsFpsDrop", e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", e.ERROR = "hlsError", e.DESTROYING = "hlsDestroying", e.KEY_LOADING = "hlsKeyLoading", e.KEY_LOADED = "hlsKeyLoaded", e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", e.BACK_BUFFER_REACHED = "hlsBackBufferReached", e
                }({}),
                pe = function(e) {
                    return e.NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError", e
                }({}),
                ge = function(e) {
                    return e.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", e.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", e.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", e.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", e.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_PARSING_ERROR = "levelParsingError", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", e.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.FRAG_GAP = "fragGap", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException", e.INTERNAL_ABORTED = "aborted", e.UNKNOWN = "unknown", e
                }({});
            const ye = function() {},
                ve = {
                    trace: ye,
                    debug: ye,
                    log: ye,
                    warn: ye,
                    info: ye,
                    error: ye
                };
            let be = ve;

            function Te(e, ...t) {
                t.forEach((function(t) {
                    be[t] = e[t] ? e[t].bind(e) : function(e) {
                        const t = self.console[e];
                        return t ? t.bind(self.console, `[${e}] >`) : ye
                    }(t)
                }))
            }
            const Ee = be,
                Ae = /^(\d+)x(\d+)$/,
                we = /(.+?)=(".*?"|.*?)(?:,|$)/g;
            class _e {
                constructor(e) {
                    "string" == typeof e && (e = _e.parseAttrList(e));
                    for (const t in e) e.hasOwnProperty(t) && ("X-" === t.substring(0, 2) && (this.clientAttrs = this.clientAttrs || [], this.clientAttrs.push(t)), this[t] = e[t])
                }
                decimalInteger(e) {
                    const t = parseInt(this[e], 10);
                    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
                }
                hexadecimalInteger(e) {
                    if (this[e]) {
                        let t = (this[e] || "0x").slice(2);
                        t = (1 & t.length ? "0" : "") + t;
                        const i = new Uint8Array(t.length / 2);
                        for (let e = 0; e < t.length / 2; e++) i[e] = parseInt(t.slice(2 * e, 2 * e + 2), 16);
                        return i
                    }
                    return null
                }
                hexadecimalIntegerAsNumber(e) {
                    const t = parseInt(this[e], 16);
                    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
                }
                decimalFloatingPoint(e) {
                    return parseFloat(this[e])
                }
                optionalFloat(e, t) {
                    const i = this[e];
                    return i ? parseFloat(i) : t
                }
                enumeratedString(e) {
                    return this[e]
                }
                bool(e) {
                    return "YES" === this[e]
                }
                decimalResolution(e) {
                    const t = Ae.exec(this[e]);
                    if (null !== t) return {
                        width: parseInt(t[1], 10),
                        height: parseInt(t[2], 10)
                    }
                }
                static parseAttrList(e) {
                    let t;
                    const i = {};
                    for (we.lastIndex = 0; null !== (t = we.exec(e));) {
                        let e = t[2];
                        0 === e.indexOf('"') && e.lastIndexOf('"') === e.length - 1 && (e = e.slice(1, -1));
                        i[t[1].trim()] = e
                    }
                    return i
                }
            }

            function ke(e) {
                return "SCTE35-OUT" === e || "SCTE35-IN" === e
            }
            class Se {
                constructor(e, t) {
                    if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) {
                        const i = t.attr;
                        for (const t in i)
                            if (Object.prototype.hasOwnProperty.call(e, t) && e[t] !== i[t]) {
                                Ee.warn(`DATERANGE tag attribute: "${t}" does not match for tags with ID: "${e.ID}"`), this._badValueForSameId = t;
                                break
                            }
                        e = de(new _e({}), i, e)
                    }
                    if (this.attr = e, this._startDate = new Date(e["START-DATE"]), "END-DATE" in this.attr) {
                        const e = new Date(this.attr["END-DATE"]);
                        ue(e.getTime()) && (this._endDate = e)
                    }
                }
                get id() {
                    return this.attr.ID
                }
                get class() {
                    return this.attr.CLASS
                }
                get startDate() {
                    return this._startDate
                }
                get endDate() {
                    if (this._endDate) return this._endDate;
                    const e = this.duration;
                    return null !== e ? new Date(this._startDate.getTime() + 1e3 * e) : null
                }
                get duration() {
                    if ("DURATION" in this.attr) {
                        const e = this.attr.decimalFloatingPoint("DURATION");
                        if (ue(e)) return e
                    } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
                    return null
                }
                get plannedDuration() {
                    return "PLANNED-DURATION" in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
                }
                get endOnNext() {
                    return this.attr.bool("END-ON-NEXT")
                }
                get isValid() {
                    return !!this.id && !this._badValueForSameId && ue(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class)
                }
            }
            class Le {
                constructor() {
                    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
                        start: 0,
                        first: 0,
                        end: 0
                    }, this.parsing = {
                        start: 0,
                        end: 0
                    }, this.buffering = {
                        start: 0,
                        first: 0,
                        end: 0
                    }
                }
            }
            var Re = "audio",
                De = "video",
                Ce = "audiovideo";
            class Ie {
                constructor(e) {
                    this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = {
                        [Re]: null,
                        [De]: null,
                        [Ce]: null
                    }, this.baseurl = e
                }
                setByteRange(e, t) {
                    const i = e.split("@", 2),
                        r = [];
                    1 === i.length ? r[0] = t ? t.byteRangeEndOffset : 0 : r[0] = parseInt(i[1]), r[1] = parseInt(i[0]) + r[0], this._byteRange = r
                }
                get byteRange() {
                    return this._byteRange ? this._byteRange : []
                }
                get byteRangeStartOffset() {
                    return this.byteRange[0]
                }
                get byteRangeEndOffset() {
                    return this.byteRange[1]
                }
                get url() {
                    return !this._url && this.baseurl && this.relurl && (this._url = ae.buildAbsoluteURL(this.baseurl, this.relurl, {
                        alwaysNormalize: !0
                    })), this._url || ""
                }
                set url(e) {
                    this._url = e
                }
            }
            class Pe extends Ie {
                constructor(e, t) {
                    super(t), this._decryptdata = null, this.rawProgramDateTime = null, this.programDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.stats = new Le, this.urlId = 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.type = e
                }
                get decryptdata() {
                    const {
                        levelkeys: e
                    } = this;
                    if (!e && !this._decryptdata) return null;
                    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
                        const e = this.levelkeys.identity;
                        if (e) this._decryptdata = e.getDecryptData(this.sn);
                        else {
                            const e = Object.keys(this.levelkeys);
                            if (1 === e.length) return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn)
                        }
                    }
                    return this._decryptdata
                }
                get end() {
                    return this.start + this.duration
                }
                get endProgramDateTime() {
                    if (null === this.programDateTime) return null;
                    if (!ue(this.programDateTime)) return null;
                    const e = ue(this.duration) ? this.duration : 0;
                    return this.programDateTime + 1e3 * e
                }
                get encrypted() {
                    var e;
                    if (null != (e = this._decryptdata) && e.encrypted) return !0;
                    if (this.levelkeys) {
                        const e = Object.keys(this.levelkeys),
                            t = e.length;
                        if (t > 1 || 1 === t && this.levelkeys[e[0]].encrypted) return !0
                    }
                    return !1
                }
                setKeyFormat(e) {
                    if (this.levelkeys) {
                        const t = this.levelkeys[e];
                        t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn))
                    }
                }
                abortRequests() {
                    var e, t;
                    null == (e = this.loader) || e.abort(), null == (t = this.keyLoader) || t.abort()
                }
                setElementaryStreamInfo(e, t, i, r, n, s = !1) {
                    const {
                        elementaryStreams: a
                    } = this, o = a[e];
                    o ? (o.startPTS = Math.min(o.startPTS, t), o.endPTS = Math.max(o.endPTS, i), o.startDTS = Math.min(o.startDTS, r), o.endDTS = Math.max(o.endDTS, n)) : a[e] = {
                        startPTS: t,
                        endPTS: i,
                        startDTS: r,
                        endDTS: n,
                        partial: s
                    }
                }
                clearElementaryStreamInfo() {
                    const {
                        elementaryStreams: e
                    } = this;
                    e[Re] = null, e[De] = null, e[Ce] = null
                }
            }
            class xe extends Ie {
                constructor(e, t, i, r, n) {
                    super(i), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.stats = new Le, this.duration = e.decimalFloatingPoint("DURATION"), this.gap = e.bool("GAP"), this.independent = e.bool("INDEPENDENT"), this.relurl = e.enumeratedString("URI"), this.fragment = t, this.index = r;
                    const s = e.enumeratedString("BYTERANGE");
                    s && this.setByteRange(s, n), n && (this.fragOffset = n.fragOffset + n.duration)
                }
                get start() {
                    return this.fragment.start + this.fragOffset
                }
                get end() {
                    return this.start + this.duration
                }
                get loaded() {
                    const {
                        elementaryStreams: e
                    } = this;
                    return !!(e.audio || e.video || e.audiovideo)
                }
            }
            class Oe {
                constructor(e) {
                    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e
                }
                reloaded(e) {
                    if (!e) return this.advanced = !0, void(this.updated = !0);
                    const t = this.lastPartSn - e.lastPartSn,
                        i = this.lastPartIndex - e.lastPartIndex;
                    this.updated = this.endSN !== e.endSN || !!i || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && i > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay
                }
                get hasProgramDateTime() {
                    return !!this.fragments.length && ue(this.fragments[this.fragments.length - 1].programDateTime)
                }
                get levelTargetDuration() {
                    return this.averagetargetduration || this.targetduration || 10
                }
                get drift() {
                    const e = this.driftEndTime - this.driftStartTime;
                    if (e > 0) {
                        return 1e3 * (this.driftEnd - this.driftStart) / e
                    }
                    return 1
                }
                get edge() {
                    return this.partEnd || this.fragmentEnd
                }
                get partEnd() {
                    var e;
                    return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
                }
                get fragmentEnd() {
                    var e;
                    return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0
                }
                get age() {
                    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
                }
                get lastPartIndex() {
                    var e;
                    return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1
                }
                get lastPartSn() {
                    var e;
                    return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
                }
            }

            function Me(e) {
                return Uint8Array.from(atob(e), (e => e.charCodeAt(0)))
            }

            function Ne(e) {
                const t = e.split(":");
                let i = null;
                if ("data" === t[0] && 2 === t.length) {
                    const e = t[1].split(";"),
                        r = e[e.length - 1].split(",");
                    if (2 === r.length) {
                        const t = "base64" === r[0],
                            n = r[1];
                        t ? (e.splice(-1, 1), i = Me(n)) : i = function(e) {
                            const t = Fe(e).subarray(0, 16),
                                i = new Uint8Array(16);
                            return i.set(t, 16 - t.length), i
                        }(n)
                    }
                }
                return i
            }

            function Fe(e) {
                return Uint8Array.from(unescape(encodeURIComponent(e)), (e => e.charCodeAt(0)))
            }
            var Be = {
                    CLEARKEY: "org.w3.clearkey",
                    FAIRPLAY: "com.apple.fps",
                    PLAYREADY: "com.microsoft.playready",
                    WIDEVINE: "com.widevine.alpha"
                },
                Ue = "org.w3.clearkey",
                $e = "com.apple.streamingkeydelivery",
                He = "com.microsoft.playready",
                je = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";

            function Ge(e) {
                switch (e) {
                    case $e:
                        return Be.FAIRPLAY;
                    case He:
                        return Be.PLAYREADY;
                    case je:
                        return Be.WIDEVINE;
                    case Ue:
                        return Be.CLEARKEY
                }
            }
            var Ve = "edef8ba979d64acea3c827dcd51d21ed";

            function qe(e) {
                switch (e) {
                    case Be.FAIRPLAY:
                        return $e;
                    case Be.PLAYREADY:
                        return He;
                    case Be.WIDEVINE:
                        return je;
                    case Be.CLEARKEY:
                        return Ue
                }
            }

            function Ke(e) {
                const {
                    drmSystems: t,
                    widevineLicenseUrl: i
                } = e, r = t ? [Be.FAIRPLAY, Be.WIDEVINE, Be.PLAYREADY, Be.CLEARKEY].filter((e => !!t[e])) : [];
                return !r[Be.WIDEVINE] && i && r.push(Be.WIDEVINE), r
            }
            const We = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;

            function Ye(e, t, i) {
                return Uint8Array.prototype.slice ? e.slice(t, i) : new Uint8Array(Array.prototype.slice.call(e, t, i))
            }
            const ze = (e, t) => t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128,
                Xe = (e, t) => t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128,
                Qe = (e, t) => {
                    const i = t;
                    let r = 0;
                    for (; ze(e, t);) {
                        r += 10;
                        r += Je(e, t + 6), Xe(e, t + 10) && (r += 10), t += r
                    }
                    if (r > 0) return e.subarray(i, i + r)
                },
                Je = (e, t) => {
                    let i = 0;
                    return i = (127 & e[t]) << 21, i |= (127 & e[t + 1]) << 14, i |= (127 & e[t + 2]) << 7, i |= 127 & e[t + 3], i
                },
                Ze = (e, t) => ze(e, t) && Je(e, t + 6) + 10 <= e.length - t,
                et = e => e && "PRIV" === e.key && "com.apple.streaming.transportStreamTimestamp" === e.info,
                tt = e => {
                    const t = String.fromCharCode(e[0], e[1], e[2], e[3]),
                        i = Je(e, 4);
                    return {
                        type: t,
                        size: i,
                        data: e.subarray(10, 10 + i)
                    }
                },
                it = e => {
                    let t = 0;
                    const i = [];
                    for (; ze(e, t);) {
                        const r = Je(e, t + 6);
                        t += 10;
                        const n = t + r;
                        for (; t + 8 < n;) {
                            const r = tt(e.subarray(t)),
                                n = rt(r);
                            n && i.push(n), t += r.size + 10
                        }
                        Xe(e, t) && (t += 10)
                    }
                    return i
                },
                rt = e => "PRIV" === e.type ? nt(e) : "W" === e.type[0] ? at(e) : st(e),
                nt = e => {
                    if (e.size < 2) return;
                    const t = lt(e.data, !0),
                        i = new Uint8Array(e.data.subarray(t.length + 1));
                    return {
                        key: e.type,
                        info: t,
                        data: i.buffer
                    }
                },
                st = e => {
                    if (e.size < 2) return;
                    if ("TXXX" === e.type) {
                        let t = 1;
                        const i = lt(e.data.subarray(t), !0);
                        t += i.length + 1;
                        const r = lt(e.data.subarray(t));
                        return {
                            key: e.type,
                            info: i,
                            data: r
                        }
                    }
                    const t = lt(e.data.subarray(1));
                    return {
                        key: e.type,
                        data: t
                    }
                },
                at = e => {
                    if ("WXXX" === e.type) {
                        if (e.size < 2) return;
                        let t = 1;
                        const i = lt(e.data.subarray(t), !0);
                        t += i.length + 1;
                        const r = lt(e.data.subarray(t));
                        return {
                            key: e.type,
                            info: i,
                            data: r
                        }
                    }
                    const t = lt(e.data);
                    return {
                        key: e.type,
                        data: t
                    }
                },
                ot = e => {
                    if (8 === e.data.byteLength) {
                        const t = new Uint8Array(e.data),
                            i = 1 & t[3];
                        let r = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];
                        return r /= 45, i && (r += 47721858.84), Math.round(r)
                    }
                },
                lt = (e, t = !1) => {
                    const i = dt();
                    if (i) {
                        const r = i.decode(e);
                        if (t) {
                            const e = r.indexOf("\0");
                            return -1 !== e ? r.substring(0, e) : r
                        }
                        return r.replace(/\0/g, "")
                    }
                    const r = e.length;
                    let n, s, a, o = "",
                        l = 0;
                    for (; l < r;) {
                        if (n = e[l++], 0 === n && t) return o;
                        if (0 !== n && 3 !== n) switch (n >> 4) {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                o += String.fromCharCode(n);
                                break;
                            case 12:
                            case 13:
                                s = e[l++], o += String.fromCharCode((31 & n) << 6 | 63 & s);
                                break;
                            case 14:
                                s = e[l++], a = e[l++], o += String.fromCharCode((15 & n) << 12 | (63 & s) << 6 | 63 & a)
                        }
                    }
                    return o
                };
            let ct;

            function dt() {
                return ct || void 0 === self.TextDecoder || (ct = new self.TextDecoder("utf-8")), ct
            }
            const ut = function(e) {
                    let t = "";
                    for (let i = 0; i < e.length; i++) {
                        let r = e[i].toString(16);
                        r.length < 2 && (r = "0" + r), t += r
                    }
                    return t
                },
                ht = Math.pow(2, 32) - 1,
                ft = [].push,
                mt = {
                    video: 1,
                    audio: 2,
                    id3: 3,
                    text: 4
                };

            function pt(e) {
                return String.fromCharCode.apply(null, e)
            }

            function gt(e, t) {
                const i = e[t] << 8 | e[t + 1];
                return i < 0 ? 65536 + i : i
            }

            function yt(e, t) {
                const i = vt(e, t);
                return i < 0 ? 4294967296 + i : i
            }

            function vt(e, t) {
                return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
            }

            function bt(e, t, i) {
                e[t] = i >> 24, e[t + 1] = i >> 16 & 255, e[t + 2] = i >> 8 & 255, e[t + 3] = 255 & i
            }

            function Tt(e, t) {
                const i = [];
                if (!t.length) return i;
                const r = e.byteLength;
                for (let n = 0; n < r;) {
                    const s = yt(e, n),
                        a = s > 1 ? n + s : r;
                    if (pt(e.subarray(n + 4, n + 8)) === t[0])
                        if (1 === t.length) i.push(e.subarray(n + 8, a));
                        else {
                            const r = Tt(e.subarray(n + 8, a), t.slice(1));
                            r.length && ft.apply(i, r)
                        }
                    n = a
                }
                return i
            }

            function Et(e) {
                const t = [],
                    i = e[0];
                let r = 8;
                const n = yt(e, r);
                r += 4;
                r += 0 === i ? 8 : 16, r += 2;
                let s = e.length + 0;
                const a = gt(e, r);
                r += 2;
                for (let i = 0; i < a; i++) {
                    let i = r;
                    const a = yt(e, i);
                    i += 4;
                    const o = 2147483647 & a;
                    if (1 === (2147483648 & a) >>> 31) return Ee.warn("SIDX has hierarchical references (not supported)"), null;
                    const l = yt(e, i);
                    i += 4, t.push({
                        referenceSize: o,
                        subsegmentDuration: l,
                        info: {
                            duration: l / n,
                            start: s,
                            end: s + o - 1
                        }
                    }), s += o, i += 4, r = i
                }
                return {
                    earliestPresentationTime: 0,
                    timescale: n,
                    version: i,
                    referencesCount: a,
                    references: t
                }
            }

            function At(e) {
                const t = [],
                    i = Tt(e, ["moov", "trak"]);
                for (let e = 0; e < i.length; e++) {
                    const r = i[e],
                        n = Tt(r, ["tkhd"])[0];
                    if (n) {
                        let e = n[0],
                            i = 0 === e ? 12 : 20;
                        const s = yt(n, i),
                            a = Tt(r, ["mdia", "mdhd"])[0];
                        if (a) {
                            e = a[0], i = 0 === e ? 12 : 20;
                            const n = yt(a, i),
                                o = Tt(r, ["mdia", "hdlr"])[0];
                            if (o) {
                                const e = pt(o.subarray(8, 12)),
                                    i = {
                                        soun: Re,
                                        vide: De
                                    }[e];
                                if (i) {
                                    const e = Tt(r, ["mdia", "minf", "stbl", "stsd"])[0];
                                    let a;
                                    e && (a = pt(e.subarray(12, 16))), t[s] = {
                                        timescale: n,
                                        type: i
                                    }, t[i] = {
                                        timescale: n,
                                        id: s,
                                        codec: a
                                    }
                                }
                            }
                        }
                    }
                }
                return Tt(e, ["moov", "mvex", "trex"]).forEach((e => {
                    const i = yt(e, 4),
                        r = t[i];
                    r && (r.default = {
                        duration: yt(e, 12),
                        flags: yt(e, 20)
                    })
                })), t
            }

            function wt(e) {
                const t = Tt(e, ["schm"])[0];
                if (t) {
                    const i = pt(t.subarray(4, 8));
                    if ("cbcs" === i || "cenc" === i) return Tt(e, ["schi", "tenc"])[0]
                }
                return Ee.error("[eme] missing 'schm' box"), null
            }

            function _t(e) {
                const t = yt(e, 0);
                let i = 8;
                1 & t && (i += 4), 4 & t && (i += 4);
                let r = 0;
                const n = yt(e, 4);
                for (let s = 0; s < n; s++) {
                    if (256 & t) {
                        r += yt(e, i), i += 4
                    }
                    512 & t && (i += 4), 1024 & t && (i += 4), 2048 & t && (i += 4)
                }
                return r
            }

            function kt(e, t) {
                const i = new Uint8Array(e.length + t.length);
                return i.set(e), i.set(t, e.length), i
            }

            function St(e, t) {
                const i = [],
                    r = t.samples,
                    n = t.timescale,
                    s = t.id;
                let a = !1;
                return Tt(r, ["moof"]).map((o => {
                    const l = o.byteOffset - 8;
                    Tt(o, ["traf"]).map((o => {
                        const c = Tt(o, ["tfdt"]).map((e => {
                            const t = e[0];
                            let i = yt(e, 4);
                            return 1 === t && (i *= Math.pow(2, 32), i += yt(e, 8)), i / n
                        }))[0];
                        return void 0 !== c && (e = c), Tt(o, ["tfhd"]).map((c => {
                            const d = yt(c, 4),
                                u = 16777215 & yt(c, 0);
                            let h = 0;
                            const f = !!(16 & u);
                            let m = 0;
                            const p = !!(32 & u);
                            let g = 8;
                            d === s && (!!(1 & u) && (g += 8), !!(2 & u) && (g += 4), !!(8 & u) && (h = yt(c, g), g += 4), f && (m = yt(c, g), g += 4), p && (g += 4), "video" === t.type && (a = function(e) {
                                if (!e) return !1;
                                const t = e.indexOf("."),
                                    i = t < 0 ? e : e.substring(0, t);
                                return "hvc1" === i || "hev1" === i || "dvh1" === i || "dvhe" === i
                            }(t.codec)), Tt(o, ["trun"]).map((s => {
                                const o = s[0],
                                    c = 16777215 & yt(s, 0),
                                    d = !!(1 & c);
                                let u = 0;
                                const f = !!(4 & c),
                                    p = !!(256 & c);
                                let g = 0;
                                const y = !!(512 & c);
                                let v = 0;
                                const b = !!(1024 & c),
                                    T = !!(2048 & c);
                                let E = 0;
                                const A = yt(s, 4);
                                let w = 8;
                                d && (u = yt(s, w), w += 4), f && (w += 4);
                                let _ = u + l;
                                for (let l = 0; l < A; l++) {
                                    if (p ? (g = yt(s, w), w += 4) : g = h, y ? (v = yt(s, w), w += 4) : v = m, b && (w += 4), T && (E = 0 === o ? yt(s, w) : vt(s, w), w += 4), t.type === De) {
                                        let t = 0;
                                        for (; t < v;) {
                                            const s = yt(r, _);
                                            if (_ += 4, Lt(a, r[_])) {
                                                Rt(r.subarray(_, _ + s), a ? 2 : 1, e + E / n, i)
                                            }
                                            _ += s, t += s + 4
                                        }
                                    }
                                    e += g / n
                                }
                            })))
                        }))
                    }))
                })), i
            }

            function Lt(e, t) {
                if (e) {
                    const e = t >> 1 & 63;
                    return 39 === e || 40 === e
                }
                return 6 === (31 & t)
            }

            function Rt(e, t, i, r) {
                const n = Dt(e);
                let s = 0;
                s += t;
                let a = 0,
                    o = 0,
                    l = !1,
                    c = 0;
                for (; s < n.length;) {
                    a = 0;
                    do {
                        if (s >= n.length) break;
                        c = n[s++], a += c
                    } while (255 === c);
                    o = 0;
                    do {
                        if (s >= n.length) break;
                        c = n[s++], o += c
                    } while (255 === c);
                    const e = n.length - s;
                    if (!l && 4 === a && s < n.length) {
                        l = !0;
                        if (181 === n[s++]) {
                            const e = gt(n, s);
                            if (s += 2, 49 === e) {
                                const e = yt(n, s);
                                if (s += 4, 1195456820 === e) {
                                    const e = n[s++];
                                    if (3 === e) {
                                        const t = n[s++],
                                            o = 64 & t,
                                            l = o ? 2 + 3 * (31 & t) : 0,
                                            c = new Uint8Array(l);
                                        if (o) {
                                            c[0] = t;
                                            for (let e = 1; e < l; e++) c[e] = n[s++]
                                        }
                                        r.push({
                                            type: e,
                                            payloadType: a,
                                            pts: i,
                                            bytes: c
                                        })
                                    }
                                }
                            }
                        }
                    } else if (5 === a && o < e) {
                        if (l = !0, o > 16) {
                            const e = [];
                            for (let t = 0; t < 16; t++) {
                                const i = n[s++].toString(16);
                                e.push(1 == i.length ? "0" + i : i), 3 !== t && 5 !== t && 7 !== t && 9 !== t || e.push("-")
                            }
                            const t = o - 16,
                                l = new Uint8Array(t);
                            for (let e = 0; e < t; e++) l[e] = n[s++];
                            r.push({
                                payloadType: a,
                                pts: i,
                                uuid: e.join(""),
                                userData: lt(l),
                                userDataBytes: l
                            })
                        }
                    } else if (o < e) s += o;
                    else if (o > e) break
                }
            }

            function Dt(e) {
                const t = e.byteLength,
                    i = [];
                let r = 1;
                for (; r < t - 2;) 0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (i.push(r + 2), r += 2) : r++;
                if (0 === i.length) return e;
                const n = t - i.length,
                    s = new Uint8Array(n);
                let a = 0;
                for (r = 0; r < n; a++, r++) a === i[0] && (a++, i.shift()), s[r] = e[a];
                return s
            }

            function Ct(e, t, i) {
                if (16 !== e.byteLength) throw new RangeError("Invalid system id");
                let r, n, s;
                if (t) {
                    r = 1, n = new Uint8Array(16 * t.length);
                    for (let e = 0; e < t.length; e++) {
                        const i = t[e];
                        if (16 !== i.byteLength) throw new RangeError("Invalid key");
                        n.set(i, 16 * e)
                    }
                } else r = 0, n = new Uint8Array;
                r > 0 ? (s = new Uint8Array(4), t.length > 0 && new DataView(s.buffer).setUint32(0, t.length, !1)) : s = new Uint8Array;
                const a = new Uint8Array(4);
                return i && i.byteLength > 0 && new DataView(a.buffer).setUint32(0, i.byteLength, !1),
                    function(e, ...t) {
                        const i = t.length;
                        let r = 8,
                            n = i;
                        for (; n--;) r += t[n].byteLength;
                        const s = new Uint8Array(r);
                        for (s[0] = r >> 24 & 255, s[1] = r >> 16 & 255, s[2] = r >> 8 & 255, s[3] = 255 & r, s.set(e, 4), n = 0, r = 8; n < i; n++) s.set(t[n], r), r += t[n].byteLength;
                        return s
                    }([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), e, s, n, a, i || new Uint8Array)
            }
            let It = {};
            class Pt {
                static clearKeyUriToKeyIdMap() {
                    It = {}
                }
                constructor(e, t, i, r = [1], n = null) {
                    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = i, this.keyFormatVersions = r, this.iv = n, this.encrypted = !!e && "NONE" !== e, this.isCommonEncryption = this.encrypted && "AES-128" !== e
                }
                isSupported() {
                    if (this.method) {
                        if ("AES-128" === this.method || "NONE" === this.method) return !0;
                        if ("identity" === this.keyFormat) return "SAMPLE-AES" === this.method;
                        switch (this.keyFormat) {
                            case $e:
                            case je:
                            case He:
                            case Ue:
                                return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method)
                        }
                    }
                    return !1
                }
                getDecryptData(e) {
                    if (!this.encrypted || !this.uri) return null;
                    if ("AES-128" === this.method && this.uri && !this.iv) {
                        "number" != typeof e && ("AES-128" !== this.method || this.iv || Ee.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`), e = 0);
                        const t = function(e) {
                            const t = new Uint8Array(16);
                            for (let i = 12; i < 16; i++) t[i] = e >> 8 * (15 - i) & 255;
                            return t
                        }(e);
                        return new Pt(this.method, this.uri, "identity", this.keyFormatVersions, t)
                    }
                    const t = Ne(this.uri);
                    if (t) switch (this.keyFormat) {
                        case je:
                            this.pssh = t, t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6));
                            break;
                        case He:
                            {
                                const e = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);this.pssh = Ct(e, null, t);
                                const i = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2),
                                    r = String.fromCharCode.apply(null, Array.from(i)),
                                    n = r.substring(r.indexOf("<"), r.length),
                                    s = (new DOMParser).parseFromString(n, "text/xml").getElementsByTagName("KID")[0];
                                if (s) {
                                    const e = s.childNodes[0] ? s.childNodes[0].nodeValue : s.getAttribute("VALUE");
                                    if (e) {
                                        const t = Me(e).subarray(0, 16);
                                        ! function(e) {
                                            const t = function(e, t, i) {
                                                const r = e[t];
                                                e[t] = e[i], e[i] = r
                                            };
                                            t(e, 0, 3), t(e, 1, 2), t(e, 4, 5), t(e, 6, 7)
                                        }(t), this.keyId = t
                                    }
                                }
                                break
                            }
                        default:
                            {
                                let e = t.subarray(0, 16);
                                if (16 !== e.length) {
                                    const t = new Uint8Array(16);
                                    t.set(e, 16 - e.length), e = t
                                }
                                this.keyId = e;
                                break
                            }
                    }
                    if (!this.keyId || 16 !== this.keyId.byteLength) {
                        let e = It[this.uri];
                        if (!e) {
                            const t = Object.keys(It).length % Number.MAX_SAFE_INTEGER;
                            e = new Uint8Array(16);
                            new DataView(e.buffer, 12, 4).setUint32(0, t), It[this.uri] = e
                        }
                        this.keyId = e
                    }
                    return this
                }
            }
            const xt = /\{\$([a-zA-Z0-9-_]+)\}/g;

            function Ot(e) {
                return xt.test(e)
            }

            function Mt(e, t, i) {
                if (null !== e.variableList || e.hasVariableRefs)
                    for (let r = i.length; r--;) {
                        const n = i[r],
                            s = t[n];
                        s && (t[n] = Nt(e, s))
                    }
            }

            function Nt(e, t) {
                if (null !== e.variableList || e.hasVariableRefs) {
                    const i = e.variableList;
                    return t.replace(xt, (t => {
                        const r = t.substring(2, t.length - 1),
                            n = null == i ? void 0 : i[r];
                        return void 0 === n ? (e.playlistParsingError || (e.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${r}"`)), t) : n
                    }))
                }
                return t
            }

            function Ft(e, t, i) {
                let r, n, s = e.variableList;
                if (s || (e.variableList = s = {}), "QUERYPARAM" in t) {
                    r = t.QUERYPARAM;
                    try {
                        const e = new self.URL(i).searchParams;
                        if (!e.has(r)) throw new Error(`"${r}" does not match any query parameter in URI: "${i}"`);
                        n = e.get(r)
                    } catch (t) {
                        e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${t.message}`))
                    }
                } else r = t.NAME, n = t.VALUE;
                r in s ? e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${r}"`)) : s[r] = n || ""
            }

            function Bt(e, t, i) {
                const r = t.IMPORT;
                if (i && r in i) {
                    let t = e.variableList;
                    t || (e.variableList = t = {}), t[r] = i[r]
                } else e.playlistParsingError || (e.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`))
            }

            function Ut() {
                if ("undefined" != typeof self) return self.MediaSource || self.WebKitMediaSource
            }
            const $t = {
                    audio: {
                        a3ds: !0,
                        "ac-3": !0,
                        "ac-4": !0,
                        alac: !0,
                        alaw: !0,
                        dra1: !0,
                        "dts+": !0,
                        "dts-": !0,
                        dtsc: !0,
                        dtse: !0,
                        dtsh: !0,
                        "ec-3": !0,
                        enca: !0,
                        g719: !0,
                        g726: !0,
                        m4ae: !0,
                        mha1: !0,
                        mha2: !0,
                        mhm1: !0,
                        mhm2: !0,
                        mlpa: !0,
                        mp4a: !0,
                        "raw ": !0,
                        Opus: !0,
                        opus: !0,
                        samr: !0,
                        sawb: !0,
                        sawp: !0,
                        sevc: !0,
                        sqcp: !0,
                        ssmv: !0,
                        twos: !0,
                        ulaw: !0
                    },
                    video: {
                        avc1: !0,
                        avc2: !0,
                        avc3: !0,
                        avc4: !0,
                        avcp: !0,
                        av01: !0,
                        drac: !0,
                        dva1: !0,
                        dvav: !0,
                        dvh1: !0,
                        dvhe: !0,
                        encv: !0,
                        hev1: !0,
                        hvc1: !0,
                        mjp2: !0,
                        mp4v: !0,
                        mvc1: !0,
                        mvc2: !0,
                        mvc3: !0,
                        mvc4: !0,
                        resv: !0,
                        rv60: !0,
                        s263: !0,
                        svc1: !0,
                        svc2: !0,
                        "vc-1": !0,
                        vp08: !0,
                        vp09: !0
                    },
                    text: {
                        stpp: !0,
                        wvtt: !0
                    }
                },
                Ht = Ut();

            function jt(e, t) {
                var i;
                return null != (i = null == Ht ? void 0 : Ht.isTypeSupported(`${t||"video"}/mp4;codecs="${e}"`)) && i
            }
            const Gt = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
                Vt = /#EXT-X-MEDIA:(.*)/g,
                qt = /^#EXT(?:INF|-X-TARGETDURATION):/m,
                Kt = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
                Wt = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
            class Yt {
                static findGroup(e, t) {
                    for (let i = 0; i < e.length; i++) {
                        const r = e[i];
                        if (r.id === t) return r
                    }
                }
                static convertAVC1ToAVCOTI(e) {
                    const t = e.split(".");
                    if (t.length > 2) {
                        let e = t.shift() + ".";
                        return e += parseInt(t.shift()).toString(16), e += ("000" + parseInt(t.shift()).toString(16)).slice(-4), e
                    }
                    return e
                }
                static resolve(e, t) {
                    return ae.buildAbsoluteURL(t, e, {
                        alwaysNormalize: !0
                    })
                }
                static isMediaPlaylist(e) {
                    return qt.test(e)
                }
                static parseMasterPlaylist(e, t) {
                    const i = {
                            contentSteering: null,
                            levels: [],
                            playlistParsingError: null,
                            sessionData: null,
                            sessionKeys: null,
                            startTimeOffset: null,
                            variableList: null,
                            hasVariableRefs: Ot(e)
                        },
                        r = [];
                    let n;
                    for (Gt.lastIndex = 0; null != (n = Gt.exec(e));)
                        if (n[1]) {
                            var s;
                            const e = new _e(n[1]);
                            Mt(i, e, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
                            const a = Nt(i, n[2]),
                                o = {
                                    attrs: e,
                                    bitrate: e.decimalInteger("AVERAGE-BANDWIDTH") || e.decimalInteger("BANDWIDTH"),
                                    name: e.NAME,
                                    url: Yt.resolve(a, t)
                                },
                                l = e.decimalResolution("RESOLUTION");
                            l && (o.width = l.width, o.height = l.height), Qt((e.CODECS || "").split(/[ ,]+/).filter((e => e)), o), o.videoCodec && -1 !== o.videoCodec.indexOf("avc1") && (o.videoCodec = Yt.convertAVC1ToAVCOTI(o.videoCodec)), null != (s = o.unknownCodecs) && s.length || r.push(o), i.levels.push(o)
                        } else if (n[3]) {
                        const e = n[3],
                            r = n[4];
                        switch (e) {
                            case "SESSION-DATA":
                                {
                                    const e = new _e(r);Mt(i, e, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
                                    const t = e["DATA-ID"];t && (null === i.sessionData && (i.sessionData = {}), i.sessionData[t] = e);
                                    break
                                }
                            case "SESSION-KEY":
                                {
                                    const e = zt(r, t, i);e.encrypted && e.isSupported() ? (null === i.sessionKeys && (i.sessionKeys = []), i.sessionKeys.push(e)) : Ee.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${r}"`);
                                    break
                                }
                            case "DEFINE":
                                {
                                    const e = new _e(r);Mt(i, e, ["NAME", "VALUE", "QUERYPARAM"]),
                                    Ft(i, e, t)
                                }
                                break;
                            case "CONTENT-STEERING":
                                {
                                    const e = new _e(r);Mt(i, e, ["SERVER-URI", "PATHWAY-ID"]),
                                    i.contentSteering = {
                                        uri: Yt.resolve(e["SERVER-URI"], t),
                                        pathwayId: e["PATHWAY-ID"] || "."
                                    };
                                    break
                                }
                            case "START":
                                i.startTimeOffset = Xt(r)
                        }
                    }
                    const a = r.length > 0 && r.length < i.levels.length;
                    return i.levels = a ? r : i.levels, 0 === i.levels.length && (i.playlistParsingError = new Error("no levels found in manifest")), i
                }
                static parseMasterPlaylistMedia(e, t, i) {
                    let r;
                    const n = {},
                        s = i.levels,
                        a = {
                            AUDIO: s.map((e => ({
                                id: e.attrs.AUDIO,
                                audioCodec: e.audioCodec
                            }))),
                            SUBTITLES: s.map((e => ({
                                id: e.attrs.SUBTITLES,
                                textCodec: e.textCodec
                            }))),
                            "CLOSED-CAPTIONS": []
                        };
                    let o = 0;
                    for (Vt.lastIndex = 0; null !== (r = Vt.exec(e));) {
                        const e = new _e(r[1]),
                            s = e.TYPE;
                        if (s) {
                            const r = a[s],
                                l = n[s] || [];
                            n[s] = l, Mt(i, e, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
                            const c = {
                                attrs: e,
                                bitrate: 0,
                                id: o++,
                                groupId: e["GROUP-ID"] || "",
                                instreamId: e["INSTREAM-ID"],
                                name: e.NAME || e.LANGUAGE || "",
                                type: s,
                                default: e.bool("DEFAULT"),
                                autoselect: e.bool("AUTOSELECT"),
                                forced: e.bool("FORCED"),
                                lang: e.LANGUAGE,
                                url: e.URI ? Yt.resolve(e.URI, t) : ""
                            };
                            if (null != r && r.length) {
                                const e = Yt.findGroup(r, c.groupId) || r[0];
                                Jt(c, e, "audioCodec"), Jt(c, e, "textCodec")
                            }
                            l.push(c)
                        }
                    }
                    return n
                }
                static parseLevelPlaylist(e, t, i, r, n, s) {
                    const a = new Oe(t),
                        o = a.fragments;
                    let l, c, d, u = null,
                        h = 0,
                        f = 0,
                        m = 0,
                        p = 0,
                        g = null,
                        y = new Pe(r, t),
                        v = -1,
                        b = !1;
                    for (Kt.lastIndex = 0, a.m3u8 = e, a.hasVariableRefs = Ot(e); null !== (l = Kt.exec(e));) {
                        b && (b = !1, y = new Pe(r, t), y.start = m, y.sn = h, y.cc = p, y.level = i, u && (y.initSegment = u, y.rawProgramDateTime = u.rawProgramDateTime, u.rawProgramDateTime = null));
                        const e = l[1];
                        if (e) {
                            y.duration = parseFloat(e);
                            const t = (" " + l[2]).slice(1);
                            y.title = t || null, y.tagList.push(t ? ["INF", e, t] : ["INF", e])
                        } else if (l[3]) {
                            if (ue(y.duration)) {
                                y.start = m, d && ti(y, d, a), y.sn = h, y.level = i, y.cc = p, y.urlId = n, o.push(y);
                                const e = (" " + l[3]).slice(1);
                                y.relurl = Nt(a, e), Zt(y, g), g = y, m += y.duration, h++, f = 0, b = !0
                            }
                        } else if (l[4]) {
                            const e = (" " + l[4]).slice(1);
                            g ? y.setByteRange(e, g) : y.setByteRange(e)
                        } else if (l[5]) y.rawProgramDateTime = (" " + l[5]).slice(1), y.tagList.push(["PROGRAM-DATE-TIME", y.rawProgramDateTime]), -1 === v && (v = o.length);
                        else {
                            if (l = l[0].match(Wt), !l) {
                                Ee.warn("No matches on slow regex match for level playlist!");
                                continue
                            }
                            for (c = 1; c < l.length && void 0 === l[c]; c++);
                            const e = (" " + l[c]).slice(1),
                                n = (" " + l[c + 1]).slice(1),
                                m = l[c + 2] ? (" " + l[c + 2]).slice(1) : "";
                            switch (e) {
                                case "PLAYLIST-TYPE":
                                    a.type = n.toUpperCase();
                                    break;
                                case "MEDIA-SEQUENCE":
                                    h = a.startSN = parseInt(n);
                                    break;
                                case "SKIP":
                                    {
                                        const e = new _e(n);Mt(a, e, ["RECENTLY-REMOVED-DATERANGES"]);
                                        const t = e.decimalInteger("SKIPPED-SEGMENTS");
                                        if (ue(t)) {
                                            a.skippedSegments = t;
                                            for (let e = t; e--;) o.unshift(null);
                                            h += t
                                        }
                                        const i = e.enumeratedString("RECENTLY-REMOVED-DATERANGES");i && (a.recentlyRemovedDateranges = i.split("\t"));
                                        break
                                    }
                                case "TARGETDURATION":
                                    a.targetduration = Math.max(parseInt(n), 1);
                                    break;
                                case "VERSION":
                                    a.version = parseInt(n);
                                    break;
                                case "EXTM3U":
                                    break;
                                case "ENDLIST":
                                    a.live = !1;
                                    break;
                                case "#":
                                    (n || m) && y.tagList.push(m ? [n, m] : [n]);
                                    break;
                                case "DISCONTINUITY":
                                    p++, y.tagList.push(["DIS"]);
                                    break;
                                case "GAP":
                                    y.gap = !0, y.tagList.push([e]);
                                    break;
                                case "BITRATE":
                                    y.tagList.push([e, n]);
                                    break;
                                case "DATERANGE":
                                    {
                                        const e = new _e(n);Mt(a, e, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]),
                                        Mt(a, e, e.clientAttrs);
                                        const t = new Se(e, a.dateRanges[e.ID]);t.isValid || a.skippedSegments ? a.dateRanges[t.id] = t : Ee.warn(`Ignoring invalid DATERANGE tag: "${n}"`),
                                        y.tagList.push(["EXT-X-DATERANGE", n]);
                                        break
                                    }
                                case "DEFINE":
                                    {
                                        const e = new _e(n);Mt(a, e, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]),
                                        "IMPORT" in e ? Bt(a, e, s) : Ft(a, e, t)
                                    }
                                    break;
                                case "DISCONTINUITY-SEQUENCE":
                                    p = parseInt(n);
                                    break;
                                case "KEY":
                                    {
                                        const e = zt(n, t, a);
                                        if (e.isSupported()) {
                                            if ("NONE" === e.method) {
                                                d = void 0;
                                                break
                                            }
                                            d || (d = {}), d[e.keyFormat] && (d = de({}, d)), d[e.keyFormat] = e
                                        } else Ee.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${n}"`);
                                        break
                                    }
                                case "START":
                                    a.startTimeOffset = Xt(n);
                                    break;
                                case "MAP":
                                    {
                                        const e = new _e(n);
                                        if (Mt(a, e, ["BYTERANGE", "URI"]), y.duration) {
                                            const n = new Pe(r, t);
                                            ei(n, e, i, d), u = n, y.initSegment = u, u.rawProgramDateTime && !y.rawProgramDateTime && (y.rawProgramDateTime = u.rawProgramDateTime)
                                        } else ei(y, e, i, d),
                                        u = y,
                                        b = !0;
                                        break
                                    }
                                case "SERVER-CONTROL":
                                    {
                                        const e = new _e(n);a.canBlockReload = e.bool("CAN-BLOCK-RELOAD"),
                                        a.canSkipUntil = e.optionalFloat("CAN-SKIP-UNTIL", 0),
                                        a.canSkipDateRanges = a.canSkipUntil > 0 && e.bool("CAN-SKIP-DATERANGES"),
                                        a.partHoldBack = e.optionalFloat("PART-HOLD-BACK", 0),
                                        a.holdBack = e.optionalFloat("HOLD-BACK", 0);
                                        break
                                    }
                                case "PART-INF":
                                    {
                                        const e = new _e(n);a.partTarget = e.decimalFloatingPoint("PART-TARGET");
                                        break
                                    }
                                case "PART":
                                    {
                                        let e = a.partList;e || (e = a.partList = []);
                                        const i = f > 0 ? e[e.length - 1] : void 0,
                                            r = f++,
                                            s = new _e(n);Mt(a, s, ["BYTERANGE", "URI"]);
                                        const o = new xe(s, y, t, r, i);e.push(o),
                                        y.duration += o.duration;
                                        break
                                    }
                                case "PRELOAD-HINT":
                                    {
                                        const e = new _e(n);Mt(a, e, ["URI"]),
                                        a.preloadHint = e;
                                        break
                                    }
                                case "RENDITION-REPORT":
                                    {
                                        const e = new _e(n);Mt(a, e, ["URI"]),
                                        a.renditionReports = a.renditionReports || [],
                                        a.renditionReports.push(e);
                                        break
                                    }
                                default:
                                    Ee.warn(`line parsed but not handled: ${l}`)
                            }
                        }
                    }
                    g && !g.relurl ? (o.pop(), m -= g.duration, a.partList && (a.fragmentHint = g)) : a.partList && (Zt(y, g), y.cc = p, a.fragmentHint = y, d && ti(y, d, a));
                    const T = o.length,
                        E = o[0],
                        A = o[T - 1];
                    if (m += a.skippedSegments * a.targetduration, m > 0 && T && A) {
                        a.averagetargetduration = m / T;
                        const e = A.sn;
                        a.endSN = "initSegment" !== e ? e : 0, a.live || (A.endList = !0), E && (a.startCC = E.cc)
                    } else a.endSN = 0, a.startCC = 0;
                    return a.fragmentHint && (m += a.fragmentHint.duration), a.totalduration = m, a.endCC = p, v > 0 && function(e, t) {
                        let i = e[t];
                        for (let r = t; r--;) {
                            const t = e[r];
                            if (!t) return;
                            t.programDateTime = i.programDateTime - 1e3 * t.duration, i = t
                        }
                    }(o, v), a
                }
            }

            function zt(e, t, i) {
                var r, n;
                const s = new _e(e);
                Mt(i, s, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
                const a = null != (r = s.METHOD) ? r : "",
                    o = s.URI,
                    l = s.hexadecimalInteger("IV"),
                    c = s.KEYFORMATVERSIONS,
                    d = null != (n = s.KEYFORMAT) ? n : "identity";
                o && s.IV && !l && Ee.error(`Invalid IV: ${s.IV}`);
                const u = o ? Yt.resolve(o, t) : "",
                    h = (c || "1").split("/").map(Number).filter(Number.isFinite);
                return new Pt(a, u, d, h, l)
            }

            function Xt(e) {
                const t = new _e(e).decimalFloatingPoint("TIME-OFFSET");
                return ue(t) ? t : null
            }

            function Qt(e, t) {
                ["video", "audio", "text"].forEach((i => {
                    const r = e.filter((e => function(e, t) {
                        const i = $t[t];
                        return !!i && !0 === i[e.slice(0, 4)]
                    }(e, i)));
                    if (r.length) {
                        const n = r.filter((e => 0 === e.lastIndexOf("avc1", 0) || 0 === e.lastIndexOf("mp4a", 0)));
                        t[`${i}Codec`] = n.length > 0 ? n[0] : r[0], e = e.filter((e => -1 === r.indexOf(e)))
                    }
                })), t.unknownCodecs = e
            }

            function Jt(e, t, i) {
                const r = t[i];
                r && (e[i] = r)
            }

            function Zt(e, t) {
                e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), ue(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null)
            }

            function ei(e, t, i, r) {
                e.relurl = t.URI, t.BYTERANGE && e.setByteRange(t.BYTERANGE), e.level = i, e.sn = "initSegment", r && (e.levelkeys = r), e.initSegment = null
            }

            function ti(e, t, i) {
                e.levelkeys = t;
                const {
                    encryptedFragments: r
                } = i;
                r.length && r[r.length - 1].levelkeys === t || !Object.keys(t).some((e => t[e].isCommonEncryption)) || r.push(e)
            }
            var ii = "manifest",
                ri = "level",
                ni = "audioTrack",
                si = "subtitleTrack",
                ai = "main",
                oi = "audio",
                li = "subtitle";

            function ci(e) {
                const {
                    type: t
                } = e;
                switch (t) {
                    case ni:
                        return oi;
                    case si:
                        return li;
                    default:
                        return ai
                }
            }

            function di(e, t) {
                let i = e.url;
                return void 0 !== i && 0 !== i.indexOf("data:") || (i = t.url), i
            }
            class ui {
                constructor(e) {
                    this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners()
                }
                startLoad(e) {}
                stopLoad() {
                    this.destroyInternalLoaders()
                }
                registerListeners() {
                    const {
                        hls: e
                    } = this;
                    e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.LEVEL_LOADING, this.onLevelLoading, this), e.on(me.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(me.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                }
                unregisterListeners() {
                    const {
                        hls: e
                    } = this;
                    e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.LEVEL_LOADING, this.onLevelLoading, this), e.off(me.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(me.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                }
                createInternalLoader(e) {
                    const t = this.hls.config,
                        i = t.pLoader,
                        r = t.loader,
                        n = new(i || r)(t);
                    return this.loaders[e.type] = n, n
                }
                getInternalLoader(e) {
                    return this.loaders[e.type]
                }
                resetInternalLoader(e) {
                    this.loaders[e] && delete this.loaders[e]
                }
                destroyInternalLoaders() {
                    for (const e in this.loaders) {
                        const t = this.loaders[e];
                        t && t.destroy(), this.resetInternalLoader(e)
                    }
                }
                destroy() {
                    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders()
                }
                onManifestLoading(e, t) {
                    const {
                        url: i
                    } = t;
                    this.variableList = null, this.load({
                        id: null,
                        level: 0,
                        responseType: "text",
                        type: ii,
                        url: i,
                        deliveryDirectives: null
                    })
                }
                onLevelLoading(e, t) {
                    const {
                        id: i,
                        level: r,
                        url: n,
                        deliveryDirectives: s
                    } = t;
                    this.load({
                        id: i,
                        level: r,
                        responseType: "text",
                        type: ri,
                        url: n,
                        deliveryDirectives: s
                    })
                }
                onAudioTrackLoading(e, t) {
                    const {
                        id: i,
                        groupId: r,
                        url: n,
                        deliveryDirectives: s
                    } = t;
                    this.load({
                        id: i,
                        groupId: r,
                        level: null,
                        responseType: "text",
                        type: ni,
                        url: n,
                        deliveryDirectives: s
                    })
                }
                onSubtitleTrackLoading(e, t) {
                    const {
                        id: i,
                        groupId: r,
                        url: n,
                        deliveryDirectives: s
                    } = t;
                    this.load({
                        id: i,
                        groupId: r,
                        level: null,
                        responseType: "text",
                        type: si,
                        url: n,
                        deliveryDirectives: s
                    })
                }
                load(e) {
                    var t;
                    const i = this.hls.config;
                    let r, n = this.getInternalLoader(e);
                    if (n) {
                        const t = n.context;
                        if (t && t.url === e.url) return void Ee.trace("[playlist-loader]: playlist request ongoing");
                        Ee.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), n.abort()
                    }
                    if (r = e.type === ii ? i.manifestLoadPolicy.default : de({}, i.playlistLoadPolicy.default, {
                            timeoutRetry: null,
                            errorRetry: null
                        }), n = this.createInternalLoader(e), null != (t = e.deliveryDirectives) && t.part) {
                        let t;
                        if (e.type === ri && null !== e.level ? t = this.hls.levels[e.level].details : e.type === ni && null !== e.id ? t = this.hls.audioTracks[e.id].details : e.type === si && null !== e.id && (t = this.hls.subtitleTracks[e.id].details), t) {
                            const e = t.partTarget,
                                i = t.targetduration;
                            if (e && i) {
                                const t = 1e3 * Math.max(3 * e, .8 * i);
                                r = de({}, r, {
                                    maxTimeToFirstByteMs: Math.min(t, r.maxTimeToFirstByteMs),
                                    maxLoadTimeMs: Math.min(t, r.maxTimeToFirstByteMs)
                                })
                            }
                        }
                    }
                    const s = r.errorRetry || r.timeoutRetry || {},
                        a = {
                            loadPolicy: r,
                            timeout: r.maxLoadTimeMs,
                            maxRetry: s.maxNumRetry || 0,
                            retryDelay: s.retryDelayMs || 0,
                            maxRetryDelay: s.maxRetryDelayMs || 0
                        },
                        o = {
                            onSuccess: (e, t, i, r) => {
                                const n = this.getInternalLoader(i);
                                this.resetInternalLoader(i.type);
                                const s = e.data;
                                0 === s.indexOf("#EXTM3U") ? (t.parsing.start = performance.now(), Yt.isMediaPlaylist(s) ? this.handleTrackOrLevelPlaylist(e, t, i, r || null, n) : this.handleMasterPlaylist(e, t, i, r)) : this.handleManifestParsingError(e, i, new Error("no EXTM3U delimiter"), r || null, t)
                            },
                            onError: (e, t, i, r) => {
                                this.handleNetworkError(t, i, !1, e, r)
                            },
                            onTimeout: (e, t, i) => {
                                this.handleNetworkError(t, i, !0, void 0, e)
                            }
                        };
                    n.load(e, a, o)
                }
                handleMasterPlaylist(e, t, i, r) {
                    const n = this.hls,
                        s = e.data,
                        a = di(e, i),
                        o = Yt.parseMasterPlaylist(s, a);
                    if (o.playlistParsingError) return void this.handleManifestParsingError(e, i, o.playlistParsingError, r, t);
                    const {
                        contentSteering: l,
                        levels: c,
                        sessionData: d,
                        sessionKeys: u,
                        startTimeOffset: h,
                        variableList: f
                    } = o;
                    this.variableList = f;
                    const {
                        AUDIO: m = [],
                        SUBTITLES: p,
                        "CLOSED-CAPTIONS": g
                    } = Yt.parseMasterPlaylistMedia(s, a, o);
                    if (m.length) {
                        m.some((e => !e.url)) || !c[0].audioCodec || c[0].attrs.AUDIO || (Ee.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), m.unshift({
                            type: "main",
                            name: "main",
                            groupId: "main",
                            default: !1,
                            autoselect: !1,
                            forced: !1,
                            id: -1,
                            attrs: new _e({}),
                            bitrate: 0,
                            url: ""
                        }))
                    }
                    n.trigger(me.MANIFEST_LOADED, {
                        levels: c,
                        audioTracks: m,
                        subtitles: p,
                        captions: g,
                        contentSteering: l,
                        url: a,
                        stats: t,
                        networkDetails: r,
                        sessionData: d,
                        sessionKeys: u,
                        startTimeOffset: h,
                        variableList: f
                    })
                }
                handleTrackOrLevelPlaylist(e, t, i, r, n) {
                    const s = this.hls,
                        {
                            id: a,
                            level: o,
                            type: l
                        } = i,
                        c = di(e, i),
                        d = ue(a) ? a : 0,
                        u = ue(o) ? o : d,
                        h = ci(i),
                        f = Yt.parseLevelPlaylist(e.data, c, u, h, d, this.variableList);
                    if (l === ii) {
                        const e = {
                            attrs: new _e({}),
                            bitrate: 0,
                            details: f,
                            name: "",
                            url: c
                        };
                        s.trigger(me.MANIFEST_LOADED, {
                            levels: [e],
                            audioTracks: [],
                            url: c,
                            stats: t,
                            networkDetails: r,
                            sessionData: null,
                            sessionKeys: null,
                            contentSteering: null,
                            startTimeOffset: null,
                            variableList: null
                        })
                    }
                    t.parsing.end = performance.now(), i.levelDetails = f, this.handlePlaylistLoaded(f, e, t, i, r, n)
                }
                handleManifestParsingError(e, t, i, r, n) {
                    this.hls.trigger(me.ERROR, {
                        type: pe.NETWORK_ERROR,
                        details: ge.MANIFEST_PARSING_ERROR,
                        fatal: t.type === ii,
                        url: e.url,
                        err: i,
                        error: i,
                        reason: i.message,
                        response: e,
                        context: t,
                        networkDetails: r,
                        stats: n
                    })
                }
                handleNetworkError(e, t, i = !1, r, n) {
                    let s = `A network ${i?"timeout":"error"+(r?" (status "+r.code+")":"")} occurred while loading ${e.type}`;
                    e.type === ri ? s += `: ${e.level} id: ${e.id}` : e.type !== ni && e.type !== si || (s += ` id: ${e.id} group-id: "${e.groupId}"`);
                    const a = new Error(s);
                    Ee.warn(`[playlist-loader]: ${s}`);
                    let o = ge.UNKNOWN,
                        l = !1;
                    const c = this.getInternalLoader(e);
                    switch (e.type) {
                        case ii:
                            o = i ? ge.MANIFEST_LOAD_TIMEOUT : ge.MANIFEST_LOAD_ERROR, l = !0;
                            break;
                        case ri:
                            o = i ? ge.LEVEL_LOAD_TIMEOUT : ge.LEVEL_LOAD_ERROR, l = !1;
                            break;
                        case ni:
                            o = i ? ge.AUDIO_TRACK_LOAD_TIMEOUT : ge.AUDIO_TRACK_LOAD_ERROR, l = !1;
                            break;
                        case si:
                            o = i ? ge.SUBTITLE_TRACK_LOAD_TIMEOUT : ge.SUBTITLE_LOAD_ERROR, l = !1
                    }
                    c && this.resetInternalLoader(e.type);
                    const d = {
                        type: pe.NETWORK_ERROR,
                        details: o,
                        fatal: l,
                        url: e.url,
                        loader: c,
                        context: e,
                        error: a,
                        networkDetails: t,
                        stats: n
                    };
                    if (r) {
                        const i = (null == t ? void 0 : t.url) || e.url;
                        d.response = le({
                            url: i,
                            data: void 0
                        }, r)
                    }
                    this.hls.trigger(me.ERROR, d)
                }
                handlePlaylistLoaded(e, t, i, r, n, s) {
                    const a = this.hls,
                        {
                            type: o,
                            level: l,
                            id: c,
                            groupId: d,
                            deliveryDirectives: u
                        } = r,
                        h = di(t, r),
                        f = ci(r),
                        m = "number" == typeof r.level && f === ai ? l : void 0;
                    if (!e.fragments.length) {
                        const e = new Error("No Segments found in Playlist");
                        return void a.trigger(me.ERROR, {
                            type: pe.NETWORK_ERROR,
                            details: ge.LEVEL_EMPTY_ERROR,
                            fatal: !1,
                            url: h,
                            error: e,
                            reason: e.message,
                            response: t,
                            context: r,
                            level: m,
                            parent: f,
                            networkDetails: n,
                            stats: i
                        })
                    }
                    e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
                    const p = e.playlistParsingError;
                    if (p) a.trigger(me.ERROR, {
                        type: pe.NETWORK_ERROR,
                        details: ge.LEVEL_PARSING_ERROR,
                        fatal: !1,
                        url: h,
                        error: p,
                        reason: p.message,
                        response: t,
                        context: r,
                        level: m,
                        parent: f,
                        networkDetails: n,
                        stats: i
                    });
                    else switch (e.live && s && (s.getCacheAge && (e.ageHeader = s.getCacheAge() || 0), s.getCacheAge && !isNaN(e.ageHeader) || (e.ageHeader = 0)), o) {
                        case ii:
                        case ri:
                            a.trigger(me.LEVEL_LOADED, {
                                details: e,
                                level: m || 0,
                                id: c || 0,
                                stats: i,
                                networkDetails: n,
                                deliveryDirectives: u
                            });
                            break;
                        case ni:
                            a.trigger(me.AUDIO_TRACK_LOADED, {
                                details: e,
                                id: c || 0,
                                groupId: d || "",
                                stats: i,
                                networkDetails: n,
                                deliveryDirectives: u
                            });
                            break;
                        case si:
                            a.trigger(me.SUBTITLE_TRACK_LOADED, {
                                details: e,
                                id: c || 0,
                                groupId: d || "",
                                stats: i,
                                networkDetails: n,
                                deliveryDirectives: u
                            })
                    }
                }
            }

            function hi(e, t) {
                let i;
                try {
                    i = new Event("addtrack")
                } catch (e) {
                    i = document.createEvent("Event"), i.initEvent("addtrack", !1, !1)
                }
                i.track = e, t.dispatchEvent(i)
            }

            function fi(e, t) {
                const i = e.mode;
                if ("disabled" === i && (e.mode = "hidden"), e.cues && !e.cues.getCueById(t.id)) try {
                    if (e.addCue(t), !e.cues.getCueById(t.id)) throw new Error(`addCue is failed for: ${t}`)
                } catch (i) {
                    Ee.debug(`[texttrack-utils]: ${i}`);
                    try {
                        const i = new self.TextTrackCue(t.startTime, t.endTime, t.text);
                        i.id = t.id, e.addCue(i)
                    } catch (e) {
                        Ee.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${e}`)
                    }
                }
                "disabled" === i && (e.mode = i)
            }

            function mi(e) {
                const t = e.mode;
                if ("disabled" === t && (e.mode = "hidden"), e.cues)
                    for (let t = e.cues.length; t--;) e.removeCue(e.cues[t]);
                "disabled" === t && (e.mode = t)
            }

            function pi(e, t, i, r) {
                const n = e.mode;
                if ("disabled" === n && (e.mode = "hidden"), e.cues && e.cues.length > 0) {
                    const n = function(e, t, i) {
                        const r = [],
                            n = function(e, t) {
                                if (t < e[0].startTime) return 0;
                                const i = e.length - 1;
                                if (t > e[i].endTime) return -1;
                                let r = 0,
                                    n = i;
                                for (; r <= n;) {
                                    const s = Math.floor((n + r) / 2);
                                    if (t < e[s].startTime) n = s - 1;
                                    else {
                                        if (!(t > e[s].startTime && r < i)) return s;
                                        r = s + 1
                                    }
                                }
                                return e[r].startTime - t < t - e[n].startTime ? r : n
                            }(e, t);
                        if (n > -1)
                            for (let s = n, a = e.length; s < a; s++) {
                                const n = e[s];
                                if (n.startTime >= t && n.endTime <= i) r.push(n);
                                else if (n.startTime > i) return r
                            }
                        return r
                    }(e.cues, t, i);
                    for (let t = 0; t < n.length; t++) r && !r(n[t]) || e.removeCue(n[t])
                }
                "disabled" === n && (e.mode = n)
            }
            var gi = "org.id3",
                yi = "com.apple.quicktime.HLS",
                vi = "https://aomedia.org/emsg/ID3";

            function bi() {
                if ("undefined" != typeof self) return self.VTTCue || self.TextTrackCue
            }

            function Ti(e, t, i, r, n) {
                let s = new e(t, i, "");
                try {
                    s.value = r, n && (s.type = n)
                } catch (a) {
                    s = new e(t, i, JSON.stringify(n ? le({
                        type: n
                    }, r) : r))
                }
                return s
            }
            const Ei = (() => {
                const e = bi();
                try {
                    e && new e(0, Number.POSITIVE_INFINITY, "")
                } catch (e) {
                    return Number.MAX_VALUE
                }
                return Number.POSITIVE_INFINITY
            })();

            function Ai(e, t) {
                return e.getTime() / 1e3 - t
            }
            class wi {
                constructor(e) {
                    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners()
                }
                destroy() {
                    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null
                }
                _registerListeners() {
                    const {
                        hls: e
                    } = this;
                    e.on(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(me.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(me.LEVEL_UPDATED, this.onLevelUpdated, this)
                }
                _unregisterListeners() {
                    const {
                        hls: e
                    } = this;
                    e.off(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(me.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(me.LEVEL_UPDATED, this.onLevelUpdated, this)
                }
                onMediaAttached(e, t) {
                    this.media = t.media
                }
                onMediaDetaching() {
                    this.id3Track && (mi(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {})
                }
                onManifestLoading() {
                    this.dateRangeCuesAppended = {}
                }
                createTrack(e) {
                    const t = this.getID3Track(e.textTracks);
                    return t.mode = "hidden", t
                }
                getID3Track(e) {
                    if (this.media) {
                        for (let t = 0; t < e.length; t++) {
                            const i = e[t];
                            if ("metadata" === i.kind && "id3" === i.label) return hi(i, this.media), i
                        }
                        return this.media.addTextTrack("metadata", "id3")
                    }
                }
                onFragParsingMetadata(e, t) {
                    if (!this.media) return;
                    const {
                        hls: {
                            config: {
                                enableEmsgMetadataCues: i,
                                enableID3MetadataCues: r
                            }
                        }
                    } = this;
                    if (!i && !r) return;
                    const {
                        samples: n
                    } = t;
                    this.id3Track || (this.id3Track = this.createTrack(this.media));
                    const s = bi();
                    if (s)
                        for (let e = 0; e < n.length; e++) {
                            const t = n[e].type;
                            if (t === vi && !i || !r) continue;
                            const a = it(n[e].data);
                            if (a) {
                                const i = n[e].pts;
                                let r = i + n[e].duration;
                                r > Ei && (r = Ei);
                                r - i <= 0 && (r = i + .25);
                                for (let e = 0; e < a.length; e++) {
                                    const n = a[e];
                                    if (!et(n)) {
                                        this.updateId3CueEnds(i, t);
                                        const e = Ti(s, i, r, n, t);
                                        e && this.id3Track.addCue(e)
                                    }
                                }
                            }
                        }
                }
                updateId3CueEnds(e, t) {
                    var i;
                    const r = null == (i = this.id3Track) ? void 0 : i.cues;
                    if (r)
                        for (let i = r.length; i--;) {
                            const n = r[i];
                            n.type === t && n.startTime < e && n.endTime === Ei && (n.endTime = e)
                        }
                }
                onBufferFlushing(e, {
                    startOffset: t,
                    endOffset: i,
                    type: r
                }) {
                    const {
                        id3Track: n,
                        hls: s
                    } = this;
                    if (!s) return;
                    const {
                        config: {
                            enableEmsgMetadataCues: a,
                            enableID3MetadataCues: o
                        }
                    } = s;
                    if (n && (a || o)) {
                        let e;
                        e = "audio" === r ? e => e.type === gi && o : "video" === r ? e => e.type === vi && a : e => e.type === gi && o || e.type === vi && a, pi(n, t, i, e)
                    }
                }
                onLevelUpdated(e, {
                    details: t
                }) {
                    if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return;
                    const {
                        dateRangeCuesAppended: i,
                        id3Track: r
                    } = this, {
                        dateRanges: n
                    } = t, s = Object.keys(n);
                    if (r) {
                        const e = Object.keys(i).filter((e => !s.includes(e)));
                        for (let t = e.length; t--;) {
                            const n = e[t];
                            Object.keys(i[n].cues).forEach((e => {
                                r.removeCue(i[n].cues[e])
                            })), delete i[n]
                        }
                    }
                    const a = t.fragments[t.fragments.length - 1];
                    if (0 === s.length || !ue(null == a ? void 0 : a.programDateTime)) return;
                    this.id3Track || (this.id3Track = this.createTrack(this.media));
                    const o = a.programDateTime / 1e3 - a.start,
                        l = bi();
                    for (let e = 0; e < s.length; e++) {
                        const t = s[e],
                            r = n[t],
                            a = i[t],
                            u = (null == a ? void 0 : a.cues) || {};
                        let h = (null == a ? void 0 : a.durationKnown) || !1;
                        const f = Ai(r.startDate, o);
                        let m = Ei;
                        const p = r.endDate;
                        if (p) m = Ai(p, o), h = !0;
                        else if (r.endOnNext && !h) {
                            const e = s.reduce(((e, t) => {
                                const i = n[t];
                                return i.class === r.class && i.id !== t && i.startDate > r.startDate && e.push(i), e
                            }), []).sort(((e, t) => e.startDate.getTime() - t.startDate.getTime()))[0];
                            e && (m = Ai(e.startDate, o), h = !0)
                        }
                        const g = Object.keys(r.attr);
                        for (let e = 0; e < g.length; e++) {
                            const i = g[e];
                            if ("ID" === (d = i) || "CLASS" === d || "START-DATE" === d || "DURATION" === d || "END-DATE" === d || "END-ON-NEXT" === d) continue;
                            const n = u[i];
                            if (n) h && !a.durationKnown && (n.endTime = m);
                            else if (l) {
                                let e = r.attr[i];
                                ke(i) && (c = e, e = Uint8Array.from(c.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer);
                                const n = Ti(l, f, m, {
                                    key: i,
                                    data: e
                                }, yi);
                                n && (n.id = t, this.id3Track.addCue(n), u[i] = n)
                            }
                        }
                        i[t] = {
                            cues: u,
                            dateRange: r,
                            durationKnown: h
                        }
                    }
                    var c, d
                }
            }
            class _i {
                constructor(e) {
                    this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = () => this.timeupdate(), this.hls = e, this.config = e.config, this.registerListeners()
                }
                get latency() {
                    return this._latency || 0
                }
                get maxLatency() {
                    const {
                        config: e,
                        levelDetails: t
                    } = this;
                    return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
                }
                get targetLatency() {
                    const {
                        levelDetails: e
                    } = this;
                    if (null === e) return null;
                    const {
                        holdBack: t,
                        partHoldBack: i,
                        targetduration: r
                    } = e, {
                        liveSyncDuration: n,
                        liveSyncDurationCount: s,
                        lowLatencyMode: a
                    } = this.config, o = this.hls.userConfig;
                    let l = a && i || t;
                    (o.liveSyncDuration || o.liveSyncDurationCount || 0 === l) && (l = void 0 !== n ? n : s * r);
                    const c = r;
                    return l + Math.min(1 * this.stallCount, c)
                }
                get liveSyncPosition() {
                    const e = this.estimateLiveEdge(),
                        t = this.targetLatency,
                        i = this.levelDetails;
                    if (null === e || null === t || null === i) return null;
                    const r = i.edge,
                        n = e - t - this.edgeStalled,
                        s = r - i.totalduration,
                        a = r - (this.config.lowLatencyMode && i.partTarget || i.targetduration);
                    return Math.min(Math.max(s, n), a)
                }
                get drift() {
                    const {
                        levelDetails: e
                    } = this;
                    return null === e ? 1 : e.drift
                }
                get edgeStalled() {
                    const {
                        levelDetails: e
                    } = this;
                    if (null === e) return 0;
                    const t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration);
                    return Math.max(e.age - t, 0)
                }
                get forwardBufferLength() {
                    const {
                        media: e,
                        levelDetails: t
                    } = this;
                    if (!e || !t) return 0;
                    const i = e.buffered.length;
                    return (i ? e.buffered.end(i - 1) : t.edge) - this.currentTime
                }
                destroy() {
                    this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
                }
                registerListeners() {
                    this.hls.on(me.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(me.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(me.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(me.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(me.ERROR, this.onError, this)
                }
                unregisterListeners() {
                    this.hls.off(me.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(me.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(me.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(me.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(me.ERROR, this.onError, this)
                }
                onMediaAttached(e, t) {
                    this.media = t.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
                }
                onMediaDetaching() {
                    this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
                }
                onManifestLoading() {
                    this.levelDetails = null, this._latency = null, this.stallCount = 0
                }
                onLevelUpdated(e, {
                    details: t
                }) {
                    this.levelDetails = t, t.advanced && this.timeupdate(), !t.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
                }
                onError(e, t) {
                    var i;
                    t.details === ge.BUFFER_STALLED_ERROR && (this.stallCount++, null != (i = this.levelDetails) && i.live && Ee.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
                }
                timeupdate() {
                    const {
                        media: e,
                        levelDetails: t
                    } = this;
                    if (!e || !t) return;
                    this.currentTime = e.currentTime;
                    const i = this.computeLatency();
                    if (null === i) return;
                    this._latency = i;
                    const {
                        lowLatencyMode: r,
                        maxLiveSyncPlaybackRate: n
                    } = this.config;
                    if (!r || 1 === n) return;
                    const s = this.targetLatency;
                    if (null === s) return;
                    const a = i - s,
                        o = a < Math.min(this.maxLatency, s + t.targetduration);
                    if (t.live && o && a > .05 && this.forwardBufferLength > 1) {
                        const t = Math.min(2, Math.max(1, n)),
                            i = Math.round(2 / (1 + Math.exp(-.75 * a - this.edgeStalled)) * 20) / 20;
                        e.playbackRate = Math.min(t, Math.max(1, i))
                    } else 1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1)
                }
                estimateLiveEdge() {
                    const {
                        levelDetails: e
                    } = this;
                    return null === e ? null : e.edge + e.age
                }
                computeLatency() {
                    const e = this.estimateLiveEdge();
                    return null === e ? null : e - this.currentTime
                }
            }
            const ki = ["NONE", "TYPE-0", "TYPE-1", null];
            var Si = "",
                Li = "YES",
                Ri = "v2";
            class Di {
                constructor(e, t, i) {
                    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = i
                }
                addDirectives(e) {
                    const t = new self.URL(e);
                    return void 0 !== this.msn && t.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && t.searchParams.set("_HLS_part", this.part.toString()), this.skip && t.searchParams.set("_HLS_skip", this.skip), t.href
                }
            }
            class Ci {
                constructor(e) {
                    this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.unknownCodecs = e.unknownCodecs, this.codecSet = [e.videoCodec, e.audioCodec].filter((e => e)).join(",").replace(/\.[^.,]+/g, "")
                }
                get maxBitrate() {
                    return Math.max(this.realBitrate, this.bitrate)
                }
                get attrs() {
                    return this._attrs[this._urlId]
                }
                get pathwayId() {
                    return this.attrs["PATHWAY-ID"] || "."
                }
                get uri() {
                    return this.url[this._urlId] || ""
                }
                get urlId() {
                    return this._urlId
                }
                set urlId(e) {
                    const t = e % this.url.length;
                    this._urlId !== t && (this.fragmentError = 0, this.loadError = 0, this.details = void 0, this._urlId = t)
                }
                get audioGroupId() {
                    var e;
                    return null == (e = this.audioGroupIds) ? void 0 : e[this.urlId]
                }
                get textGroupId() {
                    var e;
                    return null == (e = this.textGroupIds) ? void 0 : e[this.urlId]
                }
                addFallback(e) {
                    this.url.push(e.url), this._attrs.push(e.attrs)
                }
            }

            function Ii(e, t) {
                const i = t.startPTS;
                if (ue(i)) {
                    let r, n = 0;
                    t.sn > e.sn ? (n = i - e.start, r = e) : (n = e.start - i, r = t), r.duration !== n && (r.duration = n)
                } else if (t.sn > e.sn) {
                    e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration
                } else t.start = Math.max(e.start - t.duration, 0)
            }

            function Pi(e, t, i, r, n, s) {
                r - i <= 0 && (Ee.warn("Fragment should have a positive duration", t), r = i + t.duration, s = n + t.duration);
                let a = i,
                    o = r;
                const l = t.startPTS,
                    c = t.endPTS;
                if (ue(l)) {
                    const e = Math.abs(l - i);
                    ue(t.deltaPTS) ? t.deltaPTS = Math.max(e, t.deltaPTS) : t.deltaPTS = e, a = Math.max(i, l), i = Math.min(i, l), n = Math.min(n, t.startDTS), o = Math.min(r, c), r = Math.max(r, c), s = Math.max(s, t.endDTS)
                }
                const d = i - t.start;
                0 !== t.start && (t.start = i), t.duration = r - t.start, t.startPTS = i, t.maxStartPTS = a, t.startDTS = n, t.endPTS = r, t.minEndPTS = o, t.endDTS = s;
                const u = t.sn;
                if (!e || u < e.startSN || u > e.endSN) return 0;
                let h;
                const f = u - e.startSN,
                    m = e.fragments;
                for (m[f] = t, h = f; h > 0; h--) Ii(m[h], m[h - 1]);
                for (h = f; h < m.length - 1; h++) Ii(m[h], m[h + 1]);
                return e.fragmentHint && Ii(m[m.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, d
            }

            function xi(e, t) {
                let i = null;
                const r = e.fragments;
                for (let e = r.length - 1; e >= 0; e--) {
                    const t = r[e].initSegment;
                    if (t) {
                        i = t;
                        break
                    }
                }
                e.fragmentHint && delete e.fragmentHint.endPTS;
                let n, s = 0;
                if (function(e, t, i) {
                        const r = t.skippedSegments,
                            n = Math.max(e.startSN, t.startSN) - t.startSN,
                            s = (e.fragmentHint ? 1 : 0) + (r ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN,
                            a = t.startSN - e.startSN,
                            o = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments,
                            l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments;
                        for (let e = n; e <= s; e++) {
                            const n = l[a + e];
                            let s = o[e];
                            r && !s && e < r && (s = t.fragments[e] = n), n && s && i(n, s)
                        }
                    }(e, t, ((e, r) => {
                        e.relurl && (s = e.cc - r.cc), ue(e.startPTS) && ue(e.endPTS) && (r.start = r.startPTS = e.startPTS, r.startDTS = e.startDTS, r.maxStartPTS = e.maxStartPTS, r.endPTS = e.endPTS, r.endDTS = e.endDTS, r.minEndPTS = e.minEndPTS, r.duration = e.endPTS - e.startPTS, r.duration && (n = r), t.PTSKnown = t.alignedSliding = !0), r.elementaryStreams = e.elementaryStreams, r.loader = e.loader, r.stats = e.stats, r.urlId = e.urlId, e.initSegment && (r.initSegment = e.initSegment, i = e.initSegment)
                    })), i) {
                    (t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments).forEach((e => {
                        var t;
                        e.initSegment && e.initSegment.relurl !== (null == (t = i) ? void 0 : t.relurl) || (e.initSegment = i)
                    }))
                }
                if (t.skippedSegments)
                    if (t.deltaUpdateFailed = t.fragments.some((e => !e)), t.deltaUpdateFailed) {
                        Ee.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                        for (let e = t.skippedSegments; e--;) t.fragments.shift();
                        t.startSN = t.fragments[0].sn, t.startCC = t.fragments[0].cc
                    } else t.canSkipDateRanges && (t.dateRanges = function(e, t, i) {
                        const r = de({}, e);
                        i && i.forEach((e => {
                            delete r[e]
                        }));
                        return Object.keys(t).forEach((e => {
                            const i = new Se(t[e].attr, r[e]);
                            i.isValid ? r[e] = i : Ee.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(t[e].attr)}"`)
                        })), r
                    }(e.dateRanges, t.dateRanges, t.recentlyRemovedDateranges));
                const a = t.fragments;
                if (s) {
                    Ee.warn("discontinuity sliding from playlist, take drift into account");
                    for (let e = 0; e < a.length; e++) a[e].cc += s
                }
                t.skippedSegments && (t.startCC = t.fragments[0].cc),
                    function(e, t, i) {
                        if (e && t) {
                            let r = 0;
                            for (let n = 0, s = e.length; n <= s; n++) {
                                const s = e[n],
                                    a = t[n + r];
                                s && a && s.index === a.index && s.fragment.sn === a.fragment.sn ? i(s, a) : r--
                            }
                        }
                    }(e.partList, t.partList, ((e, t) => {
                        t.elementaryStreams = e.elementaryStreams, t.stats = e.stats
                    })), n ? Pi(t, n, n.startPTS, n.endPTS, n.startDTS, n.endDTS) : Oi(e, t), a.length && (t.totalduration = t.edge - a[0].start), t.driftStartTime = e.driftStartTime, t.driftStart = e.driftStart;
                const o = t.advancedDateTime;
                if (t.advanced && o) {
                    const e = t.edge;
                    t.driftStart || (t.driftStartTime = o, t.driftStart = e), t.driftEndTime = o, t.driftEnd = e
                } else t.driftEndTime = e.driftEndTime, t.driftEnd = e.driftEnd, t.advancedDateTime = e.advancedDateTime
            }

            function Oi(e, t) {
                const i = t.startSN + t.skippedSegments - e.startSN,
                    r = e.fragments;
                i < 0 || i >= r.length || Mi(t, r[i].start)
            }

            function Mi(e, t) {
                if (t) {
                    const i = e.fragments;
                    for (let r = e.skippedSegments; r < i.length; r++) i[r].start += t;
                    e.fragmentHint && (e.fragmentHint.start += t)
                }
            }

            function Ni(e, t, i) {
                var r;
                return null != e && e.details ? Fi(null == (r = e.details) ? void 0 : r.partList, t, i) : null
            }

            function Fi(e, t, i) {
                if (e)
                    for (let r = e.length; r--;) {
                        const n = e[r];
                        if (n.index === i && n.fragment.sn === t) return n
                    }
                return null
            }

            function Bi(e) {
                switch (e.details) {
                    case ge.FRAG_LOAD_TIMEOUT:
                    case ge.KEY_LOAD_TIMEOUT:
                    case ge.LEVEL_LOAD_TIMEOUT:
                    case ge.MANIFEST_LOAD_TIMEOUT:
                        return !0
                }
                return !1
            }

            function Ui(e, t) {
                const i = Bi(t);
                return e.default[(i ? "timeout" : "error") + "Retry"]
            }

            function $i(e, t) {
                const i = "linear" === e.backoff ? 1 : Math.pow(2, t);
                return Math.min(i * e.retryDelayMs, e.maxRetryDelayMs)
            }

            function Hi(e) {
                return le(le({}, e), {
                    errorRetry: null,
                    timeoutRetry: null
                })
            }

            function ji(e, t, i, r) {
                return !!e && t < e.maxNumRetry && (function(e) {
                    return 0 === e && !1 === navigator.onLine || !!e && (e < 400 || e > 499)
                }(r) || !!i)
            }
            const Gi = {
                search: function(e, t) {
                    let i = 0,
                        r = e.length - 1,
                        n = null,
                        s = null;
                    for (; i <= r;) {
                        n = (i + r) / 2 | 0, s = e[n];
                        const a = t(s);
                        if (a > 0) i = n + 1;
                        else {
                            if (!(a < 0)) return s;
                            r = n - 1
                        }
                    }
                    return null
                }
            };

            function Vi(e, t, i = 0, r = 0) {
                let n = null;
                if (e ? n = t[e.sn - t[0].sn + 1] || null : 0 === i && 0 === t[0].start && (n = t[0]), n && 0 === qi(i, r, n)) return n;
                const s = Gi.search(t, qi.bind(null, i, r));
                return !s || s === e && n ? n : s
            }

            function qi(e = 0, t = 0, i) {
                if (i.start <= e && i.start + i.duration > e) return 0;
                const r = Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
                return i.start + i.duration - r <= e ? 1 : i.start - r > e && i.start ? -1 : 0
            }

            function Ki(e, t, i) {
                const r = 1e3 * Math.min(t, i.duration + (i.deltaPTS ? i.deltaPTS : 0));
                return (i.endProgramDateTime || 0) - r > e
            }
            var Wi = 0,
                Yi = 2,
                zi = 5,
                Xi = 0,
                Qi = 1,
                Ji = 2;

            function Zi(e, t, i) {
                if (performance.now() - e.lastErrorPerfMs > 3e5) return !0;
                const r = e.details;
                if (t.details === ge.FRAG_GAP && r && t.frag) {
                    const e = t.frag.start,
                        i = Vi(null, r.fragments, e);
                    if (i && !i.gap) return !0
                }
                if (i && e.errors.length < i.errors.length) {
                    const i = e.errors[e.errors.length - 1];
                    if (r && i.frag && t.frag && Math.abs(i.frag.start - t.frag.start) > 3 * r.targetduration) return !0
                }
                return !1
            }
            class er {
                constructor(e, t) {
                    this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = Ee.log.bind(Ee, `${t}:`), this.warn = Ee.warn.bind(Ee, `${t}:`), this.hls = e
                }
                destroy() {
                    this.clearTimer(), this.hls = this.log = this.warn = null
                }
                clearTimer() {
                    clearTimeout(this.timer), this.timer = -1
                }
                startLoad() {
                    this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist()
                }
                stopLoad() {
                    this.canLoad = !1, this.clearTimer()
                }
                switchParams(e, t) {
                    const i = null == t ? void 0 : t.renditionReports;
                    if (i) {
                        let r = -1;
                        for (let n = 0; n < i.length; n++) {
                            const s = i[n];
                            let a;
                            try {
                                a = new self.URL(s.URI, t.url).href
                            } catch (e) {
                                Ee.warn(`Could not construct new URL for Rendition Report: ${e}`), a = s.URI || ""
                            }
                            if (a === e) {
                                r = n;
                                break
                            }
                            a === e.substring(0, a.length) && (r = n)
                        }
                        if (-1 !== r) {
                            const e = i[r],
                                n = parseInt(e["LAST-MSN"]) || (null == t ? void 0 : t.lastPartSn);
                            let s = parseInt(e["LAST-PART"]) || (null == t ? void 0 : t.lastPartIndex);
                            if (this.hls.config.lowLatencyMode) {
                                const e = Math.min(t.age - t.partTarget, t.targetduration);
                                s >= 0 && e > t.partTarget && (s += 1)
                            }
                            return new Di(n, s >= 0 ? s : void 0, Si)
                        }
                    }
                }
                loadPlaylist(e) {
                    -1 === this.requestScheduled && (this.requestScheduled = self.performance.now())
                }
                shouldLoadPlaylist(e) {
                    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live)
                }
                shouldReloadPlaylist(e) {
                    return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(e)
                }
                playlistLoaded(e, t, i) {
                    const {
                        details: r,
                        stats: n
                    } = t, s = self.performance.now(), a = n.loading.first ? Math.max(0, s - n.loading.first) : 0;
                    if (r.advancedDateTime = Date.now() - a, r.live || null != i && i.live) {
                        if (r.reloaded(i), i && this.log(`live playlist ${e} ${r.advanced?"REFRESHED "+r.lastPartSn+"-"+r.lastPartIndex:r.updated?"UPDATED":"MISSED"}`), i && r.fragments.length > 0 && xi(i, r), !this.canLoad || !r.live) return;
                        let a, o, l;
                        if (r.canBlockReload && r.endSN && r.advanced) {
                            const e = this.hls.config.lowLatencyMode,
                                n = r.lastPartSn,
                                s = r.endSN,
                                c = r.lastPartIndex,
                                d = n === s; - 1 !== c ? (o = d ? s + 1 : n, l = d ? e ? 0 : c : c + 1) : o = s + 1;
                            const u = r.age,
                                h = u + r.ageHeader;
                            let f = Math.min(h - r.partTarget, 1.5 * r.targetduration);
                            if (f > 0) {
                                if (i && f > i.tuneInGoal) this.warn(`CDN Tune-in goal increased from: ${i.tuneInGoal} to: ${f} with playlist age: ${r.age}`), f = 0;
                                else {
                                    const e = Math.floor(f / r.targetduration);
                                    if (o += e, void 0 !== l) {
                                        l += Math.round(f % r.targetduration / r.partTarget)
                                    }
                                    this.log(`CDN Tune-in age: ${r.ageHeader}s last advanced ${u.toFixed(2)}s goal: ${f} skip sn ${e} to part ${l}`)
                                }
                                r.tuneInGoal = f
                            }
                            if (a = this.getDeliveryDirectives(r, t.deliveryDirectives, o, l), e || !d) return void this.loadPlaylist(a)
                        } else(r.canBlockReload || r.canSkipUntil) && (a = this.getDeliveryDirectives(r, t.deliveryDirectives, o, l));
                        const c = this.hls.mainForwardBufferInfo,
                            d = c ? c.end - c.len : 0,
                            u = function(e, t = 1 / 0) {
                                let i = 1e3 * e.targetduration;
                                if (e.updated) {
                                    const r = e.fragments,
                                        n = 4;
                                    if (r.length && i * n > t) {
                                        const e = 1e3 * r[r.length - 1].duration;
                                        e < i && (i = e)
                                    }
                                } else i /= 2;
                                return Math.round(i)
                            }(r, 1e3 * (r.edge - d));
                        r.updated && s > this.requestScheduled + u && (this.requestScheduled = n.loading.start), void 0 !== o && r.canBlockReload ? this.requestScheduled = n.loading.first + u - (1e3 * r.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + u < s ? this.requestScheduled = s : this.requestScheduled - s <= 0 && (this.requestScheduled += u);
                        let h = this.requestScheduled - s;
                        h = Math.max(0, h), this.log(`reload live playlist ${e} in ${Math.round(h)} ms`), this.timer = self.setTimeout((() => this.loadPlaylist(a)), h)
                    } else this.clearTimer()
                }
                getDeliveryDirectives(e, t, i, r) {
                    let n = function(e, t) {
                        const {
                            canSkipUntil: i,
                            canSkipDateRanges: r,
                            endSN: n
                        } = e;
                        return i && (void 0 !== t ? t - n : 0) < i ? r ? Ri : Li : Si
                    }(e, i);
                    return null != t && t.skip && e.deltaUpdateFailed && (i = t.msn, r = t.part, n = Si), new Di(i, r, n)
                }
                checkRetry(e) {
                    const t = e.details,
                        i = Bi(e),
                        r = e.errorAction,
                        {
                            action: n,
                            retryCount: s = 0,
                            retryConfig: a
                        } = r || {},
                        o = !!r && !!a && (n === zi || !r.resolved && n === Yi);
                    if (o) {
                        var l;
                        if (this.requestScheduled = -1, s >= a.maxNumRetry) return !1;
                        if (i && null != (l = e.context) && l.deliveryDirectives) this.warn(`Retrying playlist loading ${s+1}/${a.maxNumRetry} after "${t}" without delivery-directives`), this.loadPlaylist();
                        else {
                            const e = $i(a, s);
                            this.timer = self.setTimeout((() => this.loadPlaylist()), e), this.warn(`Retrying playlist loading ${s+1}/${a.maxNumRetry} after "${t}" in ${e}ms`)
                        }
                        e.levelRetry = !0, r.resolved = !0
                    }
                    return o
                }
            }
            let tr;
            class ir extends er {
                constructor(e, t) {
                    super(e, "[level-controller]"), this._levels = [], this._firstLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners()
                }
                _registerListeners() {
                    const {
                        hls: e
                    } = this;
                    e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(me.LEVEL_LOADED, this.onLevelLoaded, this), e.on(me.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(me.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(me.FRAG_LOADED, this.onFragLoaded, this), e.on(me.ERROR, this.onError, this)
                }
                _unregisterListeners() {
                    const {
                        hls: e
                    } = this;
                    e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(me.LEVEL_LOADED, this.onLevelLoaded, this), e.off(me.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(me.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(me.FRAG_LOADED, this.onFragLoaded, this), e.off(me.ERROR, this.onError, this)
                }
                destroy() {
                    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy()
                }
                startLoad() {
                    this._levels.forEach((e => {
                        e.loadError = 0, e.fragmentError = 0
                    })), super.startLoad()
                }
                resetLevels() {
                    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = []
                }
                onManifestLoading(e, t) {
                    this.resetLevels()
                }
                onManifestLoaded(e, t) {
                    const i = [],
                        r = {};
                    let n;
                    t.levels.forEach((e => {
                        var t;
                        const s = e.attrs; - 1 !== (null == (t = e.audioCodec) ? void 0 : t.indexOf("mp4a.40.34")) && (tr || (tr = /chrome|firefox/i.test(navigator.userAgent)), tr && (e.audioCodec = void 0));
                        const {
                            AUDIO: a,
                            CODECS: o,
                            "FRAME-RATE": l,
                            "PATHWAY-ID": c,
                            RESOLUTION: d,
                            SUBTITLES: u
                        } = s, h = `${`${c||"."}-`}${e.bitrate}-${d}-${l}-${o}`;
                        n = r[h], n ? n.addFallback(e) : (n = new Ci(e), r[h] = n, i.push(n)), rr(n, "audio", a), rr(n, "text", u)
                    })), this.filterAndSortMediaOptions(i, t)
                }
                filterAndSortMediaOptions(e, t) {
                    let i = [],
                        r = [],
                        n = !1,
                        s = !1,
                        a = !1,
                        o = e.filter((({
                            audioCodec: e,
                            videoCodec: t,
                            width: i,
                            height: r,
                            unknownCodecs: o
                        }) => (n || (n = !(!i || !r)), s || (s = !!t), a || (a = !!e), !(null != o && o.length) && (!e || jt(e, "audio")) && (!t || jt(t, "video")))));
                    if ((n || s) && a && (o = o.filter((({
                            videoCodec: e,
                            width: t,
                            height: i
                        }) => !!e || !(!t || !i)))), 0 === o.length) return void Promise.resolve().then((() => {
                        if (this.hls) {
                            const e = new Error("no level with compatible codecs found in manifest");
                            this.hls.trigger(me.ERROR, {
                                type: pe.MEDIA_ERROR,
                                details: ge.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                                fatal: !0,
                                url: t.url,
                                error: e,
                                reason: e.message
                            })
                        }
                    }));
                    t.audioTracks && (i = t.audioTracks.filter((e => !e.audioCodec || jt(e.audioCodec, "audio"))), nr(i)), t.subtitles && (r = t.subtitles, nr(r));
                    const l = o.slice(0);
                    o.sort(((e, t) => e.attrs["HDCP-LEVEL"] !== t.attrs["HDCP-LEVEL"] ? (e.attrs["HDCP-LEVEL"] || "") > (t.attrs["HDCP-LEVEL"] || "") ? 1 : -1 : e.bitrate !== t.bitrate ? e.bitrate - t.bitrate : e.attrs["FRAME-RATE"] !== t.attrs["FRAME-RATE"] ? e.attrs.decimalFloatingPoint("FRAME-RATE") - t.attrs.decimalFloatingPoint("FRAME-RATE") : e.attrs.SCORE !== t.attrs.SCORE ? e.attrs.decimalFloatingPoint("SCORE") - t.attrs.decimalFloatingPoint("SCORE") : n && e.height !== t.height ? e.height - t.height : 0));
                    let c = l[0];
                    if (this.steering && (o = this.steering.filterParsedLevels(o), o.length !== l.length))
                        for (let e = 0; e < l.length; e++)
                            if (l[e].pathwayId === o[0].pathwayId) {
                                c = l[e];
                                break
                            }
                    this._levels = o;
                    for (let e = 0; e < o.length; e++)
                        if (o[e] === c) {
                            this._firstLevel = e, this.log(`manifest loaded, ${o.length} level(s) found, first bitrate: ${c.bitrate}`);
                            break
                        }
                    const d = a && !s,
                        u = {
                            levels: o,
                            audioTracks: i,
                            subtitleTracks: r,
                            sessionData: t.sessionData,
                            sessionKeys: t.sessionKeys,
                            firstLevel: this._firstLevel,
                            stats: t.stats,
                            audio: a,
                            video: s,
                            altAudio: !d && i.some((e => !!e.url))
                        };
                    this.hls.trigger(me.MANIFEST_PARSED, u), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
                }
                get levels() {
                    return 0 === this._levels.length ? null : this._levels
                }
                get level() {
                    return this.currentLevelIndex
                }
                set level(e) {
                    const t = this._levels;
                    if (0 === t.length) return;
                    if (e < 0 || e >= t.length) {
                        const i = new Error("invalid level idx"),
                            r = e < 0;
                        if (this.hls.trigger(me.ERROR, {
                                type: pe.OTHER_ERROR,
                                details: ge.LEVEL_SWITCH_ERROR,
                                level: e,
                                fatal: r,
                                error: i,
                                reason: i.message
                            }), r) return;
                        e = Math.min(e, t.length - 1)
                    }
                    const i = this.currentLevelIndex,
                        r = this.currentLevel,
                        n = r ? r.attrs["PATHWAY-ID"] : void 0,
                        s = t[e],
                        a = s.attrs["PATHWAY-ID"];
                    if (this.currentLevelIndex = e, this.currentLevel = s, i === e && s.details && r && n === a) return;
                    this.log(`Switching to level ${e}${a?" with Pathway "+a:""} from level ${i}${n?" with Pathway "+n:""}`);
                    const o = de({}, s, {
                        level: e,
                        maxBitrate: s.maxBitrate,
                        attrs: s.attrs,
                        uri: s.uri,
                        urlId: s.urlId
                    });
                    delete o._attrs, delete o._urlId, this.hls.trigger(me.LEVEL_SWITCHING, o);
                    const l = s.details;
                    if (!l || l.live) {
                        const e = this.switchParams(s.uri, null == r ? void 0 : r.details);
                        this.loadPlaylist(e)
                    }
                }
                get manualLevel() {
                    return this.manualLevelIndex
                }
                set manualLevel(e) {
                    this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e)
                }
                get firstLevel() {
                    return this._firstLevel
                }
                set firstLevel(e) {
                    this._firstLevel = e
                }
                get startLevel() {
                    if (void 0 === this._startLevel) {
                        const e = this.hls.config.startLevel;
                        return void 0 !== e ? e : this._firstLevel
                    }
                    return this._startLevel
                }
                set startLevel(e) {
                    this._startLevel = e
                }
                onError(e, t) {
                    !t.fatal && t.context && t.context.type === ri && t.context.level === this.level && this.checkRetry(t)
                }
                onFragLoaded(e, {
                    frag: t
                }) {
                    if (void 0 !== t && t.type === ai) {
                        const e = this._levels[t.level];
                        void 0 !== e && (e.loadError = 0)
                    }
                }
                onLevelLoaded(e, t) {
                    var i;
                    const {
                        level: r,
                        details: n
                    } = t, s = this._levels[r];
                    var a;
                    if (!s) return this.warn(`Invalid level index ${r}`), void(null != (a = t.deliveryDirectives) && a.skip && (n.deltaUpdateFailed = !0));
                    r === this.currentLevelIndex ? (0 === s.fragmentError && (s.loadError = 0), this.playlistLoaded(r, t, s.details)) : null != (i = t.deliveryDirectives) && i.skip && (n.deltaUpdateFailed = !0)
                }
                onAudioTrackSwitched(e, t) {
                    const i = this.currentLevel;
                    if (!i) return;
                    const r = this.hls.audioTracks[t.id].groupId;
                    if (i.audioGroupIds && i.audioGroupId !== r) {
                        let e = -1;
                        for (let t = 0; t < i.audioGroupIds.length; t++)
                            if (i.audioGroupIds[t] === r) {
                                e = t;
                                break
                            } - 1 !== e && e !== i.urlId && (i.urlId = e, this.canLoad && this.startLoad())
                    }
                }
                loadPlaylist(e) {
                    super.loadPlaylist();
                    const t = this.currentLevelIndex,
                        i = this.currentLevel;
                    if (i && this.shouldLoadPlaylist(i)) {
                        const r = i.urlId;
                        let n = i.uri;
                        if (e) try {
                            n = e.addDirectives(n)
                        } catch (e) {
                            this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
                        }
                        const s = i.attrs["PATHWAY-ID"];
                        this.log(`Loading level index ${t}${void 0!==(null==e?void 0:e.msn)?" at sn "+e.msn+" part "+e.part:""} with${s?" Pathway "+s:""} URI ${r+1}/${i.url.length} ${n}`), this.clearTimer(), this.hls.trigger(me.LEVEL_LOADING, {
                            url: n,
                            level: t,
                            id: r,
                            deliveryDirectives: e || null
                        })
                    }
                }
                get nextLoadLevel() {
                    return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
                }
                set nextLoadLevel(e) {
                    this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e)
                }
                removeLevel(e, t) {
                    const i = (e, i) => i !== t,
                        r = this._levels.filter(((r, n) => n !== e || (r.url.length > 1 && void 0 !== t ? (r.url = r.url.filter(i), r.audioGroupIds && (r.audioGroupIds = r.audioGroupIds.filter(i)), r.textGroupIds && (r.textGroupIds = r.textGroupIds.filter(i)), r.urlId = 0, !0) : (this.steering && this.steering.removeLevel(r), !1))));
                    this.hls.trigger(me.LEVELS_UPDATED, {
                        levels: r
                    })
                }
                onLevelsUpdated(e, {
                    levels: t
                }) {
                    t.forEach(((e, t) => {
                        const {
                            details: i
                        } = e;
                        null != i && i.fragments && i.fragments.forEach((e => {
                            e.level = t
                        }))
                    })), this._levels = t
                }
            }

            function rr(e, t, i) {
                i && ("audio" === t ? (e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds[e.url.length - 1] = i) : "text" === t && (e.textGroupIds || (e.textGroupIds = []), e.textGroupIds[e.url.length - 1] = i))
            }

            function nr(e) {
                const t = {};
                e.forEach((e => {
                    const i = e.groupId || "";
                    e.id = t[i] = t[i] || 0, t[i]++
                }))
            }
            var sr = "NOT_LOADED",
                ar = "APPENDING",
                or = "PARTIAL",
                lr = "OK";
            class cr {
                constructor(e) {
                    this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners()
                }
                _registerListeners() {
                    const {
                        hls: e
                    } = this;
                    e.on(me.BUFFER_APPENDED, this.onBufferAppended, this), e.on(me.FRAG_BUFFERED, this.onFragBuffered, this), e.on(me.FRAG_LOADED, this.onFragLoaded, this)
                }
                _unregisterListeners() {
                    const {
                        hls: e
                    } = this;
                    e.off(me.BUFFER_APPENDED, this.onBufferAppended, this), e.off(me.FRAG_BUFFERED, this.onFragBuffered, this), e.off(me.FRAG_LOADED, this.onFragLoaded, this)
                }
                destroy() {
                    this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null
                }
                getAppendedFrag(e, t) {
                    const i = this.activePartLists[t];
                    if (i)
                        for (let t = i.length; t--;) {
                            const r = i[t];
                            if (!r) break;
                            const n = r.end;
                            if (r.start <= e && null !== n && e <= n) return r
                        }
                    return this.getBufferedFrag(e, t)
                }
                getBufferedFrag(e, t) {
                    const {
                        fragments: i
                    } = this, r = Object.keys(i);
                    for (let n = r.length; n--;) {
                        const s = i[r[n]];
                        if ((null == s ? void 0 : s.body.type) === t && s.buffered) {
                            const t = s.body;
                            if (t.start <= e && e <= t.end) return t
                        }
                    }
                    return null
                }
                detectEvictedFragments(e, t, i, r) {
                    this.timeRanges && (this.timeRanges[e] = t);
                    const n = (null == r ? void 0 : r.fragment.sn) || -1;
                    Object.keys(this.fragments).forEach((r => {
                        const s = this.fragments[r];
                        if (!s) return;
                        if (n >= s.body.sn) return;
                        if (!s.buffered && !s.loaded) return void(s.body.type === i && this.removeFragment(s.body));
                        const a = s.range[e];
                        a && a.time.some((e => {
                            const i = !this.isTimeBuffered(e.startPTS, e.endPTS, t);
                            return i && this.removeFragment(s.body), i
                        }))
                    }))
                }
                detectPartialFragments(e) {
                    const t = this.timeRanges,
                        {
                            frag: i,
                            part: r
                        } = e;
                    if (!t || "initSegment" === i.sn) return;
                    const n = ur(i),
                        s = this.fragments[n];
                    if (!s || s.buffered && i.gap) return;
                    const a = !i.relurl;
                    if (Object.keys(t).forEach((e => {
                            const n = i.elementaryStreams[e];
                            if (!n) return;
                            const o = t[e],
                                l = a || !0 === n.partial;
                            s.range[e] = this.getBufferedTimes(i, r, l, o)
                        })), s.loaded = null, Object.keys(s.range).length) {
                        s.buffered = !0;
                        (s.body.endList = i.endList || s.body.endList) && (this.endListFragments[s.body.type] = s), dr(s) || this.removeParts(i.sn - 1, i.type)
                    } else this.removeFragment(s.body)
                }
                removeParts(e, t) {
                    const i = this.activePartLists[t];
                    i && (this.activePartLists[t] = i.filter((t => t.fragment.sn >= e)))
                }
                fragBuffered(e, t) {
                    const i = ur(e);
                    let r = this.fragments[i];
                    !r && t && (r = this.fragments[i] = {
                        body: e,
                        appendedPTS: null,
                        loaded: null,
                        buffered: !1,
                        range: Object.create(null)
                    }, e.gap && (this.hasGaps = !0)), r && (r.loaded = null, r.buffered = !0)
                }
                getBufferedTimes(e, t, i, r) {
                    const n = {
                            time: [],
                            partial: i
                        },
                        s = e.start,
                        a = e.end,
                        o = e.minEndPTS || a,
                        l = e.maxStartPTS || s;
                    for (let e = 0; e < r.length; e++) {
                        const t = r.start(e) - this.bufferPadding,
                            i = r.end(e) + this.bufferPadding;
                        if (l >= t && o <= i) {
                            n.time.push({
                                startPTS: Math.max(s, r.start(e)),
                                endPTS: Math.min(a, r.end(e))
                            });
                            break
                        }
                        if (s < i && a > t) n.partial = !0, n.time.push({
                            startPTS: Math.max(s, r.start(e)),
                            endPTS: Math.min(a, r.end(e))
                        });
                        else if (a <= t) break
                    }
                    return n
                }
                getPartialFragment(e) {
                    let t, i, r, n = null,
                        s = 0;
                    const {
                        bufferPadding: a,
                        fragments: o
                    } = this;
                    return Object.keys(o).forEach((l => {
                        const c = o[l];
                        c && dr(c) && (i = c.body.start - a, r = c.body.end + a, e >= i && e <= r && (t = Math.min(e - i, r - e), s <= t && (n = c.body, s = t)))
                    })), n
                }
                isEndListAppended(e) {
                    const t = this.endListFragments[e];
                    return void 0 !== t && (t.buffered || dr(t))
                }
                getState(e) {
                    const t = ur(e),
                        i = this.fragments[t];
                    return i ? i.buffered ? dr(i) ? or : lr : ar : sr
                }
                isTimeBuffered(e, t, i) {
                    let r, n;
                    for (let s = 0; s < i.length; s++) {
                        if (r = i.start(s) - this.bufferPadding, n = i.end(s) + this.bufferPadding, e >= r && t <= n) return !0;
                        if (t <= r) return !1
                    }
                    return !1
                }
                onFragLoaded(e, t) {
                    const {
                        frag: i,
                        part: r
                    } = t;
                    if ("initSegment" === i.sn || i.bitrateTest) return;
                    const n = r ? null : t,
                        s = ur(i);
                    this.fragments[s] = {
                        body: i,
                        appendedPTS: null,
                        loaded: n,
                        buffered: !1,
                        range: Object.create(null)
                    }
                }
                onBufferAppended(e, t) {
                    const {
                        frag: i,
                        part: r,
                        timeRanges: n
                    } = t;
                    if ("initSegment" === i.sn) return;
                    const s = i.type;
                    if (r) {
                        let e = this.activePartLists[s];
                        e || (this.activePartLists[s] = e = []), e.push(r)
                    }
                    this.timeRanges = n, Object.keys(n).forEach((e => {
                        const t = n[e];
                        this.detectEvictedFragments(e, t, s, r)
                    }))
                }
                onFragBuffered(e, t) {
                    this.detectPartialFragments(t)
                }
                hasFragment(e) {
                    const t = ur(e);
                    return !!this.fragments[t]
                }
                hasParts(e) {
                    var t;
                    return !(null == (t = this.activePartLists[e]) || !t.length)
                }
                removeFragmentsInRange(e, t, i, r, n) {
                    r && !this.hasGaps || Object.keys(this.fragments).forEach((s => {
                        const a = this.fragments[s];
                        if (!a) return;
                        const o = a.body;
                        o.type !== i || r && !o.gap || o.start < t && o.end > e && (a.buffered || n) && this.removeFragment(o)
                    }))
                }
                removeFragment(e) {
                    const t = ur(e);
                    e.stats.loaded = 0, e.clearElementaryStreamInfo();
                    const i = this.activePartLists[e.type];
                    if (i) {
                        const t = e.sn;
                        this.activePartLists[e.type] = i.filter((e => e.fragment.sn !== t))
                    }
                    delete this.fragments[t], e.endList && delete this.endListFragments[e.type]
                }
                removeAllFragments() {
                    this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1
                }
            }

            function dr(e) {
                var t, i, r;
                return e.buffered && (e.body.gap || (null == (t = e.range.video) ? void 0 : t.partial) || (null == (i = e.range.audio) ? void 0 : i.partial) || (null == (r = e.range.audiovideo) ? void 0 : r.partial))
            }

            function ur(e) {
                return `${e.type}_${e.level}_${e.urlId}_${e.sn}`
            }
            const hr = Math.pow(2, 17);
            class fr {
                constructor(e) {
                    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e
                }
                destroy() {
                    this.loader && (this.loader.destroy(), this.loader = null)
                }
                abort() {
                    this.loader && this.loader.abort()
                }
                load(e, t) {
                    const i = e.url;
                    if (!i) return Promise.reject(new gr({
                        type: pe.NETWORK_ERROR,
                        details: ge.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: e,
                        error: new Error("Fragment does not have a " + (i ? "part list" : "url")),
                        networkDetails: null
                    }));
                    this.abort();
                    const r = this.config,
                        n = r.fLoader,
                        s = r.loader;
                    return new Promise(((a, o) => {
                        if (this.loader && this.loader.destroy(), e.gap) {
                            if (e.tagList.some((e => "GAP" === e[0]))) return void o(pr(e));
                            e.gap = !1
                        }
                        const l = this.loader = e.loader = n ? new n(r) : new s(r),
                            c = mr(e),
                            d = Hi(r.fragLoadPolicy.default),
                            u = {
                                loadPolicy: d,
                                timeout: d.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0,
                                highWaterMark: "initSegment" === e.sn ? 1 / 0 : hr
                            };
                        e.stats = l.stats, l.load(c, u, {
                            onSuccess: (t, i, r, n) => {
                                this.resetLoader(e, l);
                                let s = t.data;
                                r.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(s.slice(0, 16)), s = s.slice(16)), a({
                                    frag: e,
                                    part: null,
                                    payload: s,
                                    networkDetails: n
                                })
                            },
                            onError: (t, r, n, s) => {
                                this.resetLoader(e, l), o(new gr({
                                    type: pe.NETWORK_ERROR,
                                    details: ge.FRAG_LOAD_ERROR,
                                    fatal: !1,
                                    frag: e,
                                    response: le({
                                        url: i,
                                        data: void 0
                                    }, t),
                                    error: new Error(`HTTP Error ${t.code} ${t.text}`),
                                    networkDetails: n,
                                    stats: s
                                }))
                            },
                            onAbort: (t, i, r) => {
                                this.resetLoader(e, l), o(new gr({
                                    type: pe.NETWORK_ERROR,
                                    details: ge.INTERNAL_ABORTED,
                                    fatal: !1,
                                    frag: e,
                                    error: new Error("Aborted"),
                                    networkDetails: r,
                                    stats: t
                                }))
                            },
                            onTimeout: (t, i, r) => {
                                this.resetLoader(e, l), o(new gr({
                                    type: pe.NETWORK_ERROR,
                                    details: ge.FRAG_LOAD_TIMEOUT,
                                    fatal: !1,
                                    frag: e,
                                    error: new Error(`Timeout after ${u.timeout}ms`),
                                    networkDetails: r,
                                    stats: t
                                }))
                            },
                            onProgress: (i, r, n, s) => {
                                t && t({
                                    frag: e,
                                    part: null,
                                    payload: n,
                                    networkDetails: s
                                })
                            }
                        })
                    }))
                }
                loadPart(e, t, i) {
                    this.abort();
                    const r = this.config,
                        n = r.fLoader,
                        s = r.loader;
                    return new Promise(((a, o) => {
                        if (this.loader && this.loader.destroy(), e.gap || t.gap) return void o(pr(e, t));
                        const l = this.loader = e.loader = n ? new n(r) : new s(r),
                            c = mr(e, t),
                            d = Hi(r.fragLoadPolicy.default),
                            u = {
                                loadPolicy: d,
                                timeout: d.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0,
                                highWaterMark: hr
                            };
                        t.stats = l.stats, l.load(c, u, {
                            onSuccess: (r, n, s, o) => {
                                this.resetLoader(e, l), this.updateStatsFromPart(e, t);
                                const c = {
                                    frag: e,
                                    part: t,
                                    payload: r.data,
                                    networkDetails: o
                                };
                                i(c), a(c)
                            },
                            onError: (i, r, n, s) => {
                                this.resetLoader(e, l), o(new gr({
                                    type: pe.NETWORK_ERROR,
                                    details: ge.FRAG_LOAD_ERROR,
                                    fatal: !1,
                                    frag: e,
                                    part: t,
                                    response: le({
                                        url: c.url,
                                        data: void 0
                                    }, i),
                                    error: new Error(`HTTP Error ${i.code} ${i.text}`),
                                    networkDetails: n,
                                    stats: s
                                }))
                            },
                            onAbort: (i, r, n) => {
                                e.stats.aborted = t.stats.aborted, this.resetLoader(e, l), o(new gr({
                                    type: pe.NETWORK_ERROR,
                                    details: ge.INTERNAL_ABORTED,
                                    fatal: !1,
                                    frag: e,
                                    part: t,
                                    error: new Error("Aborted"),
                                    networkDetails: n,
                                    stats: i
                                }))
                            },
                            onTimeout: (i, r, n) => {
                                this.resetLoader(e, l), o(new gr({
                                    type: pe.NETWORK_ERROR,
                                    details: ge.FRAG_LOAD_TIMEOUT,
                                    fatal: !1,
                                    frag: e,
                                    part: t,
                                    error: new Error(`Timeout after ${u.timeout}ms`),
                                    networkDetails: n,
                                    stats: i
                                }))
                            }
                        })
                    }))
                }
                updateStatsFromPart(e, t) {
                    const i = e.stats,
                        r = t.stats,
                        n = r.total;
                    if (i.loaded += r.loaded, n) {
                        const r = Math.round(e.duration / t.duration),
                            s = Math.min(Math.round(i.loaded / n), r),
                            a = (r - s) * Math.round(i.loaded / s);
                        i.total = i.loaded + a
                    } else i.total = Math.max(i.loaded, i.total);
                    const s = i.loading,
                        a = r.loading;
                    s.start ? s.first += a.first - a.start : (s.start = a.start, s.first = a.first), s.end = a.end
                }
                resetLoader(e, t) {
                    e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy()
                }
            }

            function mr(e, t = null) {
                const i = t || e,
                    r = {
                        frag: e,
                        part: t,
                        responseType: "arraybuffer",
                        url: i.url,
                        headers: {},
                        rangeStart: 0,
                        rangeEnd: 0
                    },
                    n = i.byteRangeStartOffset,
                    s = i.byteRangeEndOffset;
                if (ue(n) && ue(s)) {
                    var a;
                    let t = n,
                        i = s;
                    if ("initSegment" === e.sn && "AES-128" === (null == (a = e.decryptdata) ? void 0 : a.method)) {
                        const e = s - n;
                        e % 16 && (i = s + (16 - e % 16)), 0 !== n && (r.resetIV = !0, t = n - 16)
                    }
                    r.rangeStart = t, r.rangeEnd = i
                }
                return r
            }

            function pr(e, t) {
                const i = new Error(`GAP ${e.gap?"tag":"attribute"} found`),
                    r = {
                        type: pe.MEDIA_ERROR,
                        details: ge.FRAG_GAP,
                        fatal: !1,
                        frag: e,
                        error: i,
                        networkDetails: null
                    };
                return t && (r.part = t), (t || e).stats.aborted = !0, new gr(r)
            }
            class gr extends Error {
                constructor(e) {
                    super(e.error.message), this.data = void 0, this.data = e
                }
            }
            class yr {
                constructor(e) {
                    this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e
                }
                abort(e) {
                    for (const t in this.keyUriToKeyInfo) {
                        const i = this.keyUriToKeyInfo[t].loader;
                        if (i) {
                            if (e && e !== i.context.frag.type) return;
                            i.abort()
                        }
                    }
                }
                detach() {
                    for (const e in this.keyUriToKeyInfo) {
                        const t = this.keyUriToKeyInfo[e];
                        (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e]
                    }
                }
                destroy() {
                    this.detach();
                    for (const e in this.keyUriToKeyInfo) {
                        const t = this.keyUriToKeyInfo[e].loader;
                        t && t.destroy()
                    }
                    this.keyUriToKeyInfo = {}
                }
                createKeyLoadError(e, t = ge.KEY_LOAD_ERROR, i, r, n) {
                    return new gr({
                        type: pe.NETWORK_ERROR,
                        details: t,
                        fatal: !1,
                        frag: e,
                        response: n,
                        error: i,
                        networkDetails: r
                    })
                }
                loadClear(e, t) {
                    if (this.emeController && this.config.emeEnabled) {
                        const {
                            sn: i,
                            cc: r
                        } = e;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e];
                            if (r <= n.cc && ("initSegment" === i || "initSegment" === n.sn || i < n.sn)) {
                                this.emeController.selectKeySystemFormat(n).then((e => {
                                    n.setKeyFormat(e)
                                }));
                                break
                            }
                        }
                    }
                }
                load(e) {
                    return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then((t => this.loadInternal(e, t))) : this.loadInternal(e)
                }
                loadInternal(e, t) {
                    var i, r;
                    t && e.setKeyFormat(t);
                    const n = e.decryptdata;
                    if (!n) {
                        const i = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading");
                        return Promise.reject(this.createKeyLoadError(e, ge.KEY_LOAD_ERROR, i))
                    }
                    const s = n.uri;
                    if (!s) return Promise.reject(this.createKeyLoadError(e, ge.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${s}"`)));
                    let a = this.keyUriToKeyInfo[s];
                    if (null != (i = a) && i.decryptdata.key) return n.key = a.decryptdata.key, Promise.resolve({
                        frag: e,
                        keyInfo: a
                    });
                    var o;
                    if (null != (r = a) && r.keyLoadPromise) switch (null == (o = a.mediaKeySessionContext) ? void 0 : o.keyStatus) {
                        case void 0:
                        case "status-pending":
                        case "usable":
                        case "usable-in-future":
                            return a.keyLoadPromise.then((t => (n.key = t.keyInfo.decryptdata.key, {
                                frag: e,
                                keyInfo: a
                            })))
                    }
                    switch (a = this.keyUriToKeyInfo[s] = {
                        decryptdata: n,
                        keyLoadPromise: null,
                        loader: null,
                        mediaKeySessionContext: null
                    }, n.method) {
                        case "ISO-23001-7":
                        case "SAMPLE-AES":
                        case "SAMPLE-AES-CENC":
                        case "SAMPLE-AES-CTR":
                            return "identity" === n.keyFormat ? this.loadKeyHTTP(a, e) : this.loadKeyEME(a, e);
                        case "AES-128":
                            return this.loadKeyHTTP(a, e);
                        default:
                            return Promise.reject(this.createKeyLoadError(e, ge.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${n.method}"`)))
                    }
                }
                loadKeyEME(e, t) {
                    const i = {
                        frag: t,
                        keyInfo: e
                    };
                    if (this.emeController && this.config.emeEnabled) {
                        const t = this.emeController.loadKey(i);
                        if (t) return (e.keyLoadPromise = t.then((t => (e.mediaKeySessionContext = t, i)))).catch((t => {
                            throw e.keyLoadPromise = null, t
                        }))
                    }
                    return Promise.resolve(i)
                }
                loadKeyHTTP(e, t) {
                    const i = this.config,
                        r = new(0, i.loader)(i);
                    return t.keyLoader = e.loader = r, e.keyLoadPromise = new Promise(((n, s) => {
                        const a = {
                                keyInfo: e,
                                frag: t,
                                responseType: "arraybuffer",
                                url: e.decryptdata.uri
                            },
                            o = i.keyLoadPolicy.default,
                            l = {
                                loadPolicy: o,
                                timeout: o.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0
                            },
                            c = {
                                onSuccess: (e, t, i, r) => {
                                    const {
                                        frag: a,
                                        keyInfo: o,
                                        url: l
                                    } = i;
                                    if (!a.decryptdata || o !== this.keyUriToKeyInfo[l]) return s(this.createKeyLoadError(a, ge.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), r));
                                    o.decryptdata.key = a.decryptdata.key = new Uint8Array(e.data), a.keyLoader = null, o.loader = null, n({
                                        frag: a,
                                        keyInfo: o
                                    })
                                },
                                onError: (e, i, r, n) => {
                                    this.resetLoader(i), s(this.createKeyLoadError(t, ge.KEY_LOAD_ERROR, new Error(`HTTP Error ${e.code} loading key ${e.text}`), r, le({
                                        url: a.url,
                                        data: void 0
                                    }, e)))
                                },
                                onTimeout: (e, i, r) => {
                                    this.resetLoader(i), s(this.createKeyLoadError(t, ge.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), r))
                                },
                                onAbort: (e, i, r) => {
                                    this.resetLoader(i), s(this.createKeyLoadError(t, ge.INTERNAL_ABORTED, new Error("key loading aborted"), r))
                                }
                            };
                        r.load(a, l, c)
                    }))
                }
                resetLoader(e) {
                    const {
                        frag: t,
                        keyInfo: i,
                        url: r
                    } = e, n = i.loader;
                    t.keyLoader === n && (t.keyLoader = null, i.loader = null), delete this.keyUriToKeyInfo[r], n && n.destroy()
                }
            }
            class vr {
                constructor() {
                    this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
                }
                destroy() {
                    this.onHandlerDestroying(), this.onHandlerDestroyed()
                }
                onHandlerDestroying() {
                    this.clearNextTick(), this.clearInterval()
                }
                onHandlerDestroyed() {}
                hasInterval() {
                    return !!this._tickInterval
                }
                hasNextTick() {
                    return !!this._tickTimer
                }
                setInterval(e) {
                    return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0)
                }
                clearInterval() {
                    return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0)
                }
                clearNextTick() {
                    return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0)
                }
                tick() {
                    this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
                }
                tickImmediate() {
                    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
                }
                doTick() {}
            }
            const br = {
                length: 0,
                start: () => 0,
                end: () => 0
            };
            class Tr {
                static isBuffered(e, t) {
                    try {
                        if (e) {
                            const i = Tr.getBuffered(e);
                            for (let e = 0; e < i.length; e++)
                                if (t >= i.start(e) && t <= i.end(e)) return !0
                        }
                    } catch (e) {}
                    return !1
                }
                static bufferInfo(e, t, i) {
                    try {
                        if (e) {
                            const r = Tr.getBuffered(e),
                                n = [];
                            let s;
                            for (s = 0; s < r.length; s++) n.push({
                                start: r.start(s),
                                end: r.end(s)
                            });
                            return this.bufferedInfo(n, t, i)
                        }
                    } catch (e) {}
                    return {
                        len: 0,
                        start: t,
                        end: t,
                        nextStart: void 0
                    }
                }
                static bufferedInfo(e, t, i) {
                    t = Math.max(0, t), e.sort((function(e, t) {
                        const i = e.start - t.start;
                        return i || t.end - e.end
                    }));
                    let r = [];
                    if (i)
                        for (let t = 0; t < e.length; t++) {
                            const n = r.length;
                            if (n) {
                                const s = r[n - 1].end;
                                e[t].start - s < i ? e[t].end > s && (r[n - 1].end = e[t].end) : r.push(e[t])
                            } else r.push(e[t])
                        } else r = e;
                    let n, s = 0,
                        a = t,
                        o = t;
                    for (let e = 0; e < r.length; e++) {
                        const l = r[e].start,
                            c = r[e].end;
                        if (t + i >= l && t < c) a = l, o = c, s = o - t;
                        else if (t + i < l) {
                            n = l;
                            break
                        }
                    }
                    return {
                        len: s,
                        start: a || 0,
                        end: o || 0,
                        nextStart: n
                    }
                }
                static getBuffered(e) {
                    try {
                        return e.buffered
                    } catch (e) {
                        return Ee.log("failed to get media.buffered", e), br
                    }
                }
            }
            class Er {
                constructor(e, t, i, r = 0, n = -1, s = !1) {
                    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {
                        start: 0,
                        executeStart: 0,
                        executeEnd: 0,
                        end: 0
                    }, this.buffering = {
                        audio: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        },
                        video: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        },
                        audiovideo: {
                            start: 0,
                            executeStart: 0,
                            executeEnd: 0,
                            end: 0
                        }
                    }, this.level = e, this.sn = t, this.id = i, this.size = r, this.part = n, this.partial = s
                }
            }

            function Ar(e, t) {
                let i = null;
                for (let r = 0, n = e.length; r < n; r++) {
                    const n = e[r];
                    if (n && n.cc === t) {
                        i = n;
                        break
                    }
                }
                return i
            }

            function wr(e, t) {
                if (e) {
                    const i = e.start + t;
                    e.start = e.startPTS = i, e.endPTS = i + e.duration
                }
            }

            function _r(e, t) {
                const i = t.fragments;
                for (let t = 0, r = i.length; t < r; t++) wr(i[t], e);
                t.fragmentHint && wr(t.fragmentHint, e), t.alignedSliding = !0
            }

            function kr(e, t, i) {
                t && (! function(e, t, i) {
                    if (function(e, t, i) {
                            return !(!t.details || !(i.endCC > i.startCC || e && e.cc < i.startCC))
                        }(e, i, t)) {
                        const e = function(e, t, i = 0) {
                            const r = e.fragments,
                                n = t.fragments;
                            if (!n.length || !r.length) return void Ee.log("No fragments to align");
                            const s = Ar(r, n[0].cc);
                            if (s && (!s || s.startPTS)) return s;
                            Ee.log("No frag in previous level to align on")
                        }(i.details, t);
                        e && ue(e.start) && (Ee.log(`Adjusting PTS using last level due to CC increase within current level ${t.url}`), _r(e.start, t))
                    }
                }(e, i, t), !i.alignedSliding && t.details && function(e, t) {
                    if (!t.fragments.length || !e.hasProgramDateTime || !t.hasProgramDateTime) return;
                    const i = t.fragments[0].programDateTime,
                        r = e.fragments[0].programDateTime,
                        n = (r - i) / 1e3 + t.fragments[0].start;
                    n && ue(n) && (Ee.log(`Adjusting PTS using programDateTime delta ${r-i}ms, sliding:${n.toFixed(3)} ${e.url} `), _r(n, e))
                }(i, t.details), i.alignedSliding || !t.details || i.skippedSegments || Oi(t.details, i))
            }

            function Sr(e, t) {
                if (!e.hasProgramDateTime || !t.hasProgramDateTime) return;
                const i = e.fragments,
                    r = t.fragments;
                if (!i.length || !r.length) return;
                const n = r[Math.round(r.length / 2) - 1],
                    s = Ar(i, n.cc) || i[Math.round(i.length / 2) - 1],
                    a = n.programDateTime,
                    o = s.programDateTime;
                if (null === a || null === o) return;
                _r((o - a) / 1e3 - (s.start - n.start), e)
            }
            class Lr {
                constructor(e, t) {
                    this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t
                }
                decrypt(e, t) {
                    return this.subtle.decrypt({
                        name: "AES-CBC",
                        iv: this.aesIV
                    }, t, e)
                }
            }
            class Rr {
                constructor(e, t) {
                    this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t
                }
                expandKey() {
                    return this.subtle.importKey("raw", this.key, {
                        name: "AES-CBC"
                    }, !1, ["encrypt", "decrypt"])
                }
            }
            class Dr {
                constructor() {
                    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
                }
                uint8ArrayToUint32Array_(e) {
                    const t = new DataView(e),
                        i = new Uint32Array(4);
                    for (let e = 0; e < 4; e++) i[e] = t.getUint32(4 * e);
                    return i
                }
                initTable() {
                    const e = this.sBox,
                        t = this.invSBox,
                        i = this.subMix,
                        r = i[0],
                        n = i[1],
                        s = i[2],
                        a = i[3],
                        o = this.invSubMix,
                        l = o[0],
                        c = o[1],
                        d = o[2],
                        u = o[3],
                        h = new Uint32Array(256);
                    let f = 0,
                        m = 0,
                        p = 0;
                    for (p = 0; p < 256; p++) h[p] = p < 128 ? p << 1 : p << 1 ^ 283;
                    for (p = 0; p < 256; p++) {
                        let i = m ^ m << 1 ^ m << 2 ^ m << 3 ^ m << 4;
                        i = i >>> 8 ^ 255 & i ^ 99, e[f] = i, t[i] = f;
                        const o = h[f],
                            p = h[o],
                            g = h[p];
                        let y = 257 * h[i] ^ 16843008 * i;
                        r[f] = y << 24 | y >>> 8, n[f] = y << 16 | y >>> 16, s[f] = y << 8 | y >>> 24, a[f] = y, y = 16843009 * g ^ 65537 * p ^ 257 * o ^ 16843008 * f, l[i] = y << 24 | y >>> 8, c[i] = y << 16 | y >>> 16, d[i] = y << 8 | y >>> 24, u[i] = y, f ? (f = o ^ h[h[h[g ^ o]]], m ^= h[h[m]]) : f = m = 1
                    }
                }
                expandKey(e) {
                    const t = this.uint8ArrayToUint32Array_(e);
                    let i = !0,
                        r = 0;
                    for (; r < t.length && i;) i = t[r] === this.key[r], r++;
                    if (i) return;
                    this.key = t;
                    const n = this.keySize = t.length;
                    if (4 !== n && 6 !== n && 8 !== n) throw new Error("Invalid aes key size=" + n);
                    const s = this.ksRows = 4 * (n + 6 + 1);
                    let a, o;
                    const l = this.keySchedule = new Uint32Array(s),
                        c = this.invKeySchedule = new Uint32Array(s),
                        d = this.sBox,
                        u = this.rcon,
                        h = this.invSubMix,
                        f = h[0],
                        m = h[1],
                        p = h[2],
                        g = h[3];
                    let y, v;
                    for (a = 0; a < s; a++) a < n ? y = l[a] = t[a] : (v = y, a % n == 0 ? (v = v << 8 | v >>> 24, v = d[v >>> 24] << 24 | d[v >>> 16 & 255] << 16 | d[v >>> 8 & 255] << 8 | d[255 & v], v ^= u[a / n | 0] << 24) : n > 6 && a % n == 4 && (v = d[v >>> 24] << 24 | d[v >>> 16 & 255] << 16 | d[v >>> 8 & 255] << 8 | d[255 & v]), l[a] = y = (l[a - n] ^ v) >>> 0);
                    for (o = 0; o < s; o++) a = s - o, v = 3 & o ? l[a] : l[a - 4], c[o] = o < 4 || a <= 4 ? v : f[d[v >>> 24]] ^ m[d[v >>> 16 & 255]] ^ p[d[v >>> 8 & 255]] ^ g[d[255 & v]], c[o] = c[o] >>> 0
                }
                networkToHostOrderSwap(e) {
                    return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24
                }
                decrypt(e, t, i) {
                    const r = this.keySize + 6,
                        n = this.invKeySchedule,
                        s = this.invSBox,
                        a = this.invSubMix,
                        o = a[0],
                        l = a[1],
                        c = a[2],
                        d = a[3],
                        u = this.uint8ArrayToUint32Array_(i);
                    let h = u[0],
                        f = u[1],
                        m = u[2],
                        p = u[3];
                    const g = new Int32Array(e),
                        y = new Int32Array(g.length);
                    let v, b, T, E, A, w, _, k, S, L, R, D, C, I;
                    const P = this.networkToHostOrderSwap;
                    for (; t < g.length;) {
                        for (S = P(g[t]), L = P(g[t + 1]), R = P(g[t + 2]), D = P(g[t + 3]), A = S ^ n[0], w = D ^ n[1], _ = R ^ n[2], k = L ^ n[3], C = 4, I = 1; I < r; I++) v = o[A >>> 24] ^ l[w >> 16 & 255] ^ c[_ >> 8 & 255] ^ d[255 & k] ^ n[C], b = o[w >>> 24] ^ l[_ >> 16 & 255] ^ c[k >> 8 & 255] ^ d[255 & A] ^ n[C + 1], T = o[_ >>> 24] ^ l[k >> 16 & 255] ^ c[A >> 8 & 255] ^ d[255 & w] ^ n[C + 2], E = o[k >>> 24] ^ l[A >> 16 & 255] ^ c[w >> 8 & 255] ^ d[255 & _] ^ n[C + 3], A = v, w = b, _ = T, k = E, C += 4;
                        v = s[A >>> 24] << 24 ^ s[w >> 16 & 255] << 16 ^ s[_ >> 8 & 255] << 8 ^ s[255 & k] ^ n[C], b = s[w >>> 24] << 24 ^ s[_ >> 16 & 255] << 16 ^ s[k >> 8 & 255] << 8 ^ s[255 & A] ^ n[C + 1], T = s[_ >>> 24] << 24 ^ s[k >> 16 & 255] << 16 ^ s[A >> 8 & 255] << 8 ^ s[255 & w] ^ n[C + 2], E = s[k >>> 24] << 24 ^ s[A >> 16 & 255] << 16 ^ s[w >> 8 & 255] << 8 ^ s[255 & _] ^ n[C + 3], y[t] = P(v ^ h), y[t + 1] = P(E ^ f), y[t + 2] = P(T ^ m), y[t + 3] = P(b ^ p), h = S, f = L, m = R, p = D, t += 4
                    }
                    return y.buffer
                }
            }
            class Cr {
                constructor(e, {
                    removePKCS7Padding: t = !0
                } = {}) {
                    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = t, t) try {
                        const e = self.crypto;
                        e && (this.subtle = e.subtle || e.webkitSubtle)
                    } catch (e) {}
                    null === this.subtle && (this.useSoftware = !0)
                }
                destroy() {
                    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null
                }
                isSync() {
                    return this.useSoftware
                }
                flush() {
                    const {
                        currentResult: e,
                        remainderData: t
                    } = this;
                    if (!e || t) return this.reset(), null;
                    const i = new Uint8Array(e);
                    return this.reset(), this.removePKCS7Padding ? function(e) {
                        const t = e.byteLength,
                            i = t && new DataView(e.buffer).getUint8(t - 1);
                        return i ? Ye(e, 0, t - i) : e
                    }(i) : i
                }
                reset() {
                    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
                }
                decrypt(e, t, i) {
                    return this.useSoftware ? new Promise(((r, n) => {
                        this.softwareDecrypt(new Uint8Array(e), t, i);
                        const s = this.flush();
                        s ? r(s.buffer) : n(new Error("[softwareDecrypt] Failed to decrypt data"))
                    })) : this.webCryptoDecrypt(new Uint8Array(e), t, i)
                }
                softwareDecrypt(e, t, i) {
                    const {
                        currentIV: r,
                        currentResult: n,
                        remainderData: s
                    } = this;
                    this.logOnce("JS AES decrypt"), s && (e = kt(s, e), this.remainderData = null);
                    const a = this.getValidChunk(e);
                    if (!a.length) return null;
                    r && (i = r);
                    let o = this.softwareDecrypter;
                    o || (o = this.softwareDecrypter = new Dr), o.expandKey(t);
                    const l = n;
                    return this.currentResult = o.decrypt(a.buffer, 0, i), this.currentIV = Ye(a, -16).buffer, l || null
                }
                webCryptoDecrypt(e, t, i) {
                    const r = this.subtle;
                    return this.key === t && this.fastAesKey || (this.key = t, this.fastAesKey = new Rr(r, t)), this.fastAesKey.expandKey().then((t => {
                        if (!r) return Promise.reject(new Error("web crypto not initialized"));
                        this.logOnce("WebCrypto AES decrypt");
                        return new Lr(r, new Uint8Array(i)).decrypt(e.buffer, t)
                    })).catch((r => (Ee.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${r.name}: ${r.message}`), this.onWebCryptoError(e, t, i))))
                }
                onWebCryptoError(e, t, i) {
                    this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, i);
                    const r = this.flush();
                    if (r) return r.buffer;
                    throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
                }
                getValidChunk(e) {
                    let t = e;
                    const i = e.length - e.length % 16;
                    return i !== e.length && (t = Ye(e, 0, i), this.remainderData = Ye(e, i)), t
                }
                logOnce(e) {
                    this.logEnabled && (Ee.log(`[decrypter]: ${e}`), this.logEnabled = !1)
                }
            }
            const Ir = function(e) {
                    let t = "";
                    const i = e.length;
                    for (let r = 0; r < i; r++) t += `[${e.start(r).toFixed(3)}-${e.end(r).toFixed(3)}]`;
                    return t
                },
                Pr = "STOPPED",
                xr = "IDLE",
                Or = "KEY_LOADING",
                Mr = "FRAG_LOADING",
                Nr = "FRAG_LOADING_WAITING_RETRY",
                Fr = "WAITING_TRACK",
                Br = "PARSING",
                Ur = "PARSED",
                $r = "ENDED",
                Hr = "ERROR",
                jr = "WAITING_INIT_PTS",
                Gr = "WAITING_LEVEL";
            class Vr extends vr {
                constructor(e, t, i, r, n) {
                    super(), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = Pr, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.loadedmetadata = !1, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.onvseeking = null, this.onvended = null, this.logPrefix = "", this.log = void 0, this.warn = void 0, this.playlistType = n, this.logPrefix = r, this.log = Ee.log.bind(Ee, `${r}:`), this.warn = Ee.warn.bind(Ee, `${r}:`), this.hls = e, this.fragmentLoader = new fr(e.config), this.keyLoader = i, this.fragmentTracker = t, this.config = e.config, this.decrypter = new Cr(e.config), e.on(me.MANIFEST_LOADED, this.onManifestLoaded, this)
                }
                doTick() {
                    this.onTickEnd()
                }
                onTickEnd() {}
                startLoad(e) {}
                stopLoad() {
                    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);
                    const e = this.fragCurrent;
                    null != e && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = Pr
                }
                _streamEnded(e, t) {
                    if (t.live || e.nextStart || !e.end || !this.media) return !1;
                    const i = t.partList;
                    if (null != i && i.length) {
                        const e = i[i.length - 1];
                        return Tr.isBuffered(this.media, e.start + e.duration / 2)
                    }
                    const r = t.fragments[t.fragments.length - 1].type;
                    return this.fragmentTracker.isEndListAppended(r)
                }
                getLevelDetails() {
                    var e;
                    if (this.levels && null !== this.levelLastLoaded) return null == (e = this.levels[this.levelLastLoaded]) ? void 0 : e.details
                }
                onMediaAttached(e, t) {
                    const i = this.media = this.mediaBuffer = t.media;
                    this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), i.addEventListener("seeking", this.onvseeking), i.addEventListener("ended", this.onvended);
                    const r = this.config;
                    this.levels && r.autoStartLoad && this.state === Pr && this.startLoad(r.startPosition)
                }
                onMediaDetaching() {
                    const e = this.media;
                    null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
                }
                onMediaSeeking() {
                    const {
                        config: e,
                        fragCurrent: t,
                        media: i,
                        mediaBuffer: r,
                        state: n
                    } = this, s = i ? i.currentTime : 0, a = Tr.bufferInfo(r || i, s, e.maxBufferHole);
                    if (this.log(`media seeking to ${ue(s)?s.toFixed(3):s}, state: ${n}`), this.state === $r) this.resetLoadingState();
                    else if (t) {
                        const i = e.maxFragLookUpTolerance,
                            r = t.start - i,
                            n = t.start + t.duration + i;
                        if (!a.len || n < a.start || r > a.end) {
                            const e = s > n;
                            (s < r || e) && (e && t.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null)
                        }
                    }
                    i && (this.fragmentTracker.removeFragmentsInRange(s, 1 / 0, this.playlistType, !0), this.lastCurrentTime = s), this.loadedmetadata || a.len || (this.nextLoadPosition = this.startPosition = s), this.tickImmediate()
                }
                onMediaEnded() {
                    this.startPosition = this.lastCurrentTime = 0
                }
                onManifestLoaded(e, t) {
                    this.startTimeOffset = t.startTimeOffset, this.initPTS = []
                }
                onHandlerDestroying() {
                    this.stopLoad(), super.onHandlerDestroying()
                }
                onHandlerDestroyed() {
                    this.state = Pr, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed()
                }
                loadFragment(e, t, i) {
                    this._loadFragForPlayback(e, t, i)
                }
                _loadFragForPlayback(e, t, i) {
                    this._doFragLoad(e, t, i, (t => {
                        if (this.fragContextChanged(e)) return this.warn(`Fragment ${e.sn}${t.part?" p: "+t.part.index:""} of level ${e.level} was dropped during download.`), void this.fragmentTracker.removeFragment(e);
                        e.stats.chunkCount++, this._handleFragmentLoadProgress(t)
                    })).then((t => {
                        if (!t) return;
                        const i = this.state;
                        this.fragContextChanged(e) ? (i === Mr || !this.fragCurrent && i === Br) && (this.fragmentTracker.removeFragment(e), this.state = xr) : ("payload" in t && (this.log(`Loaded fragment ${e.sn} of level ${e.level}`), this.hls.trigger(me.FRAG_LOADED, t)), this._handleFragmentLoadComplete(t))
                    })).catch((t => {
                        this.state !== Pr && this.state !== Hr && (this.warn(t), this.resetFragmentLoading(e))
                    }))
                }
                clearTrackerIfNeeded(e) {
                    var t;
                    const {
                        fragmentTracker: i
                    } = this;
                    if (i.getState(e) === ar) {
                        const t = e.type,
                            r = this.getFwdBufferInfo(this.mediaBuffer, t),
                            n = Math.max(e.duration, r ? r.len : this.config.maxBufferLength);
                        this.reduceMaxBufferLength(n) && i.removeFragment(e)
                    } else 0 === (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) ? i.removeAllFragments() : i.hasParts(e.type) && (i.detectPartialFragments({
                        frag: e,
                        part: null,
                        stats: e.stats,
                        id: e.type
                    }), i.getState(e) === or && i.removeFragment(e))
                }
                checkLiveUpdate(e) {
                    if (e.updated && !e.live) {
                        const t = e.fragments[e.fragments.length - 1];
                        this.fragmentTracker.detectPartialFragments({
                            frag: t,
                            part: null,
                            stats: t.stats,
                            id: t.type
                        })
                    }
                    e.fragments[0] || (e.deltaUpdateFailed = !0)
                }
                flushMainBuffer(e, t, i = null) {
                    if (!(e - t)) return;
                    const r = {
                        startOffset: e,
                        endOffset: t,
                        type: i
                    };
                    this.hls.trigger(me.BUFFER_FLUSHING, r)
                }
                _loadInitSegment(e, t) {
                    this._doFragLoad(e, t).then((t => {
                        if (!t || this.fragContextChanged(e) || !this.levels) throw new Error("init load aborted");
                        return t
                    })).then((t => {
                        const {
                            hls: i
                        } = this, {
                            payload: r
                        } = t, n = e.decryptdata;
                        if (r && r.byteLength > 0 && n && n.key && n.iv && "AES-128" === n.method) {
                            const s = self.performance.now();
                            return this.decrypter.decrypt(new Uint8Array(r), n.key.buffer, n.iv.buffer).catch((t => {
                                throw i.trigger(me.ERROR, {
                                    type: pe.MEDIA_ERROR,
                                    details: ge.FRAG_DECRYPT_ERROR,
                                    fatal: !1,
                                    error: t,
                                    reason: t.message,
                                    frag: e
                                }), t
                            })).then((r => {
                                const n = self.performance.now();
                                return i.trigger(me.FRAG_DECRYPTED, {
                                    frag: e,
                                    payload: r,
                                    stats: {
                                        tstart: s,
                                        tdecrypt: n
                                    }
                                }), t.payload = r, t
                            }))
                        }
                        return t
                    })).then((i => {
                        const {
                            fragCurrent: r,
                            hls: n,
                            levels: s
                        } = this;
                        if (!s) throw new Error("init load aborted, missing levels");
                        const a = e.stats;
                        this.state = xr, t.fragmentError = 0, e.data = new Uint8Array(i.payload), a.parsing.start = a.buffering.start = self.performance.now(), a.parsing.end = a.buffering.end = self.performance.now(), i.frag === r && n.trigger(me.FRAG_BUFFERED, {
                            stats: a,
                            frag: r,
                            part: null,
                            id: e.type
                        }), this.tick()
                    })).catch((t => {
                        this.state !== Pr && this.state !== Hr && (this.warn(t), this.resetFragmentLoading(e))
                    }))
                }
                fragContextChanged(e) {
                    const {
                        fragCurrent: t
                    } = this;
                    return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId
                }
                fragBufferedComplete(e, t) {
                    var i, r, n, s;
                    const a = this.mediaBuffer ? this.mediaBuffer : this.media;
                    this.log(`Buffered ${e.type} sn: ${e.sn}${t?" part: "+t.index:""} of ${this.playlistType===ai?"level":"track"} ${e.level} (frag:[${(null!=(i=e.startPTS)?i:NaN).toFixed(3)}-${(null!=(r=e.endPTS)?r:NaN).toFixed(3)}] > buffer:${a?Ir(Tr.getBuffered(a)):"(detached)"})`), this.state = xr, a && (!this.loadedmetadata && e.type == ai && a.buffered.length && (null == (n = this.fragCurrent) ? void 0 : n.sn) === (null == (s = this.fragPrevious) ? void 0 : s.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick())
                }
                seekToStartPos() {}
                _handleFragmentLoadComplete(e) {
                    const {
                        transmuxer: t
                    } = this;
                    if (!t) return;
                    const {
                        frag: i,
                        part: r,
                        partsLoaded: n
                    } = e, s = !n || 0 === n.length || n.some((e => !e)), a = new Er(i.level, i.sn, i.stats.chunkCount + 1, 0, r ? r.index : -1, !s);
                    t.flush(a)
                }
                _handleFragmentLoadProgress(e) {}
                _doFragLoad(e, t, i = null, r) {
                    var n;
                    const s = null == t ? void 0 : t.details;
                    if (!this.levels || !s) throw new Error(`frag load aborted, missing level${s?"":" detail"}s`);
                    let a = null;
                    if (!e.encrypted || null != (n = e.decryptdata) && n.key ? !e.encrypted && s.encryptedFragments.length && this.keyLoader.loadClear(e, s.encryptedFragments) : (this.log(`Loading key for ${e.sn} of [${s.startSN}-${s.endSN}], ${"[stream-controller]"===this.logPrefix?"level":"track"} ${e.level}`), this.state = Or, this.fragCurrent = e, a = this.keyLoader.load(e).then((e => {
                            if (!this.fragContextChanged(e.frag)) return this.hls.trigger(me.KEY_LOADED, e), this.state === Or && (this.state = xr), e
                        })), this.hls.trigger(me.KEY_LOADING, {
                            frag: e
                        }), null === this.fragCurrent && (a = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING")))), i = Math.max(e.start, i || 0), this.config.lowLatencyMode && "initSegment" !== e.sn) {
                        const n = s.partList;
                        if (n && r) {
                            i > e.end && s.fragmentHint && (e = s.fragmentHint);
                            const o = this.getNextPart(n, e, i);
                            if (o > -1) {
                                const l = n[o];
                                let c;
                                return this.log(`Loading part sn: ${e.sn} p: ${l.index} cc: ${e.cc} of playlist [${s.startSN}-${s.endSN}] parts [0-${o}-${n.length-1}] ${"[stream-controller]"===this.logPrefix?"level":"track"}: ${e.level}, target: ${parseFloat(i.toFixed(3))}`), this.nextLoadPosition = l.start + l.duration, this.state = Mr, c = a ? a.then((i => !i || this.fragContextChanged(i.frag) ? null : this.doFragPartsLoad(e, l, t, r))).catch((e => this.handleFragLoadError(e))) : this.doFragPartsLoad(e, l, t, r).catch((e => this.handleFragLoadError(e))), this.hls.trigger(me.FRAG_LOADING, {
                                    frag: e,
                                    part: l,
                                    targetBufferTime: i
                                }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : c
                            }
                            if (!e.url || this.loadedEndOfParts(n, i)) return Promise.resolve(null)
                        }
                    }
                    this.log(`Loading fragment ${e.sn} cc: ${e.cc} ${s?"of ["+s.startSN+"-"+s.endSN+"] ":""}${"[stream-controller]"===this.logPrefix?"level":"track"}: ${e.level}, target: ${parseFloat(i.toFixed(3))}`), ue(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = Mr;
                    const o = this.config.progressive;
                    let l;
                    return l = o && a ? a.then((t => !t || this.fragContextChanged(null == t ? void 0 : t.frag) ? null : this.fragmentLoader.load(e, r))).catch((e => this.handleFragLoadError(e))) : Promise.all([this.fragmentLoader.load(e, o ? r : void 0), a]).then((([e]) => (!o && e && r && r(e), e))).catch((e => this.handleFragLoadError(e))), this.hls.trigger(me.FRAG_LOADING, {
                        frag: e,
                        targetBufferTime: i
                    }), null === this.fragCurrent ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : l
                }
                doFragPartsLoad(e, t, i, r) {
                    return new Promise(((n, s) => {
                        var a;
                        const o = [],
                            l = null == (a = i.details) ? void 0 : a.partList,
                            c = t => {
                                this.fragmentLoader.loadPart(e, t, r).then((r => {
                                    o[t.index] = r;
                                    const s = r.part;
                                    this.hls.trigger(me.FRAG_LOADED, r);
                                    const a = Ni(i, e.sn, t.index + 1) || Fi(l, e.sn, t.index + 1);
                                    if (!a) return n({
                                        frag: e,
                                        part: s,
                                        partsLoaded: o
                                    });
                                    c(a)
                                })).catch(s)
                            };
                        c(t)
                    }))
                }
                handleFragLoadError(e) {
                    if ("data" in e) {
                        const t = e.data;
                        e.data && t.details === ge.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(me.ERROR, t)
                    } else this.hls.trigger(me.ERROR, {
                        type: pe.OTHER_ERROR,
                        details: ge.INTERNAL_EXCEPTION,
                        err: e,
                        error: e,
                        fatal: !0
                    });
                    return null
                }
                _handleTransmuxerFlush(e) {
                    const t = this.getCurrentContext(e);
                    if (!t || this.state !== Br) return void(this.fragCurrent || this.state === Pr || this.state === Hr || (this.state = xr));
                    const {
                        frag: i,
                        part: r,
                        level: n
                    } = t, s = self.performance.now();
                    i.stats.parsing.end = s, r && (r.stats.parsing.end = s), this.updateLevelTiming(i, r, n, e.partial)
                }
                getCurrentContext(e) {
                    const {
                        levels: t,
                        fragCurrent: i
                    } = this, {
                        level: r,
                        sn: n,
                        part: s
                    } = e;
                    if (null == t || !t[r]) return this.warn(`Levels object was unset while buffering fragment ${n} of level ${r}. The current chunk will not be buffered.`), null;
                    const a = t[r],
                        o = s > -1 ? Ni(a, n, s) : null,
                        l = o ? o.fragment : function(e, t, i) {
                            if (null == e || !e.details) return null;
                            const r = e.details;
                            let n = r.fragments[t - r.startSN];
                            return n || (n = r.fragmentHint, n && n.sn === t ? n : t < r.startSN && i && i.sn === t ? i : null)
                        }(a, n, i);
                    return l ? (i && i !== l && (l.stats = i.stats), {
                        frag: l,
                        part: o,
                        level: a
                    }) : null
                }
                bufferFragmentData(e, t, i, r, n) {
                    var s;
                    if (!e || this.state !== Br) return;
                    const {
                        data1: a,
                        data2: o
                    } = e;
                    let l = a;
                    if (a && o && (l = kt(a, o)), null == (s = l) || !s.length) return;
                    const c = {
                        type: e.type,
                        frag: t,
                        part: i,
                        chunkMeta: r,
                        parent: t.type,
                        data: l
                    };
                    if (this.hls.trigger(me.BUFFER_APPENDING, c), e.dropped && e.independent && !i) {
                        if (n) return;
                        this.flushBufferGap(t)
                    }
                }
                flushBufferGap(e) {
                    const t = this.media;
                    if (!t) return;
                    if (!Tr.isBuffered(t, t.currentTime)) return void this.flushMainBuffer(0, e.start);
                    const i = t.currentTime,
                        r = Tr.bufferInfo(t, i, 0),
                        n = e.duration,
                        s = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * n),
                        a = Math.max(Math.min(e.start - s, r.end - s), i + s);
                    e.start - a > s && this.flushMainBuffer(a, e.start)
                }
                getFwdBufferInfo(e, t) {
                    const i = this.getLoadPosition();
                    return ue(i) ? this.getFwdBufferInfoAtPos(e, i, t) : null
                }
                getFwdBufferInfoAtPos(e, t, i) {
                    const {
                        config: {
                            maxBufferHole: r
                        }
                    } = this, n = Tr.bufferInfo(e, t, r);
                    if (0 === n.len && void 0 !== n.nextStart) {
                        const s = this.fragmentTracker.getBufferedFrag(t, i);
                        if (s && n.nextStart < s.end) return Tr.bufferInfo(e, t, Math.max(n.nextStart, r))
                    }
                    return n
                }
                getMaxBufferLength(e) {
                    const {
                        config: t
                    } = this;
                    let i;
                    return i = e ? Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : t.maxBufferLength, Math.min(i, t.maxMaxBufferLength)
                }
                reduceMaxBufferLength(e) {
                    const t = this.config,
                        i = e || t.maxBufferLength;
                    return t.maxMaxBufferLength >= i && (t.maxMaxBufferLength /= 2, this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`), !0)
                }
                getAppendedFrag(e, t = ai) {
                    const i = this.fragmentTracker.getAppendedFrag(e, ai);
                    return i && "fragment" in i ? i.fragment : i
                }
                getNextFragment(e, t) {
                    const i = t.fragments,
                        r = i.length;
                    if (!r) return null;
                    const {
                        config: n
                    } = this, s = i[0].start;
                    let a;
                    if (t.live) {
                        const s = n.initialLiveManifestSize;
                        if (r < s) return this.warn(`Not enough fragments to start playback (have: ${r}, need: ${s})`), null;
                        t.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (a = this.getInitialLiveFragment(t, i), this.startPosition = a ? this.hls.liveSyncPosition || a.start : e)
                    } else e <= s && (a = i[0]);
                    if (!a) {
                        const i = n.lowLatencyMode ? t.partEnd : t.fragmentEnd;
                        a = this.getFragmentAtPosition(e, i, t)
                    }
                    return this.mapToInitFragWhenRequired(a)
                }
                isLoopLoading(e, t) {
                    const i = this.fragmentTracker.getState(e);
                    return (i === lr || i === or && !!e.gap) && this.nextLoadPosition > t
                }
                getNextFragmentLoopLoading(e, t, i, r, n) {
                    const s = e.gap,
                        a = this.getNextFragment(this.nextLoadPosition, t);
                    if (null === a) return a;
                    if (e = a, s && e && !e.gap && i.nextStart) {
                        const t = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, i.nextStart, r);
                        if (null !== t && i.len + t.len >= n) return this.log(`buffer full after gaps in "${r}" playlist starting at sn: ${e.sn}`), null
                    }
                    return e
                }
                mapToInitFragWhenRequired(e) {
                    return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment
                }
                getNextPart(e, t, i) {
                    let r = -1,
                        n = !1,
                        s = !0;
                    for (let a = 0, o = e.length; a < o; a++) {
                        const o = e[a];
                        if (s = s && !o.independent, r > -1 && i < o.start) break;
                        const l = o.loaded;
                        l ? r = -1 : (n || o.independent || s) && o.fragment === t && (r = a), n = l
                    }
                    return r
                }
                loadedEndOfParts(e, t) {
                    const i = e[e.length - 1];
                    return i && t > i.start && i.loaded
                }
                getInitialLiveFragment(e, t) {
                    const i = this.fragPrevious;
                    let r = null;
                    if (i) {
                        if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${i.programDateTime}`), r = function(e, t, i) {
                                if (null === t || !Array.isArray(e) || !e.length || !ue(t)) return null;
                                if (t < (e[0].programDateTime || 0)) return null;
                                if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null;
                                i = i || 0;
                                for (let r = 0; r < e.length; ++r) {
                                    const n = e[r];
                                    if (Ki(t, i, n)) return n
                                }
                                return null
                            }(t, i.endProgramDateTime, this.config.maxFragLookUpTolerance)), !r) {
                            const n = i.sn + 1;
                            if (n >= e.startSN && n <= e.endSN) {
                                const s = t[n - e.startSN];
                                i.cc === s.cc && (r = s, this.log(`Live playlist, switching playlist, load frag with next SN: ${r.sn}`))
                            }
                            r || (r = function(e, t) {
                                return Gi.search(e, (e => e.cc < t ? 1 : e.cc > t ? -1 : 0))
                            }(t, i.cc), r && this.log(`Live playlist, switching playlist, load frag with same CC: ${r.sn}`))
                        }
                    } else {
                        const t = this.hls.liveSyncPosition;
                        null !== t && (r = this.getFragmentAtPosition(t, this.bitrateTest ? e.fragmentEnd : e.edge, e))
                    }
                    return r
                }
                getFragmentAtPosition(e, t, i) {
                    const {
                        config: r
                    } = this;
                    let {
                        fragPrevious: n
                    } = this, {
                        fragments: s,
                        endSN: a
                    } = i;
                    const {
                        fragmentHint: o
                    } = i, l = r.maxFragLookUpTolerance, c = i.partList, d = !!(r.lowLatencyMode && null != c && c.length && o);
                    let u;
                    if (d && o && !this.bitrateTest && (s = s.concat(o), a = o.sn), e < t) {
                        u = Vi(n, s, e, e > t - l ? 0 : l)
                    } else u = s[s.length - 1];
                    if (u) {
                        const e = u.sn - i.startSN,
                            t = this.fragmentTracker.getState(u);
                        if ((t === lr || t === or && u.gap) && (n = u), n && u.sn === n.sn && (!d || c[0].fragment.sn > u.sn)) {
                            if (n && u.level === n.level) {
                                const t = s[e + 1];
                                u = u.sn < a && this.fragmentTracker.getState(t) !== lr ? t : null
                            }
                        }
                    }
                    return u
                }
                synchronizeToLiveEdge(e) {
                    const {
                        config: t,
                        media: i
                    } = this;
                    if (!i) return;
                    const r = this.hls.liveSyncPosition,
                        n = i.currentTime,
                        s = e.fragments[0].start,
                        a = e.edge,
                        o = n >= s - t.maxFragLookUpTolerance && n <= a;
                    if (null !== r && i.duration > r && (n < r || !o)) {
                        const s = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
                        (!o && i.readyState < 4 || n < a - s) && (this.loadedmetadata || (this.nextLoadPosition = r), i.readyState && (this.warn(`Playback: ${n.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${r.toFixed(3)}`), i.currentTime = r))
                    }
                }
                alignPlaylists(e, t) {
                    const {
                        levels: i,
                        levelLastLoaded: r,
                        fragPrevious: n
                    } = this, s = null !== r ? i[r] : null, a = e.fragments.length;
                    if (!a) return this.warn("No fragments in live playlist"), 0;
                    const o = e.fragments[0].start,
                        l = !t,
                        c = e.alignedSliding && ue(o);
                    if (l || !c && !o) {
                        kr(n, s, e);
                        const i = e.fragments[0].start;
                        return this.log(`Live playlist sliding: ${i.toFixed(2)} start-sn: ${t?t.startSN:"na"}->${e.startSN} prev-sn: ${n?n.sn:"na"} fragments: ${a}`), i
                    }
                    return o
                }
                waitForCdnTuneIn(e) {
                    return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget)
                }
                setStartPosition(e, t) {
                    let i = this.startPosition;
                    if (i < t && (i = -1), -1 === i || -1 === this.lastCurrentTime) {
                        const r = null !== this.startTimeOffset,
                            n = r ? this.startTimeOffset : e.startTimeOffset;
                        null !== n && ue(n) ? (i = t + n, n < 0 && (i += e.totalduration), i = Math.min(Math.max(t, i), t + e.totalduration), this.log(`Start time offset ${n} found in ${r?"multivariant":"media"} playlist, adjust startPosition to ${i}`), this.startPosition = i) : e.live ? i = this.hls.liveSyncPosition || t : this.startPosition = i = 0, this.lastCurrentTime = i
                    }
                    this.nextLoadPosition = i
                }
                getLoadPosition() {
                    const {
                        media: e
                    } = this;
                    let t = 0;
                    return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t
                }
                handleFragLoadAborted(e, t) {
                    this.transmuxer && "initSegment" !== e.sn && e.stats.aborted && (this.warn(`Fragment ${e.sn}${t?" part "+t.index:""} of level ${e.level} was aborted`), this.resetFragmentLoading(e))
                }
                resetFragmentLoading(e) {
                    this.fragCurrent && (this.fragContextChanged(e) || this.state === Nr) || (this.state = xr)
                }
                onFragmentOrKeyLoadError(e, t) {
                    if (t.chunkMeta && !t.frag) {
                        const e = this.getCurrentContext(t.chunkMeta);
                        e && (t.frag = e.frag)
                    }
                    const i = t.frag;
                    if (!i || i.type !== e || !this.levels) return;
                    var r;
                    if (this.fragContextChanged(i)) return void this.warn(`Frag load error must match current frag to retry ${i.url} > ${null==(r=this.fragCurrent)?void 0:r.url}`);
                    const n = t.details === ge.FRAG_GAP;
                    n && this.fragmentTracker.fragBuffered(i, !0);
                    const s = t.errorAction,
                        {
                            action: a,
                            retryCount: o = 0,
                            retryConfig: l
                        } = s || {};
                    if (s && a === zi && l) {
                        var c;
                        this.resetStartWhenNotLoaded(null != (c = this.levelLastLoaded) ? c : i.level);
                        const r = $i(l, o);
                        this.warn(`Fragment ${i.sn} of ${e} ${i.level} errored with ${t.details}, retrying loading ${o+1}/${l.maxNumRetry} in ${r}ms`), s.resolved = !0, this.retryDate = self.performance.now() + r, this.state = Nr
                    } else l && s ? (this.resetFragmentErrors(e), o < l.maxNumRetry ? n || (s.resolved = !0) : Ee.warn(`${t.details} reached or exceeded max retry (${o})`)) : (null == s ? void 0 : s.action) === Yi ? this.state = Gr : this.state = Hr;
                    this.tickImmediate()
                }
                reduceLengthAndFlushBuffer(e) {
                    if (this.state === Br || this.state === Ur) {
                        const t = e.parent,
                            i = this.getFwdBufferInfo(this.mediaBuffer, t),
                            r = i && i.len > .5;
                        r && this.reduceMaxBufferLength(i.len);
                        const n = !r;
                        return n && this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), n
                    }
                    return !1
                }
                resetFragmentErrors(e) {
                    e === oi && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== Pr && (this.state = xr)
                }
                afterBufferFlushed(e, t, i) {
                    if (!e) return;
                    const r = Tr.getBuffered(e);
                    this.fragmentTracker.detectEvictedFragments(t, r, i), this.state === $r && this.resetLoadingState()
                }
                resetLoadingState() {
                    this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = xr
                }
                resetStartWhenNotLoaded(e) {
                    if (!this.loadedmetadata) {
                        this.startFragRequested = !1;
                        const t = this.levels ? this.levels[e].details : null;
                        null != t && t.live ? (this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
                    }
                }
                resetWhenMissingContext(e) {
                    var t;
                    this.warn(`The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(null != (t = this.levelLastLoaded) ? t : e.level), this.resetLoadingState()
                }
                removeUnbufferedFrags(e = 0) {
                    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0)
                }
                updateLevelTiming(e, t, i, r) {
                    var n;
                    const s = i.details;
                    if (!s) return void this.warn("level.details undefined");
                    if (Object.keys(e.elementaryStreams).reduce(((t, n) => {
                            const a = e.elementaryStreams[n];
                            if (a) {
                                const o = a.endPTS - a.startPTS;
                                if (o <= 0) return this.warn(`Could not parse fragment ${e.sn} ${n} duration reliably (${o})`), t || !1;
                                const l = r ? 0 : Pi(s, e, a.startPTS, a.endPTS, a.startDTS, a.endDTS);
                                return this.hls.trigger(me.LEVEL_PTS_UPDATED, {
                                    details: s,
                                    level: i,
                                    drift: l,
                                    type: n,
                                    frag: e,
                                    start: a.startPTS,
                                    end: a.endPTS
                                }), !0
                            }
                            return t
                        }), !1)) i.fragmentError = 0;
                    else if (null === (null == (n = this.transmuxer) ? void 0 : n.error)) {
                        const t = new Error(`Found no media in fragment ${e.sn} of level ${e.level} resetting transmuxer to fallback to playlist timing`);
                        if (0 === i.fragmentError && (i.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0)), this.warn(t.message), this.hls.trigger(me.ERROR, {
                                type: pe.MEDIA_ERROR,
                                details: ge.FRAG_PARSING_ERROR,
                                fatal: !1,
                                error: t,
                                frag: e,
                                reason: `Found no media in msn ${e.sn} of level "${i.url}"`
                            }), !this.hls) return;
                        this.resetTransmuxer()
                    }
                    this.state = Ur, this.hls.trigger(me.FRAG_PARSED, {
                        frag: e,
                        part: t
                    })
                }
                resetTransmuxer() {
                    this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
                }
                recoverWorkerError(e) {
                    var t, i, r;
                    "demuxerWorker" === e.event && (this.fragmentTracker.removeAllFragments(), this.resetTransmuxer(), this.resetStartWhenNotLoaded(null != (t = null != (i = this.levelLastLoaded) ? i : null == (r = this.fragCurrent) ? void 0 : r.level) ? t : 0), this.resetLoadingState())
                }
                set state(e) {
                    const t = this._state;
                    t !== e && (this._state = e, this.log(`${t}->${e}`))
                }
                get state() {
                    return this._state
                }
            }

            function qr() {
                return self.SourceBuffer || self.WebKitSourceBuffer
            }

            function Kr(e = "", t = 9e4) {
                return {
                    type: e,
                    id: -1,
                    pid: -1,
                    inputTimeScale: t,
                    sequenceNumber: -1,
                    samples: [],
                    dropped: 0
                }
            }
            class Wr {
                constructor() {
                    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
                }
                resetInitSegment(e, t, i, r) {
                    this._id3Track = {
                        type: "id3",
                        id: 3,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: 0,
                        samples: [],
                        dropped: 0
                    }
                }
                resetTimeStamp(e) {
                    this.initPTS = e, this.resetContiguity()
                }
                resetContiguity() {
                    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
                }
                canParse(e, t) {
                    return !1
                }
                appendFrame(e, t, i) {}
                demux(e, t) {
                    this.cachedData && (e = kt(this.cachedData, e), this.cachedData = null);
                    let i, r = Qe(e, 0),
                        n = r ? r.length : 0;
                    const s = this._audioTrack,
                        a = this._id3Track,
                        o = r ? (e => {
                            const t = it(e);
                            for (let e = 0; e < t.length; e++) {
                                const i = t[e];
                                if (et(i)) return ot(i)
                            }
                        })(r) : void 0,
                        l = e.length;
                    for ((null === this.basePTS || 0 === this.frameIndex && ue(o)) && (this.basePTS = Yr(o, t, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), r && r.length > 0 && a.samples.push({
                            pts: this.lastPTS,
                            dts: this.lastPTS,
                            data: r,
                            type: gi,
                            duration: Number.POSITIVE_INFINITY
                        }); n < l;) {
                        if (this.canParse(e, n)) {
                            const t = this.appendFrame(s, e, n);
                            t ? (this.frameIndex++, this.lastPTS = t.sample.pts, n += t.length, i = n) : n = l
                        } else Ze(e, n) ? (r = Qe(e, n), a.samples.push({
                            pts: this.lastPTS,
                            dts: this.lastPTS,
                            data: r,
                            type: gi,
                            duration: Number.POSITIVE_INFINITY
                        }), n += r.length, i = n) : n++;
                        if (n === l && i !== l) {
                            const t = Ye(e, i);
                            this.cachedData ? this.cachedData = kt(this.cachedData, t) : this.cachedData = t
                        }
                    }
                    return {
                        audioTrack: s,
                        videoTrack: Kr(),
                        id3Track: a,
                        textTrack: Kr()
                    }
                }
                demuxSampleAes(e, t, i) {
                    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
                }
                flush(e) {
                    const t = this.cachedData;
                    return t && (this.cachedData = null, this.demux(t, 0)), {
                        audioTrack: this._audioTrack,
                        videoTrack: Kr(),
                        id3Track: this._id3Track,
                        textTrack: Kr()
                    }
                }
                destroy() {}
            }
            const Yr = (e, t, i) => {
                if (ue(e)) return 90 * e;
                return 9e4 * t + (i ? 9e4 * i.baseTime / i.timescale : 0)
            };

            function zr(e, t) {
                return 255 === e[t] && 240 == (246 & e[t + 1])
            }

            function Xr(e, t) {
                return 1 & e[t + 1] ? 7 : 9
            }

            function Qr(e, t) {
                return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5
            }

            function Jr(e, t) {
                return t + 1 < e.length && zr(e, t)
            }

            function Zr(e, t) {
                if (Jr(e, t)) {
                    const i = Xr(e, t);
                    if (t + i >= e.length) return !1;
                    const r = Qr(e, t);
                    if (r <= i) return !1;
                    const n = t + r;
                    return n === e.length || Jr(e, n)
                }
                return !1
            }

            function en(e, t, i, r, n) {
                if (!e.samplerate) {
                    const s = function(e, t, i, r) {
                        let n, s, a, o;
                        const l = navigator.userAgent.toLowerCase(),
                            c = r,
                            d = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                        n = 1 + ((192 & t[i + 2]) >>> 6);
                        const u = (60 & t[i + 2]) >>> 2;
                        if (!(u > d.length - 1)) return a = (1 & t[i + 2]) << 2, a |= (192 & t[i + 3]) >>> 6, Ee.log(`manifest codec:${r}, ADTS type:${n}, samplingIndex:${u}`), /firefox/i.test(l) ? u >= 6 ? (n = 5, o = new Array(4), s = u - 3) : (n = 2, o = new Array(2), s = u) : -1 !== l.indexOf("android") ? (n = 2, o = new Array(2), s = u) : (n = 5, o = new Array(4), r && (-1 !== r.indexOf("mp4a.40.29") || -1 !== r.indexOf("mp4a.40.5")) || !r && u >= 6 ? s = u - 3 : ((r && -1 !== r.indexOf("mp4a.40.2") && (u >= 6 && 1 === a || /vivaldi/i.test(l)) || !r && 1 === a) && (n = 2, o = new Array(2)), s = u)), o[0] = n << 3, o[0] |= (14 & u) >> 1, o[1] |= (1 & u) << 7, o[1] |= a << 3, 5 === n && (o[1] |= (14 & s) >> 1, o[2] = (1 & s) << 7, o[2] |= 8, o[3] = 0), {
                            config: o,
                            samplerate: d[u],
                            channelCount: a,
                            codec: "mp4a.40." + n,
                            manifestCodec: c
                        };
                        e.trigger(me.ERROR, {
                            type: pe.MEDIA_ERROR,
                            details: ge.FRAG_PARSING_ERROR,
                            fatal: !0,
                            reason: `invalid ADTS sampling index:${u}`
                        })
                    }(t, i, r, n);
                    if (!s) return;
                    e.config = s.config, e.samplerate = s.samplerate, e.channelCount = s.channelCount, e.codec = s.codec, e.manifestCodec = s.manifestCodec, Ee.log(`parsed codec:${e.codec}, rate:${s.samplerate}, channels:${s.channelCount}`)
                }
            }

            function tn(e) {
                return 9216e4 / e
            }

            function rn(e, t, i, r, n) {
                const s = r + n * tn(e.samplerate),
                    a = function(e, t) {
                        const i = Xr(e, t);
                        if (t + i <= e.length) {
                            const r = Qr(e, t) - i;
                            if (r > 0) return {
                                headerLength: i,
                                frameLength: r
                            }
                        }
                    }(t, i);
                let o;
                if (a) {
                    const {
                        frameLength: r,
                        headerLength: n
                    } = a, l = n + r, c = Math.max(0, i + l - t.length);
                    c ? (o = new Uint8Array(l - n), o.set(t.subarray(i + n, t.length), 0)) : o = t.subarray(i + n, i + l);
                    const d = {
                        unit: o,
                        pts: s
                    };
                    return c || e.samples.push(d), {
                        sample: d,
                        length: l,
                        missing: c
                    }
                }
                const l = t.length - i;
                o = new Uint8Array(l), o.set(t.subarray(i, t.length), 0);
                return {
                    sample: {
                        unit: o,
                        pts: s
                    },
                    length: l,
                    missing: -1
                }
            }
            const nn = /\/emsg[-/]ID3/i;
            let sn = null;
            const an = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
                on = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
                ln = [
                    [0, 72, 144, 12],
                    [0, 0, 0, 0],
                    [0, 72, 144, 12],
                    [0, 144, 144, 12]
                ],
                cn = [0, 1, 1, 4];

            function dn(e, t, i, r, n) {
                if (i + 24 > t.length) return;
                const s = un(t, i);
                if (s && i + s.frameLength <= t.length) {
                    const a = r + n * (9e4 * s.samplesPerFrame / s.sampleRate),
                        o = {
                            unit: t.subarray(i, i + s.frameLength),
                            pts: a,
                            dts: a
                        };
                    return e.config = [], e.channelCount = s.channelCount, e.samplerate = s.sampleRate, e.samples.push(o), {
                        sample: o,
                        length: s.frameLength,
                        missing: 0
                    }
                }
            }

            function un(e, t) {
                const i = e[t + 1] >> 3 & 3,
                    r = e[t + 1] >> 1 & 3,
                    n = e[t + 2] >> 4 & 15,
                    s = e[t + 2] >> 2 & 3;
                if (1 !== i && 0 !== n && 15 !== n && 3 !== s) {
                    const a = e[t + 2] >> 1 & 1,
                        o = e[t + 3] >> 6,
                        l = 1e3 * an[14 * (3 === i ? 3 - r : 3 === r ? 3 : 4) + n - 1],
                        c = on[3 * (3 === i ? 0 : 2 === i ? 1 : 2) + s],
                        d = 3 === o ? 1 : 2,
                        u = ln[i][r],
                        h = cn[r],
                        f = 8 * u * h,
                        m = Math.floor(u * l / c + a) * h;
                    if (null === sn) {
                        const e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                        sn = e ? parseInt(e[1]) : 0
                    }
                    return !!sn && sn <= 87 && 2 === r && l >= 224e3 && 0 === o && (e[t + 3] = 128 | e[t + 3]), {
                        sampleRate: c,
                        channelCount: d,
                        frameLength: m,
                        samplesPerFrame: f
                    }
                }
            }

            function hn(e, t) {
                return !(255 !== e[t] || 224 & ~e[t + 1] || !(6 & e[t + 1]))
            }

            function fn(e, t) {
                return t + 1 < e.length && hn(e, t)
            }

            function mn(e, t) {
                if (t + 1 < e.length && hn(e, t)) {
                    const i = 4,
                        r = un(e, t);
                    let n = i;
                    null != r && r.frameLength && (n = r.frameLength);
                    const s = t + n;
                    return s === e.length || fn(e, s)
                }
                return !1
            }
            class pn {
                constructor(e) {
                    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0
                }
                loadWord() {
                    const e = this.data,
                        t = this.bytesAvailable,
                        i = e.byteLength - t,
                        r = new Uint8Array(4),
                        n = Math.min(4, t);
                    if (0 === n) throw new Error("no bytes available");
                    r.set(e.subarray(i, i + n)), this.word = new DataView(r.buffer).getUint32(0), this.bitsAvailable = 8 * n, this.bytesAvailable -= n
                }
                skipBits(e) {
                    let t;
                    e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (t = (e -= this.bitsAvailable) >> 3, e -= t << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e)
                }
                readBits(e) {
                    let t = Math.min(this.bitsAvailable, e);
                    const i = this.word >>> 32 - t;
                    if (e > 32 && Ee.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t;
                    else {
                        if (!(this.bytesAvailable > 0)) throw new Error("no bits available");
                        this.loadWord()
                    }
                    return t = e - t, t > 0 && this.bitsAvailable ? i << t | this.readBits(t) : i
                }
                skipLZ() {
                    let e;
                    for (e = 0; e < this.bitsAvailable; ++e)
                        if (this.word & 2147483648 >>> e) return this.word <<= e, this.bitsAvailable -= e, e;
                    return this.loadWord(), e + this.skipLZ()
                }
                skipUEG() {
                    this.skipBits(1 + this.skipLZ())
                }
                skipEG() {
                    this.skipBits(1 + this.skipLZ())
                }
                readUEG() {
                    const e = this.skipLZ();
                    return this.readBits(e + 1) - 1
                }
                readEG() {
                    const e = this.readUEG();
                    return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
                }
                readBoolean() {
                    return 1 === this.readBits(1)
                }
                readUByte() {
                    return this.readBits(8)
                }
                readUShort() {
                    return this.readBits(16)
                }
                readUInt() {
                    return this.readBits(32)
                }
                skipScalingList(e) {
                    let t, i = 8,
                        r = 8;
                    for (let n = 0; n < e; n++) 0 !== r && (t = this.readEG(), r = (i + t + 256) % 256), i = 0 === r ? i : r
                }
                readSPS() {
                    let e, t, i, r = 0,
                        n = 0,
                        s = 0,
                        a = 0;
                    const o = this.readUByte.bind(this),
                        l = this.readBits.bind(this),
                        c = this.readUEG.bind(this),
                        d = this.readBoolean.bind(this),
                        u = this.skipBits.bind(this),
                        h = this.skipEG.bind(this),
                        f = this.skipUEG.bind(this),
                        m = this.skipScalingList.bind(this);
                    o();
                    const p = o();
                    if (l(5), u(3), o(), f(), 100 === p || 110 === p || 122 === p || 244 === p || 44 === p || 83 === p || 86 === p || 118 === p || 128 === p) {
                        const e = c();
                        if (3 === e && u(1), f(), f(), u(1), d())
                            for (t = 3 !== e ? 8 : 12, i = 0; i < t; i++) d() && m(i < 6 ? 16 : 64)
                    }
                    f();
                    const g = c();
                    if (0 === g) c();
                    else if (1 === g)
                        for (u(1), h(), h(), e = c(), i = 0; i < e; i++) h();
                    f(), u(1);
                    const y = c(),
                        v = c(),
                        b = l(1);
                    0 === b && u(1), u(1), d() && (r = c(), n = c(), s = c(), a = c());
                    let T = [1, 1];
                    if (d() && d()) {
                        switch (o()) {
                            case 1:
                                T = [1, 1];
                                break;
                            case 2:
                                T = [12, 11];
                                break;
                            case 3:
                                T = [10, 11];
                                break;
                            case 4:
                                T = [16, 11];
                                break;
                            case 5:
                                T = [40, 33];
                                break;
                            case 6:
                                T = [24, 11];
                                break;
                            case 7:
                                T = [20, 11];
                                break;
                            case 8:
                                T = [32, 11];
                                break;
                            case 9:
                                T = [80, 33];
                                break;
                            case 10:
                                T = [18, 11];
                                break;
                            case 11:
                                T = [15, 11];
                                break;
                            case 12:
                                T = [64, 33];
                                break;
                            case 13:
                                T = [160, 99];
                                break;
                            case 14:
                                T = [4, 3];
                                break;
                            case 15:
                                T = [3, 2];
                                break;
                            case 16:
                                T = [2, 1];
                                break;
                            case 255:
                                T = [o() << 8 | o(), o() << 8 | o()]
                        }
                    }
                    return {
                        width: Math.ceil(16 * (y + 1) - 2 * r - 2 * n),
                        height: (2 - b) * (v + 1) * 16 - (b ? 2 : 4) * (s + a),
                        pixelRatio: T
                    }
                }
                readSliceType() {
                    return this.readUByte(), this.readUEG(), this.readUEG()
                }
            }
            class gn {
                constructor(e, t, i) {
                    this.keyData = void 0, this.decrypter = void 0, this.keyData = i, this.decrypter = new Cr(t, {
                        removePKCS7Padding: !1
                    })
                }
                decryptBuffer(e) {
                    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer)
                }
                decryptAacSample(e, t, i) {
                    const r = e[t].unit;
                    if (r.length <= 16) return;
                    const n = r.subarray(16, r.length - r.length % 16),
                        s = n.buffer.slice(n.byteOffset, n.byteOffset + n.length);
                    this.decryptBuffer(s).then((n => {
                        const s = new Uint8Array(n);
                        r.set(s, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, i)
                    }))
                }
                decryptAacSamples(e, t, i) {
                    for (;; t++) {
                        if (t >= e.length) return void i();
                        if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, i), !this.decrypter.isSync())) return
                    }
                }
                getAvcEncryptedData(e) {
                    const t = 16 * Math.floor((e.length - 48) / 160) + 16,
                        i = new Int8Array(t);
                    let r = 0;
                    for (let t = 32; t < e.length - 16; t += 160, r += 16) i.set(e.subarray(t, t + 16), r);
                    return i
                }
                getAvcDecryptedUnit(e, t) {
                    const i = new Uint8Array(t);
                    let r = 0;
                    for (let t = 32; t < e.length - 16; t += 160, r += 16) e.set(i.subarray(r, r + 16), t);
                    return e
                }
                decryptAvcSample(e, t, i, r, n) {
                    const s = Dt(n.data),
                        a = this.getAvcEncryptedData(s);
                    this.decryptBuffer(a.buffer).then((a => {
                        n.data = this.getAvcDecryptedUnit(s, a), this.decrypter.isSync() || this.decryptAvcSamples(e, t, i + 1, r)
                    }))
                }
                decryptAvcSamples(e, t, i, r) {
                    if (e instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
                    for (;; t++, i = 0) {
                        if (t >= e.length) return void r();
                        const n = e[t].units;
                        for (; !(i >= n.length); i++) {
                            const s = n[i];
                            if (!(s.data.length <= 48 || 1 !== s.type && 5 !== s.type || (this.decryptAvcSample(e, t, i, r, s), this.decrypter.isSync()))) return
                        }
                    }
                }
            }
            const yn = 188;
            class vn {
                constructor(e, t, i) {
                    this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = e, this.config = t, this.typeSupported = i
                }
                static probe(e) {
                    const t = vn.syncOffset(e);
                    return t > 0 && Ee.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`), -1 !== t
                }
                static syncOffset(e) {
                    const t = e.length;
                    let i = Math.min(940, e.length - yn) + 1,
                        r = 0;
                    for (; r < i;) {
                        let n = !1,
                            s = -1,
                            a = 0;
                        for (let o = r; o < t; o += yn) {
                            if (71 !== e[o]) {
                                if (a) return -1;
                                break
                            }
                            if (a++, -1 === s && (s = o, 0 !== s && (i = Math.min(s + 18612, e.length - yn) + 1)), n || (n = 0 === Tn(e, o)), n && a > 1 && (0 === s && a > 2 || o + yn > i)) return s
                        }
                        r++
                    }
                    return -1
                }
                static createTrack(e, t) {
                    return {
                        container: "video" === e || "audio" === e ? "video/mp2t" : void 0,
                        type: e,
                        id: mt[e],
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: 0,
                        samples: [],
                        dropped: 0,
                        duration: "audio" === e ? t : void 0
                    }
                }
                resetInitSegment(e, t, i, r) {
                    this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = vn.createTrack("video"), this._audioTrack = vn.createTrack("audio", r), this._id3Track = vn.createTrack("id3"), this._txtTrack = vn.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = i, this._duration = r
                }
                resetTimeStamp() {}
                resetContiguity() {
                    const {
                        _audioTrack: e,
                        _avcTrack: t,
                        _id3Track: i
                    } = this;
                    e && (e.pesData = null), t && (t.pesData = null), i && (i.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null
                }
                demux(e, t, i = !1, r = !1) {
                    let n;
                    i || (this.sampleAes = null);
                    const s = this._avcTrack,
                        a = this._audioTrack,
                        o = this._id3Track,
                        l = this._txtTrack;
                    let c = s.pid,
                        d = s.pesData,
                        u = a.pid,
                        h = o.pid,
                        f = a.pesData,
                        m = o.pesData,
                        p = null,
                        g = this.pmtParsed,
                        y = this._pmtId,
                        v = e.length;
                    if (this.remainderData && (v = (e = kt(this.remainderData, e)).length, this.remainderData = null), v < yn && !r) return this.remainderData = e, {
                        audioTrack: a,
                        videoTrack: s,
                        id3Track: o,
                        textTrack: l
                    };
                    const b = Math.max(0, vn.syncOffset(e));
                    v -= (v - b) % yn, v < e.byteLength && !r && (this.remainderData = new Uint8Array(e.buffer, v, e.buffer.byteLength - v));
                    let T = 0;
                    for (let t = b; t < v; t += yn)
                        if (71 === e[t]) {
                            const r = !!(64 & e[t + 1]),
                                v = Tn(e, t);
                            let T;
                            if ((48 & e[t + 3]) >> 4 > 1) {
                                if (T = t + 5 + e[t + 4], T === t + yn) continue
                            } else T = t + 4;
                            switch (v) {
                                case c:
                                    r && (d && (n = wn(d)) && this.parseAVCPES(s, l, n, !1), d = {
                                        data: [],
                                        size: 0
                                    }), d && (d.data.push(e.subarray(T, t + yn)), d.size += t + yn - T);
                                    break;
                                case u:
                                    if (r) {
                                        if (f && (n = wn(f))) switch (a.segmentCodec) {
                                            case "aac":
                                                this.parseAACPES(a, n);
                                                break;
                                            case "mp3":
                                                this.parseMPEGPES(a, n)
                                        }
                                        f = {
                                            data: [],
                                            size: 0
                                        }
                                    }
                                    f && (f.data.push(e.subarray(T, t + yn)), f.size += t + yn - T);
                                    break;
                                case h:
                                    r && (m && (n = wn(m)) && this.parseID3PES(o, n), m = {
                                        data: [],
                                        size: 0
                                    }), m && (m.data.push(e.subarray(T, t + yn)), m.size += t + yn - T);
                                    break;
                                case 0:
                                    r && (T += e[T] + 1), y = this._pmtId = En(e, T);
                                    break;
                                case y:
                                    {
                                        r && (T += e[T] + 1);
                                        const n = An(e, T, this.typeSupported, i);c = n.avc,
                                        c > 0 && (s.pid = c),
                                        u = n.audio,
                                        u > 0 && (a.pid = u, a.segmentCodec = n.segmentCodec),
                                        h = n.id3,
                                        h > 0 && (o.pid = h),
                                        null === p || g || (Ee.warn(`MPEG-TS PMT found at ${t} after unknown PID '${p}'. Backtracking to sync byte @${b} to parse all TS packets.`), p = null, t = b - 188),
                                        g = this.pmtParsed = !0;
                                        break
                                    }
                                case 17:
                                case 8191:
                                    break;
                                default:
                                    p = v
                            }
                        } else T++;
                    if (T > 0) {
                        const e = new Error(`Found ${T} TS packet/s that do not start with 0x47`);
                        this.observer.emit(me.ERROR, me.ERROR, {
                            type: pe.MEDIA_ERROR,
                            details: ge.FRAG_PARSING_ERROR,
                            fatal: !1,
                            error: e,
                            reason: e.message
                        })
                    }
                    s.pesData = d, a.pesData = f, o.pesData = m;
                    const E = {
                        audioTrack: a,
                        videoTrack: s,
                        id3Track: o,
                        textTrack: l
                    };
                    return r && this.extractRemainingSamples(E), E
                }
                flush() {
                    const {
                        remainderData: e
                    } = this;
                    let t;
                    return this.remainderData = null, t = e ? this.demux(e, -1, !1, !0) : {
                        videoTrack: this._avcTrack,
                        audioTrack: this._audioTrack,
                        id3Track: this._id3Track,
                        textTrack: this._txtTrack
                    }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t
                }
                extractRemainingSamples(e) {
                    const {
                        audioTrack: t,
                        videoTrack: i,
                        id3Track: r,
                        textTrack: n
                    } = e, s = i.pesData, a = t.pesData, o = r.pesData;
                    let l;
                    if (s && (l = wn(s)) ? (this.parseAVCPES(i, n, l, !0), i.pesData = null) : i.pesData = s, a && (l = wn(a))) {
                        switch (t.segmentCodec) {
                            case "aac":
                                this.parseAACPES(t, l);
                                break;
                            case "mp3":
                                this.parseMPEGPES(t, l)
                        }
                        t.pesData = null
                    } else null != a && a.size && Ee.log("last AAC PES packet truncated,might overlap between fragments"), t.pesData = a;
                    o && (l = wn(o)) ? (this.parseID3PES(r, l), r.pesData = null) : r.pesData = o
                }
                demuxSampleAes(e, t, i) {
                    const r = this.demux(e, i, !0, !this.config.progressive),
                        n = this.sampleAes = new gn(this.observer, this.config, t);
                    return this.decrypt(r, n)
                }
                decrypt(e, t) {
                    return new Promise((i => {
                        const {
                            audioTrack: r,
                            videoTrack: n
                        } = e;
                        r.samples && "aac" === r.segmentCodec ? t.decryptAacSamples(r.samples, 0, (() => {
                            n.samples ? t.decryptAvcSamples(n.samples, 0, 0, (() => {
                                i(e)
                            })) : i(e)
                        })) : n.samples && t.decryptAvcSamples(n.samples, 0, 0, (() => {
                            i(e)
                        }))
                    }))
                }
                destroy() {
                    this._duration = 0
                }
                parseAVCPES(e, t, i, r) {
                    const n = this.parseAVCNALu(e, i.data);
                    let s, a = this.avcSample,
                        o = !1;
                    i.data = null, a && n.length && !e.audFound && (_n(a, e), a = this.avcSample = bn(!1, i.pts, i.dts, "")), n.forEach((r => {
                        var n;
                        switch (r.type) {
                            case 1:
                                {
                                    let t = !1;s = !0;
                                    const n = r.data;
                                    if (o && n.length > 4) {
                                        const e = new pn(n).readSliceType();
                                        2 !== e && 4 !== e && 7 !== e && 9 !== e || (t = !0)
                                    }
                                    var l;
                                    if (t) null != (l = a) && l.frame && !a.key && (_n(a, e), a = this.avcSample = null);a || (a = this.avcSample = bn(!0, i.pts, i.dts, "")),
                                    a.frame = !0,
                                    a.key = t;
                                    break
                                }
                            case 5:
                                s = !0, null != (n = a) && n.frame && !a.key && (_n(a, e), a = this.avcSample = null), a || (a = this.avcSample = bn(!0, i.pts, i.dts, "")), a.key = !0, a.frame = !0;
                                break;
                            case 6:
                                s = !0, Rt(r.data, 1, i.pts, t.samples);
                                break;
                            case 7:
                                if (s = !0, o = !0, !e.sps) {
                                    const t = r.data,
                                        i = new pn(t).readSPS();
                                    e.width = i.width, e.height = i.height, e.pixelRatio = i.pixelRatio, e.sps = [t], e.duration = this._duration;
                                    const n = t.subarray(1, 4);
                                    let s = "avc1.";
                                    for (let e = 0; e < 3; e++) {
                                        let t = n[e].toString(16);
                                        t.length < 2 && (t = "0" + t), s += t
                                    }
                                    e.codec = s
                                }
                                break;
                            case 8:
                                s = !0, e.pps || (e.pps = [r.data]);
                                break;
                            case 9:
                                s = !1, e.audFound = !0, a && _n(a, e), a = this.avcSample = bn(!1, i.pts, i.dts, "");
                                break;
                            case 12:
                                s = !0;
                                break;
                            default:
                                s = !1, a && (a.debug += "unknown NAL " + r.type + " ")
                        }
                        if (a && s) {
                            a.units.push(r)
                        }
                    })), r && a && (_n(a, e), this.avcSample = null)
                }
                getLastNalUnit(e) {
                    var t;
                    let i, r = this.avcSample;
                    if (r && 0 !== r.units.length || (r = e[e.length - 1]), null != (t = r) && t.units) {
                        const e = r.units;
                        i = e[e.length - 1]
                    }
                    return i
                }
                parseAVCNALu(e, t) {
                    const i = t.byteLength;
                    let r = e.naluState || 0;
                    const n = r,
                        s = [];
                    let a, o, l, c = 0,
                        d = -1,
                        u = 0;
                    for (-1 === r && (d = 0, u = 31 & t[0], r = 0, c = 1); c < i;)
                        if (a = t[c++], r)
                            if (1 !== r)
                                if (a)
                                    if (1 === a) {
                                        if (d >= 0) {
                                            const e = {
                                                data: t.subarray(d, c - r - 1),
                                                type: u
                                            };
                                            s.push(e)
                                        } else {
                                            const i = this.getLastNalUnit(e.samples);
                                            if (i && (n && c <= 4 - n && i.state && (i.data = i.data.subarray(0, i.data.byteLength - n)), o = c - r - 1, o > 0)) {
                                                const e = new Uint8Array(i.data.byteLength + o);
                                                e.set(i.data, 0), e.set(t.subarray(0, o), i.data.byteLength), i.data = e, i.state = 0
                                            }
                                        }
                                        c < i ? (l = 31 & t[c], d = c, u = l, r = 0) : r = -1
                                    } else r = 0;
                    else r = 3;
                    else r = a ? 0 : 2;
                    else r = a ? 0 : 1;
                    if (d >= 0 && r >= 0) {
                        const e = {
                            data: t.subarray(d, i),
                            type: u,
                            state: r
                        };
                        s.push(e)
                    }
                    if (0 === s.length) {
                        const i = this.getLastNalUnit(e.samples);
                        if (i) {
                            const e = new Uint8Array(i.data.byteLength + t.byteLength);
                            e.set(i.data, 0), e.set(t, i.data.byteLength), i.data = e
                        }
                    }
                    return e.naluState = r, s
                }
                parseAACPES(e, t) {
                    let i = 0;
                    const r = this.aacOverFlow;
                    let n, s, a, o = t.data;
                    if (r) {
                        this.aacOverFlow = null;
                        const t = r.missing,
                            n = r.sample.unit.byteLength;
                        if (-1 === t) {
                            const e = new Uint8Array(n + o.byteLength);
                            e.set(r.sample.unit, 0), e.set(o, n), o = e
                        } else {
                            const s = n - t;
                            r.sample.unit.set(o.subarray(0, t), s), e.samples.push(r.sample), i = r.missing
                        }
                    }
                    for (n = i, s = o.length; n < s - 1 && !Jr(o, n); n++);
                    if (n !== i) {
                        let e;
                        const t = n < s - 1;
                        e = t ? `AAC PES did not start with ADTS header,offset:${n}` : "No ADTS header found in AAC PES";
                        const i = new Error(e);
                        if (Ee.warn(`parsing error: ${e}`), this.observer.emit(me.ERROR, me.ERROR, {
                                type: pe.MEDIA_ERROR,
                                details: ge.FRAG_PARSING_ERROR,
                                fatal: !1,
                                levelRetry: t,
                                error: i,
                                reason: e
                            }), !t) return
                    }
                    if (en(e, this.observer, o, n, this.audioCodec), void 0 !== t.pts) a = t.pts;
                    else {
                        if (!r) return void Ee.warn("[tsdemuxer]: AAC PES unknown PTS"); {
                            const t = tn(e.samplerate);
                            a = r.sample.pts + t
                        }
                    }
                    let l, c = 0;
                    for (; n < s;) {
                        if (l = rn(e, o, n, a, c), n += l.length, l.missing) {
                            this.aacOverFlow = l;
                            break
                        }
                        for (c++; n < s - 1 && !Jr(o, n); n++);
                    }
                }
                parseMPEGPES(e, t) {
                    const i = t.data,
                        r = i.length;
                    let n = 0,
                        s = 0;
                    const a = t.pts;
                    if (void 0 !== a)
                        for (; s < r;)
                            if (fn(i, s)) {
                                const t = dn(e, i, s, a, n);
                                if (!t) break;
                                s += t.length, n++
                            } else s++;
                    else Ee.warn("[tsdemuxer]: MPEG PES unknown PTS")
                }
                parseID3PES(e, t) {
                    if (void 0 === t.pts) return void Ee.warn("[tsdemuxer]: ID3 PES unknown PTS");
                    const i = de({}, t, {
                        type: this._avcTrack ? vi : gi,
                        duration: Number.POSITIVE_INFINITY
                    });
                    e.samples.push(i)
                }
            }

            function bn(e, t, i, r) {
                return {
                    key: e,
                    frame: !1,
                    pts: t,
                    dts: i,
                    units: [],
                    debug: r,
                    length: 0
                }
            }

            function Tn(e, t) {
                return ((31 & e[t + 1]) << 8) + e[t + 2]
            }

            function En(e, t) {
                return (31 & e[t + 10]) << 8 | e[t + 11]
            }

            function An(e, t, i, r) {
                const n = {
                        audio: -1,
                        avc: -1,
                        id3: -1,
                        segmentCodec: "aac"
                    },
                    s = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;
                for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < s;) {
                    const s = Tn(e, t);
                    switch (e[t]) {
                        case 207:
                            if (!r) {
                                Ee.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                                break
                            }
                        case 15:
                            -1 === n.audio && (n.audio = s);
                            break;
                        case 21:
                            -1 === n.id3 && (n.id3 = s);
                            break;
                        case 219:
                            if (!r) {
                                Ee.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                                break
                            }
                        case 27:
                            -1 === n.avc && (n.avc = s);
                            break;
                        case 3:
                        case 4:
                            !0 !== i.mpeg && !0 !== i.mp3 ? Ee.log("MPEG audio found, not supported in this browser") : -1 === n.audio && (n.audio = s, n.segmentCodec = "mp3");
                            break;
                        case 36:
                            Ee.warn("Unsupported HEVC stream type found")
                    }
                    t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4])
                }
                return n
            }

            function wn(e) {
                let t, i, r, n, s, a = 0;
                const o = e.data;
                if (!e || 0 === e.size) return null;
                for (; o[0].length < 19 && o.length > 1;) {
                    const e = new Uint8Array(o[0].length + o[1].length);
                    e.set(o[0]), e.set(o[1], o[0].length), o[0] = e, o.splice(1, 1)
                }
                t = o[0];
                if (1 === (t[0] << 16) + (t[1] << 8) + t[2]) {
                    if (i = (t[4] << 8) + t[5], i && i > e.size - 6) return null;
                    const l = t[7];
                    192 & l && (n = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2, 64 & l ? (s = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2, n - s > 54e5 && (Ee.warn(`${Math.round((n-s)/9e4)}s delta between PTS and DTS, align them`), n = s)) : s = n), r = t[8];
                    let c = r + 9;
                    if (e.size <= c) return null;
                    e.size -= c;
                    const d = new Uint8Array(e.size);
                    for (let e = 0, i = o.length; e < i; e++) {
                        t = o[e];
                        let i = t.byteLength;
                        if (c) {
                            if (c > i) {
                                c -= i;
                                continue
                            }
                            t = t.subarray(c), i -= c, c = 0
                        }
                        d.set(t, a), a += i
                    }
                    return i && (i -= r + 3), {
                        data: d,
                        pts: n,
                        dts: s,
                        len: i
                    }
                }
                return null
            }

            function _n(e, t) {
                if (e.units.length && e.frame) {
                    if (void 0 === e.pts) {
                        const i = t.samples,
                            r = i.length;
                        if (!r) return void t.dropped++; {
                            const t = i[r - 1];
                            e.pts = t.pts, e.dts = t.dts
                        }
                    }
                    t.samples.push(e)
                }
                e.debug.length && Ee.log(e.pts + "/" + e.dts + ":" + e.debug)
            }
            class kn {
                static getSilentFrame(e, t) {
                    if ("mp4a.40.2" === e) {
                        if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);
                        if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                        if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                        if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                        if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                        if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
                    } else {
                        if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                        if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
                    }
                }
            }
            const Sn = Math.pow(2, 32) - 1;
            class Ln {
                static init() {
                    let e;
                    for (e in Ln.types = {
                            avc1: [],
                            avcC: [],
                            btrt: [],
                            dinf: [],
                            dref: [],
                            esds: [],
                            ftyp: [],
                            hdlr: [],
                            mdat: [],
                            mdhd: [],
                            mdia: [],
                            mfhd: [],
                            minf: [],
                            moof: [],
                            moov: [],
                            mp4a: [],
                            ".mp3": [],
                            mvex: [],
                            mvhd: [],
                            pasp: [],
                            sdtp: [],
                            stbl: [],
                            stco: [],
                            stsc: [],
                            stsd: [],
                            stsz: [],
                            stts: [],
                            tfdt: [],
                            tfhd: [],
                            traf: [],
                            trak: [],
                            trun: [],
                            trex: [],
                            tkhd: [],
                            vmhd: [],
                            smhd: []
                        }, Ln.types) Ln.types.hasOwnProperty(e) && (Ln.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
                    const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                        i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                    Ln.HDLR_TYPES = {
                        video: t,
                        audio: i
                    };
                    const r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
                        n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                    Ln.STTS = Ln.STSC = Ln.STCO = n, Ln.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Ln.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), Ln.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), Ln.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                    const s = new Uint8Array([105, 115, 111, 109]),
                        a = new Uint8Array([97, 118, 99, 49]),
                        o = new Uint8Array([0, 0, 0, 1]);
                    Ln.FTYP = Ln.box(Ln.types.ftyp, s, o, s, a), Ln.DINF = Ln.box(Ln.types.dinf, Ln.box(Ln.types.dref, r))
                }
                static box(e, ...t) {
                    let i = 8,
                        r = t.length;
                    const n = r;
                    for (; r--;) i += t[r].byteLength;
                    const s = new Uint8Array(i);
                    for (s[0] = i >> 24 & 255, s[1] = i >> 16 & 255, s[2] = i >> 8 & 255, s[3] = 255 & i, s.set(e, 4), r = 0, i = 8; r < n; r++) s.set(t[r], i), i += t[r].byteLength;
                    return s
                }
                static hdlr(e) {
                    return Ln.box(Ln.types.hdlr, Ln.HDLR_TYPES[e])
                }
                static mdat(e) {
                    return Ln.box(Ln.types.mdat, e)
                }
                static mdhd(e, t) {
                    t *= e;
                    const i = Math.floor(t / (Sn + 1)),
                        r = Math.floor(t % (Sn + 1));
                    return Ln.box(Ln.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 85, 196, 0, 0]))
                }
                static mdia(e) {
                    return Ln.box(Ln.types.mdia, Ln.mdhd(e.timescale, e.duration), Ln.hdlr(e.type), Ln.minf(e))
                }
                static mfhd(e) {
                    return Ln.box(Ln.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]))
                }
                static minf(e) {
                    return "audio" === e.type ? Ln.box(Ln.types.minf, Ln.box(Ln.types.smhd, Ln.SMHD), Ln.DINF, Ln.stbl(e)) : Ln.box(Ln.types.minf, Ln.box(Ln.types.vmhd, Ln.VMHD), Ln.DINF, Ln.stbl(e))
                }
                static moof(e, t, i) {
                    return Ln.box(Ln.types.moof, Ln.mfhd(e), Ln.traf(i, t))
                }
                static moov(e) {
                    let t = e.length;
                    const i = [];
                    for (; t--;) i[t] = Ln.trak(e[t]);
                    return Ln.box.apply(null, [Ln.types.moov, Ln.mvhd(e[0].timescale, e[0].duration)].concat(i).concat(Ln.mvex(e)))
                }
                static mvex(e) {
                    let t = e.length;
                    const i = [];
                    for (; t--;) i[t] = Ln.trex(e[t]);
                    return Ln.box.apply(null, [Ln.types.mvex, ...i])
                }
                static mvhd(e, t) {
                    t *= e;
                    const i = Math.floor(t / (Sn + 1)),
                        r = Math.floor(t % (Sn + 1)),
                        n = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                    return Ln.box(Ln.types.mvhd, n)
                }
                static sdtp(e) {
                    const t = e.samples || [],
                        i = new Uint8Array(4 + t.length);
                    let r, n;
                    for (r = 0; r < t.length; r++) n = t[r].flags, i[r + 4] = n.dependsOn << 4 | n.isDependedOn << 2 | n.hasRedundancy;
                    return Ln.box(Ln.types.sdtp, i)
                }
                static stbl(e) {
                    return Ln.box(Ln.types.stbl, Ln.stsd(e), Ln.box(Ln.types.stts, Ln.STTS), Ln.box(Ln.types.stsc, Ln.STSC), Ln.box(Ln.types.stsz, Ln.STSZ), Ln.box(Ln.types.stco, Ln.STCO))
                }
                static avc1(e) {
                    let t, i, r, n = [],
                        s = [];
                    for (t = 0; t < e.sps.length; t++) i = e.sps[t], r = i.byteLength, n.push(r >>> 8 & 255), n.push(255 & r), n = n.concat(Array.prototype.slice.call(i));
                    for (t = 0; t < e.pps.length; t++) i = e.pps[t], r = i.byteLength, s.push(r >>> 8 & 255), s.push(255 & r), s = s.concat(Array.prototype.slice.call(i));
                    const a = Ln.box(Ln.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | e.sps.length].concat(n).concat([e.pps.length]).concat(s))),
                        o = e.width,
                        l = e.height,
                        c = e.pixelRatio[0],
                        d = e.pixelRatio[1];
                    return Ln.box(Ln.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), a, Ln.box(Ln.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), Ln.box(Ln.types.pasp, new Uint8Array([c >> 24, c >> 16 & 255, c >> 8 & 255, 255 & c, d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d])))
                }
                static esds(e) {
                    const t = e.config.length;
                    return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]))
                }
                static mp4a(e) {
                    const t = e.samplerate;
                    return Ln.box(Ln.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]), Ln.box(Ln.types.esds, Ln.esds(e)))
                }
                static mp3(e) {
                    const t = e.samplerate;
                    return Ln.box(Ln.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]))
                }
                static stsd(e) {
                    return "audio" === e.type ? "mp3" === e.segmentCodec && "mp3" === e.codec ? Ln.box(Ln.types.stsd, Ln.STSD, Ln.mp3(e)) : Ln.box(Ln.types.stsd, Ln.STSD, Ln.mp4a(e)) : Ln.box(Ln.types.stsd, Ln.STSD, Ln.avc1(e))
                }
                static tkhd(e) {
                    const t = e.id,
                        i = e.duration * e.timescale,
                        r = e.width,
                        n = e.height,
                        s = Math.floor(i / (Sn + 1)),
                        a = Math.floor(i % (Sn + 1));
                    return Ln.box(Ln.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0, n >> 8 & 255, 255 & n, 0, 0]))
                }
                static traf(e, t) {
                    const i = Ln.sdtp(e),
                        r = e.id,
                        n = Math.floor(t / (Sn + 1)),
                        s = Math.floor(t % (Sn + 1));
                    return Ln.box(Ln.types.traf, Ln.box(Ln.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r])), Ln.box(Ln.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), Ln.trun(e, i.length + 16 + 20 + 8 + 16 + 8 + 8), i)
                }
                static trak(e) {
                    return e.duration = e.duration || 4294967295, Ln.box(Ln.types.trak, Ln.tkhd(e), Ln.mdia(e))
                }
                static trex(e) {
                    const t = e.id;
                    return Ln.box(Ln.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
                }
                static trun(e, t) {
                    const i = e.samples || [],
                        r = i.length,
                        n = 12 + 16 * r,
                        s = new Uint8Array(n);
                    let a, o, l, c, d, u;
                    for (t += 8 + n, s.set(["video" === e.type ? 1 : 0, 0, 15, 1, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t], 0), a = 0; a < r; a++) o = i[a], l = o.duration, c = o.size, d = o.flags, u = o.cts, s.set([l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, 255 & c, d.isLeading << 2 | d.dependsOn, d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync, 61440 & d.degradPrio, 15 & d.degradPrio, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u], 12 + 16 * a);
                    return Ln.box(Ln.types.trun, s)
                }
                static initSegment(e) {
                    Ln.types || Ln.init();
                    const t = Ln.moov(e),
                        i = new Uint8Array(Ln.FTYP.byteLength + t.byteLength);
                    return i.set(Ln.FTYP), i.set(t, Ln.FTYP.byteLength), i
                }
            }
            Ln.types = void 0, Ln.HDLR_TYPES = void 0, Ln.STTS = void 0, Ln.STSC = void 0, Ln.STCO = void 0, Ln.STSZ = void 0, Ln.VMHD = void 0, Ln.SMHD = void 0, Ln.STSD = void 0, Ln.FTYP = void 0, Ln.DINF = void 0;
            const Rn = 9e4;

            function Dn(e, t, i = 1, r = !1) {
                const n = e * t * i;
                return r ? Math.round(n) : n
            }

            function Cn(e, t = !1) {
                return Dn(e, 1e3, 1 / Rn, t)
            }
            let In, Pn = null,
                xn = null;
            class On {
                constructor(e, t, i, r = "") {
                    if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = e, this.config = t, this.typeSupported = i, this.ISGenerated = !1, null === Pn) {
                        const e = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
                        Pn = e ? parseInt(e[1]) : 0
                    }
                    if (null === xn) {
                        const e = navigator.userAgent.match(/Safari\/(\d+)/i);
                        xn = e ? parseInt(e[1]) : 0
                    }
                }
                destroy() {}
                resetTimeStamp(e) {
                    Ee.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = e
                }
                resetNextTimestamp() {
                    Ee.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
                }
                resetInitSegment() {
                    Ee.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1
                }
                getVideoStartPts(e) {
                    let t = !1;
                    const i = e.reduce(((e, i) => {
                        const r = i.pts - e;
                        return r < -4294967296 ? (t = !0, Mn(e, i.pts)) : r > 0 ? e : i.pts
                    }), e[0].pts);
                    return t && Ee.debug("PTS rollover detected"), i
                }
                remux(e, t, i, r, n, s, a, o) {
                    let l, c, d, u, h, f, m = n,
                        p = n;
                    const g = e.pid > -1,
                        y = t.pid > -1,
                        v = t.samples.length,
                        b = e.samples.length > 0,
                        T = a && v > 0 || v > 1;
                    if ((!g || b) && (!y || T) || this.ISGenerated || a) {
                        this.ISGenerated || (d = this.generateIS(e, t, n, s));
                        const i = this.isVideoContiguous;
                        let r, a = -1;
                        if (T && (a = function(e) {
                                for (let t = 0; t < e.length; t++)
                                    if (e[t].key) return t;
                                return -1
                            }(t.samples), !i && this.config.forceKeyFrameOnDiscontinuity))
                            if (f = !0, a > 0) {
                                Ee.warn(`[mp4-remuxer]: Dropped ${a} out of ${v} video samples due to a missing keyframe`);
                                const e = this.getVideoStartPts(t.samples);
                                t.samples = t.samples.slice(a), t.dropped += a, p += (t.samples[0].pts - e) / t.inputTimeScale, r = p
                            } else -1 === a && (Ee.warn(`[mp4-remuxer]: No keyframe found out of ${v} video samples`), f = !1);
                        if (this.ISGenerated) {
                            if (b && T) {
                                const i = this.getVideoStartPts(t.samples),
                                    r = (Mn(e.samples[0].pts, i) - i) / t.inputTimeScale;
                                m += Math.max(0, r), p += Math.max(0, -r)
                            }
                            if (b) {
                                if (e.samplerate || (Ee.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), d = this.generateIS(e, t, n, s)), c = this.remuxAudio(e, m, this.isAudioContiguous, s, y || T || o === oi ? p : void 0), T) {
                                    const r = c ? c.endPTS - c.startPTS : 0;
                                    t.inputTimeScale || (Ee.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), d = this.generateIS(e, t, n, s)), l = this.remuxVideo(t, p, i, r)
                                }
                            } else T && (l = this.remuxVideo(t, p, i, 0));
                            l && (l.firstKeyFrame = a, l.independent = -1 !== a, l.firstKeyFramePTS = r)
                        }
                    }
                    return this.ISGenerated && this._initPTS && this._initDTS && (i.samples.length && (h = Nn(i, n, this._initPTS, this._initDTS)), r.samples.length && (u = Fn(r, n, this._initPTS))), {
                        audio: c,
                        video: l,
                        initSegment: d,
                        independent: f,
                        text: u,
                        id3: h
                    }
                }
                generateIS(e, t, i, r) {
                    const n = e.samples,
                        s = t.samples,
                        a = this.typeSupported,
                        o = {},
                        l = this._initPTS;
                    let c, d, u, h = !l || r,
                        f = "audio/mp4";
                    if (h && (c = d = 1 / 0), e.config && n.length) {
                        if (e.timescale = e.samplerate, "mp3" === e.segmentCodec) a.mpeg ? (f = "audio/mpeg", e.codec = "") : a.mp3 && (e.codec = "mp3");
                        o.audio = {
                            id: "audio",
                            container: f,
                            codec: e.codec,
                            initSegment: "mp3" === e.segmentCodec && a.mpeg ? new Uint8Array(0) : Ln.initSegment([e]),
                            metadata: {
                                channelCount: e.channelCount
                            }
                        }, h && (u = e.inputTimeScale, l && u === l.timescale ? h = !1 : c = d = n[0].pts - Math.round(u * i))
                    }
                    if (t.sps && t.pps && s.length && (t.timescale = t.inputTimeScale, o.video = {
                            id: "main",
                            container: "video/mp4",
                            codec: t.codec,
                            initSegment: Ln.initSegment([t]),
                            metadata: {
                                width: t.width,
                                height: t.height
                            }
                        }, h))
                        if (u = t.inputTimeScale, l && u === l.timescale) h = !1;
                        else {
                            const e = this.getVideoStartPts(s),
                                t = Math.round(u * i);
                            d = Math.min(d, Mn(s[0].dts, e) - t), c = Math.min(c, e - t)
                        }
                    if (Object.keys(o).length) return this.ISGenerated = !0, h ? (this._initPTS = {
                        baseTime: c,
                        timescale: u
                    }, this._initDTS = {
                        baseTime: d,
                        timescale: u
                    }) : c = u = void 0, {
                        tracks: o,
                        initPTS: c,
                        timescale: u
                    }
                }
                remuxVideo(e, t, i, r) {
                    const n = e.inputTimeScale,
                        s = e.samples,
                        a = [],
                        o = s.length,
                        l = this._initPTS;
                    let c, d, u = this.nextAvcDts,
                        h = 8,
                        f = this.videoSampleDuration,
                        m = Number.POSITIVE_INFINITY,
                        p = Number.NEGATIVE_INFINITY,
                        g = !1;
                    if (!i || null === u) {
                        u = t * n - (s[0].pts - Mn(s[0].dts, s[0].pts))
                    }
                    const y = l.baseTime * n / l.timescale;
                    for (let e = 0; e < o; e++) {
                        const t = s[e];
                        t.pts = Mn(t.pts - y, u), t.dts = Mn(t.dts - y, u), t.dts < s[e > 0 ? e - 1 : e].dts && (g = !0)
                    }
                    g && s.sort((function(e, t) {
                        const i = e.dts - t.dts,
                            r = e.pts - t.pts;
                        return i || r
                    })), c = s[0].dts, d = s[s.length - 1].dts;
                    const v = d - c,
                        b = v ? Math.round(v / (o - 1)) : f || e.inputTimeScale / 30;
                    if (i) {
                        const e = c - u,
                            t = e > b,
                            i = e < -1;
                        if ((t || i) && (t ? Ee.warn(`AVC: ${Cn(e,!0)} ms (${e}dts) hole between fragments detected, filling it`) : Ee.warn(`AVC: ${Cn(-e,!0)} ms (${e}dts) overlapping between fragments detected`), !i || u >= s[0].pts)) {
                            c = u;
                            const t = s[0].pts - e;
                            s[0].dts = c, s[0].pts = t, Ee.log(`Video: First PTS/DTS adjusted: ${Cn(t,!0)}/${Cn(c,!0)}, delta: ${Cn(e,!0)} ms`)
                        }
                    }
                    c = Math.max(0, c);
                    let T = 0,
                        E = 0;
                    for (let e = 0; e < o; e++) {
                        const t = s[e],
                            i = t.units,
                            r = i.length;
                        let n = 0;
                        for (let e = 0; e < r; e++) n += i[e].data.length;
                        E += n, T += r, t.length = n, t.dts = Math.max(t.dts, c), m = Math.min(t.pts, m), p = Math.max(t.pts, p)
                    }
                    d = s[o - 1].dts;
                    const A = E + 4 * T + 8;
                    let w;
                    try {
                        w = new Uint8Array(A)
                    } catch (e) {
                        return void this.observer.emit(me.ERROR, me.ERROR, {
                            type: pe.MUX_ERROR,
                            details: ge.REMUX_ALLOC_ERROR,
                            fatal: !1,
                            error: e,
                            bytes: A,
                            reason: `fail allocating video mdat ${A}`
                        })
                    }
                    const _ = new DataView(w.buffer);
                    _.setUint32(0, A), w.set(Ln.types.mdat, 4);
                    let k = !1,
                        S = Number.POSITIVE_INFINITY,
                        L = Number.POSITIVE_INFINITY,
                        R = Number.NEGATIVE_INFINITY,
                        D = Number.NEGATIVE_INFINITY;
                    for (let e = 0; e < o; e++) {
                        const t = s[e],
                            i = t.units;
                        let l, c = 0;
                        for (let e = 0, t = i.length; e < t; e++) {
                            const t = i[e],
                                r = t.data,
                                n = t.data.byteLength;
                            _.setUint32(h, n), h += 4, w.set(r, h), h += n, c += 4 + n
                        }
                        if (e < o - 1) f = s[e + 1].dts - t.dts, l = s[e + 1].pts - t.pts;
                        else {
                            const i = this.config,
                                a = e > 0 ? t.dts - s[e - 1].dts : b;
                            if (l = e > 0 ? t.pts - s[e - 1].pts : b, i.stretchShortVideoTrack && null !== this.nextAudioPts) {
                                const e = Math.floor(i.maxBufferHole * n),
                                    s = (r ? m + r * n : this.nextAudioPts) - t.pts;
                                s > e ? (f = s - a, f < 0 ? f = a : k = !0, Ee.log(`[mp4-remuxer]: It is approximately ${s/90} ms to the next segment; using duration ${f/90} ms for the last video frame.`)) : f = a
                            } else f = a
                        }
                        const d = Math.round(t.pts - t.dts);
                        S = Math.min(S, f), R = Math.max(R, f), L = Math.min(L, l), D = Math.max(D, l), a.push(new Bn(t.key, f, c, d))
                    }
                    if (a.length)
                        if (Pn) {
                            if (Pn < 70) {
                                const e = a[0].flags;
                                e.dependsOn = 2, e.isNonSync = 0
                            }
                        } else if (xn && D - L < R - S && b / R < .025 && 0 === a[0].cts) {
                        Ee.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                        let e = c;
                        for (let t = 0, i = a.length; t < i; t++) {
                            const r = e + a[t].duration,
                                n = e + a[t].cts;
                            if (t < i - 1) {
                                const e = r + a[t + 1].cts;
                                a[t].duration = e - n
                            } else a[t].duration = t ? a[t - 1].duration : b;
                            a[t].cts = 0, e = r
                        }
                    }
                    f = k || !f ? b : f, this.nextAvcDts = u = d + f, this.videoSampleDuration = f, this.isVideoContiguous = !0;
                    const C = {
                        data1: Ln.moof(e.sequenceNumber++, c, de({}, e, {
                            samples: a
                        })),
                        data2: w,
                        startPTS: m / n,
                        endPTS: (p + f) / n,
                        startDTS: c / n,
                        endDTS: u / n,
                        type: "video",
                        hasAudio: !1,
                        hasVideo: !0,
                        nb: a.length,
                        dropped: e.dropped
                    };
                    return e.samples = [], e.dropped = 0, C
                }
                remuxAudio(e, t, i, r, n) {
                    const s = e.inputTimeScale,
                        a = s / (e.samplerate ? e.samplerate : s),
                        o = "aac" === e.segmentCodec ? 1024 : 1152,
                        l = o * a,
                        c = this._initPTS,
                        d = "mp3" === e.segmentCodec && this.typeSupported.mpeg,
                        u = [],
                        h = void 0 !== n;
                    let f = e.samples,
                        m = d ? 0 : 8,
                        p = this.nextAudioPts || -1;
                    const g = t * s,
                        y = c.baseTime * s / c.timescale;
                    if (this.isAudioContiguous = i = i || f.length && p > 0 && (r && Math.abs(g - p) < 9e3 || Math.abs(Mn(f[0].pts - y, g) - p) < 20 * l), f.forEach((function(e) {
                            e.pts = Mn(e.pts - y, g)
                        })), !i || p < 0) {
                        if (f = f.filter((e => e.pts >= 0)), !f.length) return;
                        p = 0 === n ? 0 : r && !h ? Math.max(0, g) : f[0].pts
                    }
                    if ("aac" === e.segmentCodec) {
                        const t = this.config.maxAudioFramesDrift;
                        for (let i = 0, r = p; i < f.length; i++) {
                            const n = f[i],
                                a = n.pts,
                                o = a - r,
                                c = Math.abs(1e3 * o / s);
                            if (o <= -t * l && h) 0 === i && (Ee.warn(`Audio frame @ ${(a/s).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3*o/s)} ms.`), this.nextAudioPts = p = r = a);
                            else if (o >= t * l && c < 1e4 && h) {
                                let t = Math.round(o / l);
                                r = a - t * l, r < 0 && (t--, r += l), 0 === i && (this.nextAudioPts = p = r), Ee.warn(`[mp4-remuxer]: Injecting ${t} audio frame @ ${(r/s).toFixed(3)}s due to ${Math.round(1e3*o/s)} ms gap.`);
                                for (let s = 0; s < t; s++) {
                                    const t = Math.max(r, 0);
                                    let s = kn.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                                    s || (Ee.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), s = n.unit.subarray()), f.splice(i, 0, {
                                        unit: s,
                                        pts: t
                                    }), r += l, i++
                                }
                            }
                            n.pts = r, r += l
                        }
                    }
                    let v, b = null,
                        T = null,
                        E = 0,
                        A = f.length;
                    for (; A--;) E += f[A].unit.byteLength;
                    for (let t = 0, r = f.length; t < r; t++) {
                        const r = f[t],
                            n = r.unit;
                        let s = r.pts;
                        if (null !== T) {
                            u[t - 1].duration = Math.round((s - T) / a)
                        } else {
                            if (i && "aac" === e.segmentCodec && (s = p), b = s, !(E > 0)) return;
                            E += m;
                            try {
                                v = new Uint8Array(E)
                            } catch (e) {
                                return void this.observer.emit(me.ERROR, me.ERROR, {
                                    type: pe.MUX_ERROR,
                                    details: ge.REMUX_ALLOC_ERROR,
                                    fatal: !1,
                                    error: e,
                                    bytes: E,
                                    reason: `fail allocating audio mdat ${E}`
                                })
                            }
                            if (!d) {
                                new DataView(v.buffer).setUint32(0, E), v.set(Ln.types.mdat, 4)
                            }
                        }
                        v.set(n, m);
                        const l = n.byteLength;
                        m += l, u.push(new Bn(!0, o, l, 0)), T = s
                    }
                    const w = u.length;
                    if (!w) return;
                    const _ = u[u.length - 1];
                    this.nextAudioPts = p = T + a * _.duration;
                    const k = d ? new Uint8Array(0) : Ln.moof(e.sequenceNumber++, b / a, de({}, e, {
                        samples: u
                    }));
                    e.samples = [];
                    const S = b / s,
                        L = p / s,
                        R = {
                            data1: k,
                            data2: v,
                            startPTS: S,
                            endPTS: L,
                            startDTS: S,
                            endDTS: L,
                            type: "audio",
                            hasAudio: !0,
                            hasVideo: !1,
                            nb: w
                        };
                    return this.isAudioContiguous = !0, R
                }
                remuxEmptyAudio(e, t, i, r) {
                    const n = e.inputTimeScale,
                        s = n / (e.samplerate ? e.samplerate : n),
                        a = this.nextAudioPts,
                        o = this._initDTS,
                        l = 9e4 * o.baseTime / o.timescale,
                        c = (null !== a ? a : r.startDTS * n) + l,
                        d = r.endDTS * n + l,
                        u = 1024 * s,
                        h = Math.ceil((d - c) / u),
                        f = kn.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);
                    if (Ee.warn("[mp4-remuxer]: remux empty Audio"), !f) return void Ee.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
                    const m = [];
                    for (let e = 0; e < h; e++) {
                        const t = c + e * u;
                        m.push({
                            unit: f,
                            pts: t,
                            dts: t
                        })
                    }
                    return e.samples = m, this.remuxAudio(e, t, i, !1)
                }
            }

            function Mn(e, t) {
                let i;
                if (null === t) return e;
                for (i = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) e += i;
                return e
            }

            function Nn(e, t, i, r) {
                const n = e.samples.length;
                if (!n) return;
                const s = e.inputTimeScale;
                for (let a = 0; a < n; a++) {
                    const n = e.samples[a];
                    n.pts = Mn(n.pts - i.baseTime * s / i.timescale, t * s) / s, n.dts = Mn(n.dts - r.baseTime * s / r.timescale, t * s) / s
                }
                const a = e.samples;
                return e.samples = [], {
                    samples: a
                }
            }

            function Fn(e, t, i) {
                const r = e.samples.length;
                if (!r) return;
                const n = e.inputTimeScale;
                for (let s = 0; s < r; s++) {
                    const r = e.samples[s];
                    r.pts = Mn(r.pts - i.baseTime * n / i.timescale, t * n) / n
                }
                e.samples.sort(((e, t) => e.pts - t.pts));
                const s = e.samples;
                return e.samples = [], {
                    samples: s
                }
            }
            class Bn {
                constructor(e, t, i, r) {
                    this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = i, this.cts = r, this.flags = new Un(e)
                }
            }
            class Un {
                constructor(e) {
                    this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = e ? 2 : 1, this.isNonSync = e ? 0 : 1
                }
            }

            function $n(e, t) {
                const i = null == e ? void 0 : e.codec;
                return i && i.length > 4 ? i : "hvc1" === i || "hev1" === i ? "hvc1.1.6.L120.90" : "av01" === i ? "av01.0.04M.08" : "avc1" === i || t === De ? "avc1.42e01e" : "mp4a.40.5"
            }
            try {
                In = self.performance.now.bind(self.performance)
            } catch (e) {
                Ee.debug("Unable to use Performance API on this environment"), In = "undefined" != typeof self && self.Date.now
            }
            const Hn = [{
                demux: class {
                    constructor(e, t) {
                        this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t
                    }
                    resetTimeStamp() {}
                    resetInitSegment(e, t, i, r) {
                        const n = this.videoTrack = Kr("video", 1),
                            s = this.audioTrack = Kr("audio", 1),
                            a = this.txtTrack = Kr("text", 1);
                        if (this.id3Track = Kr("id3", 1), this.timeOffset = 0, null == e || !e.byteLength) return;
                        const o = At(e);
                        if (o.video) {
                            const {
                                id: e,
                                timescale: t,
                                codec: i
                            } = o.video;
                            n.id = e, n.timescale = a.timescale = t, n.codec = i
                        }
                        if (o.audio) {
                            const {
                                id: e,
                                timescale: t,
                                codec: i
                            } = o.audio;
                            s.id = e, s.timescale = t, s.codec = i
                        }
                        a.id = mt.text, n.sampleDuration = 0, n.duration = s.duration = r
                    }
                    resetContiguity() {
                        this.remainderData = null
                    }
                    static probe(e) {
                        return Tt(e = e.length > 16384 ? e.subarray(0, 16384) : e, ["moof"]).length > 0
                    }
                    demux(e, t) {
                        this.timeOffset = t;
                        let i = e;
                        const r = this.videoTrack,
                            n = this.txtTrack;
                        if (this.config.progressive) {
                            this.remainderData && (i = kt(this.remainderData, e));
                            const t = function(e) {
                                const t = {
                                        valid: null,
                                        remainder: null
                                    },
                                    i = Tt(e, ["moof"]);
                                if (!i) return t;
                                if (i.length < 2) return t.remainder = e, t;
                                const r = i[i.length - 1];
                                return t.valid = Ye(e, 0, r.byteOffset - 8), t.remainder = Ye(e, r.byteOffset - 8), t
                            }(i);
                            this.remainderData = t.remainder, r.samples = t.valid || new Uint8Array
                        } else r.samples = i;
                        const s = this.extractID3Track(r, t);
                        return n.samples = St(t, r), {
                            videoTrack: r,
                            audioTrack: this.audioTrack,
                            id3Track: s,
                            textTrack: this.txtTrack
                        }
                    }
                    flush() {
                        const e = this.timeOffset,
                            t = this.videoTrack,
                            i = this.txtTrack;
                        t.samples = this.remainderData || new Uint8Array, this.remainderData = null;
                        const r = this.extractID3Track(t, this.timeOffset);
                        return i.samples = St(e, t), {
                            videoTrack: t,
                            audioTrack: Kr(),
                            id3Track: r,
                            textTrack: Kr()
                        }
                    }
                    extractID3Track(e, t) {
                        const i = this.id3Track;
                        if (e.samples.length) {
                            const r = Tt(e.samples, ["emsg"]);
                            r && r.forEach((e => {
                                const r = function(e) {
                                    const t = e[0];
                                    let i = "",
                                        r = "",
                                        n = 0,
                                        s = 0,
                                        a = 0,
                                        o = 0,
                                        l = 0,
                                        c = 0;
                                    if (0 === t) {
                                        for (;
                                            "\0" !== pt(e.subarray(c, c + 1));) i += pt(e.subarray(c, c + 1)), c += 1;
                                        for (i += pt(e.subarray(c, c + 1)), c += 1;
                                            "\0" !== pt(e.subarray(c, c + 1));) r += pt(e.subarray(c, c + 1)), c += 1;
                                        r += pt(e.subarray(c, c + 1)), c += 1, n = yt(e, 12), s = yt(e, 16), o = yt(e, 20), l = yt(e, 24), c = 28
                                    } else if (1 === t) {
                                        c += 4, n = yt(e, c), c += 4;
                                        const t = yt(e, c);
                                        c += 4;
                                        const s = yt(e, c);
                                        for (c += 4, a = 2 ** 32 * t + s, he(a) || (a = Number.MAX_SAFE_INTEGER, Ee.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = yt(e, c), c += 4, l = yt(e, c), c += 4;
                                            "\0" !== pt(e.subarray(c, c + 1));) i += pt(e.subarray(c, c + 1)), c += 1;
                                        for (i += pt(e.subarray(c, c + 1)), c += 1;
                                            "\0" !== pt(e.subarray(c, c + 1));) r += pt(e.subarray(c, c + 1)), c += 1;
                                        r += pt(e.subarray(c, c + 1)), c += 1
                                    }
                                    return {
                                        schemeIdUri: i,
                                        value: r,
                                        timeScale: n,
                                        presentationTime: a,
                                        presentationTimeDelta: s,
                                        eventDuration: o,
                                        id: l,
                                        payload: e.subarray(c, e.byteLength)
                                    }
                                }(e);
                                if (nn.test(r.schemeIdUri)) {
                                    const e = ue(r.presentationTime) ? r.presentationTime / r.timeScale : t + r.presentationTimeDelta / r.timeScale;
                                    let n = 4294967295 === r.eventDuration ? Number.POSITIVE_INFINITY : r.eventDuration / r.timeScale;
                                    n <= .001 && (n = Number.POSITIVE_INFINITY);
                                    const s = r.payload;
                                    i.samples.push({
                                        data: s,
                                        len: s.byteLength,
                                        dts: e,
                                        pts: e,
                                        type: vi,
                                        duration: n
                                    })
                                }
                            }))
                        }
                        return i
                    }
                    demuxSampleAes(e, t, i) {
                        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
                    }
                    destroy() {}
                },
                remux: class {
                    constructor() {
                        this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null
                    }
                    destroy() {}
                    resetTimeStamp(e) {
                        this.initPTS = e, this.lastEndTime = null
                    }
                    resetNextTimestamp() {
                        this.lastEndTime = null
                    }
                    resetInitSegment(e, t, i, r) {
                        this.audioCodec = t, this.videoCodec = i, this.generateInitSegment(function(e, t) {
                            if (!e || !t) return e;
                            const i = t.keyId;
                            i && t.isCommonEncryption && Tt(e, ["moov", "trak"]).forEach((e => {
                                const t = Tt(e, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
                                let r = Tt(t, ["enca"]);
                                const n = r.length > 0;
                                n || (r = Tt(t, ["encv"])), r.forEach((e => {
                                    Tt(n ? e.subarray(28) : e.subarray(78), ["sinf"]).forEach((e => {
                                        const t = wt(e);
                                        if (t) {
                                            const e = t.subarray(8, 24);
                                            e.some((e => 0 !== e)) || (Ee.log(`[eme] Patching keyId in 'enc${n?"a":"v"}>sinf>>tenc' box: ${ut(e)} -> ${ut(i)}`), t.set(i, 8))
                                        }
                                    }))
                                }))
                            }));
                            return e
                        }(e, r)), this.emitInitSegment = !0
                    }
                    generateInitSegment(e) {
                        let {
                            audioCodec: t,
                            videoCodec: i
                        } = this;
                        if (null == e || !e.byteLength) return this.initTracks = void 0, void(this.initData = void 0);
                        const r = this.initData = At(e);
                        t || (t = $n(r.audio, Re)), i || (i = $n(r.video, De));
                        const n = {};
                        r.audio && r.video ? n.audiovideo = {
                            container: "video/mp4",
                            codec: t + "," + i,
                            initSegment: e,
                            id: "main"
                        } : r.audio ? n.audio = {
                            container: "audio/mp4",
                            codec: t,
                            initSegment: e,
                            id: "audio"
                        } : r.video ? n.video = {
                            container: "video/mp4",
                            codec: i,
                            initSegment: e,
                            id: "main"
                        } : Ee.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = n
                    }
                    remux(e, t, i, r, n, s) {
                        var a, o;
                        let {
                            initPTS: l,
                            lastEndTime: c
                        } = this;
                        const d = {
                            audio: void 0,
                            video: void 0,
                            text: r,
                            id3: i,
                            initSegment: void 0
                        };
                        ue(c) || (c = this.lastEndTime = n || 0);
                        const u = t.samples;
                        if (null == u || !u.length) return d;
                        const h = {
                            initPTS: void 0,
                            timescale: 1
                        };
                        let f = this.initData;
                        if (null != (a = f) && a.length || (this.generateInitSegment(u), f = this.initData), null == (o = f) || !o.length) return Ee.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), d;
                        this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1);
                        const m = function(e, t) {
                                let i = 0,
                                    r = 0,
                                    n = 0;
                                const s = Tt(e, ["moof", "traf"]);
                                for (let e = 0; e < s.length; e++) {
                                    const a = s[e],
                                        o = Tt(a, ["tfhd"])[0],
                                        l = t[yt(o, 4)];
                                    if (!l) continue;
                                    const c = l.default,
                                        d = yt(o, 0) | (null == c ? void 0 : c.flags);
                                    let u = null == c ? void 0 : c.duration;
                                    8 & d && (u = yt(o, 2 & d ? 12 : 8));
                                    const h = l.timescale || 9e4,
                                        f = Tt(a, ["trun"]);
                                    for (let e = 0; e < f.length; e++) i = _t(f[e]), !i && u && (i = u * yt(f[e], 4)), l.type === De ? r += i / h : l.type === Re && (n += i / h)
                                }
                                if (0 === r && 0 === n) {
                                    let t = 0;
                                    const i = Tt(e, ["sidx"]);
                                    for (let e = 0; e < i.length; e++) {
                                        const r = Et(i[e]);
                                        null != r && r.references && (t += r.references.reduce(((e, t) => e + t.info.duration || 0), 0))
                                    }
                                    return t
                                }
                                return r || n
                            }(u, f),
                            p = function(e, t) {
                                return Tt(t, ["moof", "traf"]).reduce(((t, i) => {
                                    const r = Tt(i, ["tfdt"])[0],
                                        n = r[0],
                                        s = Tt(i, ["tfhd"]).reduce(((t, i) => {
                                            const s = yt(i, 4),
                                                a = e[s];
                                            if (a) {
                                                let e = yt(r, 4);
                                                if (1 === n) {
                                                    if (e === ht) return Ee.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time"), t;
                                                    e *= ht + 1, e += yt(r, 8)
                                                }
                                                const i = e / (a.timescale || 9e4);
                                                if (ue(i) && (null === t || i < t)) return i
                                            }
                                            return t
                                        }), null);
                                    return null !== s && ue(s) && (null === t || s < t) ? s : t
                                }), null)
                            }(f, u),
                            g = null === p ? n : p;
                        (function(e, t, i, r) {
                            if (null === e) return !0;
                            const n = Math.max(r, 1),
                                s = t - e.baseTime / e.timescale;
                            return Math.abs(s - i) > n
                        }(l, g, n, m) || h.timescale !== l.timescale && s) && (h.initPTS = g - n, l && 1 === l.timescale && Ee.warn("Adjusting initPTS by " + (h.initPTS - l.baseTime)), this.initPTS = l = {
                            baseTime: h.initPTS,
                            timescale: 1
                        });
                        const y = e ? g - l.baseTime / l.timescale : c,
                            v = y + m;
                        ! function(e, t, i) {
                            Tt(t, ["moof", "traf"]).forEach((t => {
                                Tt(t, ["tfhd"]).forEach((r => {
                                    const n = yt(r, 4),
                                        s = e[n];
                                    if (!s) return;
                                    const a = s.timescale || 9e4;
                                    Tt(t, ["tfdt"]).forEach((e => {
                                        const t = e[0];
                                        let r = yt(e, 4);
                                        if (0 === t) r -= i * a, r = Math.max(r, 0), bt(e, 4, r);
                                        else {
                                            r *= Math.pow(2, 32), r += yt(e, 8), r -= i * a, r = Math.max(r, 0);
                                            const t = Math.floor(r / (ht + 1)),
                                                n = Math.floor(r % (ht + 1));
                                            bt(e, 4, t), bt(e, 8, n)
                                        }
                                    }))
                                }))
                            }))
                        }(f, u, l.baseTime / l.timescale), m > 0 ? this.lastEndTime = v : (Ee.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
                        const b = !!f.audio,
                            T = !!f.video;
                        let E = "";
                        b && (E += "audio"), T && (E += "video");
                        const A = {
                            data1: u,
                            startPTS: y,
                            startDTS: y,
                            endPTS: v,
                            endDTS: v,
                            type: E,
                            hasAudio: b,
                            hasVideo: T,
                            nb: 1,
                            dropped: 0
                        };
                        return d.audio = "audio" === A.type ? A : void 0, d.video = "audio" !== A.type ? A : void 0, d.initSegment = h, d.id3 = Nn(i, n, l, l), r.samples.length && (d.text = Fn(r, n, l)), d
                    }
                }
            }, {
                demux: vn,
                remux: On
            }, {
                demux: class extends Wr {
                    constructor(e, t) {
                        super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t
                    }
                    resetInitSegment(e, t, i, r) {
                        super.resetInitSegment(e, t, i, r), this._audioTrack = {
                            container: "audio/adts",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "aac",
                            samples: [],
                            manifestCodec: t,
                            duration: r,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    static probe(e) {
                        if (!e) return !1;
                        let t = (Qe(e, 0) || []).length;
                        for (let i = e.length; t < i; t++)
                            if (Zr(e, t)) return Ee.log("ADTS sync word found !"), !0;
                        return !1
                    }
                    canParse(e, t) {
                        return function(e, t) {
                            return function(e, t) {
                                return t + 5 < e.length
                            }(e, t) && zr(e, t) && Qr(e, t) <= e.length - t
                        }(e, t)
                    }
                    appendFrame(e, t, i) {
                        en(e, this.observer, t, i, e.manifestCodec);
                        const r = rn(e, t, i, this.basePTS, this.frameIndex);
                        if (r && 0 === r.missing) return r
                    }
                },
                remux: On
            }, {
                demux: class extends Wr {
                    resetInitSegment(e, t, i, r) {
                        super.resetInitSegment(e, t, i, r), this._audioTrack = {
                            container: "audio/mpeg",
                            type: "audio",
                            id: 2,
                            pid: -1,
                            sequenceNumber: 0,
                            segmentCodec: "mp3",
                            samples: [],
                            manifestCodec: t,
                            duration: r,
                            inputTimeScale: 9e4,
                            dropped: 0
                        }
                    }
                    static probe(e) {
                        if (!e) return !1;
                        let t = (Qe(e, 0) || []).length;
                        for (let i = e.length; t < i; t++)
                            if (mn(e, t)) return Ee.log("MPEG Audio sync word found !"), !0;
                        return !1
                    }
                    canParse(e, t) {
                        return function(e, t) {
                            return hn(e, t) && 4 <= e.length - t
                        }(e, t)
                    }
                    appendFrame(e, t, i) {
                        if (null !== this.basePTS) return dn(e, t, i, this.basePTS, this.frameIndex)
                    }
                },
                remux: On
            }];
            class jn {
                constructor(e, t, i, r, n) {
                    this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = i, this.vendor = r, this.id = n
                }
                configure(e) {
                    this.transmuxConfig = e, this.decrypter && this.decrypter.reset()
                }
                push(e, t, i, r) {
                    const n = i.transmuxing;
                    n.executeStart = In();
                    let s = new Uint8Array(e);
                    const {
                        currentTransmuxState: a,
                        transmuxConfig: o
                    } = this;
                    r && (this.currentTransmuxState = r);
                    const {
                        contiguous: l,
                        discontinuity: c,
                        trackSwitch: d,
                        accurateTimeOffset: u,
                        timeOffset: h,
                        initSegmentChange: f
                    } = r || a, {
                        audioCodec: m,
                        videoCodec: p,
                        defaultInitPts: g,
                        duration: y,
                        initSegmentData: v
                    } = o, b = function(e, t) {
                        let i = null;
                        e.byteLength > 0 && null != t && null != t.key && null !== t.iv && null != t.method && (i = t);
                        return i
                    }(s, t);
                    if (b && "AES-128" === b.method) {
                        const e = this.getDecrypter();
                        if (!e.isSync()) return this.decryptionPromise = e.webCryptoDecrypt(s, b.key.buffer, b.iv.buffer).then((e => {
                            const t = this.push(e, null, i);
                            return this.decryptionPromise = null, t
                        })), this.decryptionPromise; {
                            let t = e.softwareDecrypt(s, b.key.buffer, b.iv.buffer);
                            if (i.part > -1 && (t = e.flush()), !t) return n.executeEnd = In(), Gn(i);
                            s = new Uint8Array(t)
                        }
                    }
                    const T = this.needsProbing(c, d);
                    if (T) {
                        const e = this.configureTransmuxer(s);
                        if (e) return Ee.warn(`[transmuxer] ${e.message}`), this.observer.emit(me.ERROR, me.ERROR, {
                            type: pe.MEDIA_ERROR,
                            details: ge.FRAG_PARSING_ERROR,
                            fatal: !1,
                            error: e,
                            reason: e.message
                        }), n.executeEnd = In(), Gn(i)
                    }(c || d || f || T) && this.resetInitSegment(v, m, p, y, t), (c || f || T) && this.resetInitialTimestamp(g), l || this.resetContiguity();
                    const E = this.transmux(s, b, h, u, i),
                        A = this.currentTransmuxState;
                    return A.contiguous = !0, A.discontinuity = !1, A.trackSwitch = !1, n.executeEnd = In(), E
                }
                flush(e) {
                    const t = e.transmuxing;
                    t.executeStart = In();
                    const {
                        decrypter: i,
                        currentTransmuxState: r,
                        decryptionPromise: n
                    } = this;
                    if (n) return n.then((() => this.flush(e)));
                    const s = [],
                        {
                            timeOffset: a
                        } = r;
                    if (i) {
                        const t = i.flush();
                        t && s.push(this.push(t, null, e))
                    }
                    const {
                        demuxer: o,
                        remuxer: l
                    } = this;
                    if (!o || !l) return t.executeEnd = In(), [Gn(e)];
                    const c = o.flush(a);
                    return Vn(c) ? c.then((t => (this.flushRemux(s, t, e), s))) : (this.flushRemux(s, c, e), s)
                }
                flushRemux(e, t, i) {
                    const {
                        audioTrack: r,
                        videoTrack: n,
                        id3Track: s,
                        textTrack: a
                    } = t, {
                        accurateTimeOffset: o,
                        timeOffset: l
                    } = this.currentTransmuxState;
                    Ee.log(`[transmuxer.ts]: Flushed fragment ${i.sn}${i.part>-1?" p: "+i.part:""} of level ${i.level}`);
                    const c = this.remuxer.remux(r, n, s, a, l, o, !0, this.id);
                    e.push({
                        remuxResult: c,
                        chunkMeta: i
                    }), i.transmuxing.executeEnd = In()
                }
                resetInitialTimestamp(e) {
                    const {
                        demuxer: t,
                        remuxer: i
                    } = this;
                    t && i && (t.resetTimeStamp(e), i.resetTimeStamp(e))
                }
                resetContiguity() {
                    const {
                        demuxer: e,
                        remuxer: t
                    } = this;
                    e && t && (e.resetContiguity(), t.resetNextTimestamp())
                }
                resetInitSegment(e, t, i, r, n) {
                    const {
                        demuxer: s,
                        remuxer: a
                    } = this;
                    s && a && (s.resetInitSegment(e, t, i, r), a.resetInitSegment(e, t, i, n))
                }
                destroy() {
                    this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
                }
                transmux(e, t, i, r, n) {
                    let s;
                    return s = t && "SAMPLE-AES" === t.method ? this.transmuxSampleAes(e, t, i, r, n) : this.transmuxUnencrypted(e, i, r, n), s
                }
                transmuxUnencrypted(e, t, i, r) {
                    const {
                        audioTrack: n,
                        videoTrack: s,
                        id3Track: a,
                        textTrack: o
                    } = this.demuxer.demux(e, t, !1, !this.config.progressive);
                    return {
                        remuxResult: this.remuxer.remux(n, s, a, o, t, i, !1, this.id),
                        chunkMeta: r
                    }
                }
                transmuxSampleAes(e, t, i, r, n) {
                    return this.demuxer.demuxSampleAes(e, t, i).then((e => ({
                        remuxResult: this.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, i, r, !1, this.id),
                        chunkMeta: n
                    })))
                }
                configureTransmuxer(e) {
                    const {
                        config: t,
                        observer: i,
                        typeSupported: r,
                        vendor: n
                    } = this;
                    let s;
                    for (let t = 0, i = Hn.length; t < i; t++)
                        if (Hn[t].demux.probe(e)) {
                            s = Hn[t];
                            break
                        }
                    if (!s) return new Error("Failed to find demuxer by probing fragment data");
                    const a = this.demuxer,
                        o = this.remuxer,
                        l = s.remux,
                        c = s.demux;
                    o && o instanceof l || (this.remuxer = new l(i, t, r, n)), a && a instanceof c || (this.demuxer = new c(i, t, r), this.probe = c.probe)
                }
                needsProbing(e, t) {
                    return !this.demuxer || !this.remuxer || e || t
                }
                getDecrypter() {
                    let e = this.decrypter;
                    return e || (e = this.decrypter = new Cr(this.config)), e
                }
            }
            const Gn = e => ({
                remuxResult: {},
                chunkMeta: e
            });

            function Vn(e) {
                return "then" in e && e.then instanceof Function
            }
            class qn {
                constructor(e, t, i, r, n) {
                    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = i, this.duration = r, this.defaultInitPts = n || null
                }
            }
            class Kn {
                constructor(e, t, i, r, n, s) {
                    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = i, this.trackSwitch = r, this.timeOffset = n, this.initSegmentChange = s
                }
            }
            var Wn = {
                exports: {}
            };
            ! function(e) {
                var t = Object.prototype.hasOwnProperty,
                    i = "~";

                function r() {}

                function n(e, t, i) {
                    this.fn = e, this.context = t, this.once = i || !1
                }

                function s(e, t, r, s, a) {
                    if ("function" != typeof r) throw new TypeError("The listener must be a function");
                    var o = new n(r, s || e, a),
                        l = i ? i + t : t;
                    return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e
                }

                function a(e, t) {
                    0 == --e._eventsCount ? e._events = new r : delete e._events[t]
                }

                function o() {
                    this._events = new r, this._eventsCount = 0
                }
                Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (i = !1)), o.prototype.eventNames = function() {
                    var e, r, n = [];
                    if (0 === this._eventsCount) return n;
                    for (r in e = this._events) t.call(e, r) && n.push(i ? r.slice(1) : r);
                    return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(e)) : n
                }, o.prototype.listeners = function(e) {
                    var t = i ? i + e : e,
                        r = this._events[t];
                    if (!r) return [];
                    if (r.fn) return [r.fn];
                    for (var n = 0, s = r.length, a = new Array(s); n < s; n++) a[n] = r[n].fn;
                    return a
                }, o.prototype.listenerCount = function(e) {
                    var t = i ? i + e : e,
                        r = this._events[t];
                    return r ? r.fn ? 1 : r.length : 0
                }, o.prototype.emit = function(e, t, r, n, s, a) {
                    var o = i ? i + e : e;
                    if (!this._events[o]) return !1;
                    var l, c, d = this._events[o],
                        u = arguments.length;
                    if (d.fn) {
                        switch (d.once && this.removeListener(e, d.fn, void 0, !0), u) {
                            case 1:
                                return d.fn.call(d.context), !0;
                            case 2:
                                return d.fn.call(d.context, t), !0;
                            case 3:
                                return d.fn.call(d.context, t, r), !0;
                            case 4:
                                return d.fn.call(d.context, t, r, n), !0;
                            case 5:
                                return d.fn.call(d.context, t, r, n, s), !0;
                            case 6:
                                return d.fn.call(d.context, t, r, n, s, a), !0
                        }
                        for (c = 1, l = new Array(u - 1); c < u; c++) l[c - 1] = arguments[c];
                        d.fn.apply(d.context, l)
                    } else {
                        var h, f = d.length;
                        for (c = 0; c < f; c++) switch (d[c].once && this.removeListener(e, d[c].fn, void 0, !0), u) {
                            case 1:
                                d[c].fn.call(d[c].context);
                                break;
                            case 2:
                                d[c].fn.call(d[c].context, t);
                                break;
                            case 3:
                                d[c].fn.call(d[c].context, t, r);
                                break;
                            case 4:
                                d[c].fn.call(d[c].context, t, r, n);
                                break;
                            default:
                                if (!l)
                                    for (h = 1, l = new Array(u - 1); h < u; h++) l[h - 1] = arguments[h];
                                d[c].fn.apply(d[c].context, l)
                        }
                    }
                    return !0
                }, o.prototype.on = function(e, t, i) {
                    return s(this, e, t, i, !1)
                }, o.prototype.once = function(e, t, i) {
                    return s(this, e, t, i, !0)
                }, o.prototype.removeListener = function(e, t, r, n) {
                    var s = i ? i + e : e;
                    if (!this._events[s]) return this;
                    if (!t) return a(this, s), this;
                    var o = this._events[s];
                    if (o.fn) o.fn !== t || n && !o.once || r && o.context !== r || a(this, s);
                    else {
                        for (var l = 0, c = [], d = o.length; l < d; l++)(o[l].fn !== t || n && !o[l].once || r && o[l].context !== r) && c.push(o[l]);
                        c.length ? this._events[s] = 1 === c.length ? c[0] : c : a(this, s)
                    }
                    return this
                }, o.prototype.removeAllListeners = function(e) {
                    var t;
                    return e ? (t = i ? i + e : e, this._events[t] && a(this, t)) : (this._events = new r, this._eventsCount = 0), this
                }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = i, o.EventEmitter = o, e.exports = o
            }(Wn);
            var Yn = Z(Wn.exports);
            const zn = Ut() || {
                isTypeSupported: () => !1
            };
            class Xn {
                constructor(e, t, i, r) {
                    this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
                    const n = e.config;
                    this.hls = e, this.id = t, this.useWorker = !!n.enableWorker, this.onTransmuxComplete = i, this.onFlush = r;
                    const s = (e, t) => {
                        (t = t || {}).frag = this.frag, t.id = this.id, e === me.ERROR && (this.error = t.error), this.hls.trigger(e, t)
                    };
                    this.observer = new Yn, this.observer.on(me.FRAG_DECRYPTED, s), this.observer.on(me.ERROR, s);
                    const a = {
                            mp4: zn.isTypeSupported("video/mp4"),
                            mpeg: zn.isTypeSupported("audio/mpeg"),
                            mp3: zn.isTypeSupported('audio/mp4; codecs="mp3"')
                        },
                        o = navigator.vendor;
                    if (this.useWorker && "undefined" != typeof Worker) {
                        if (n.workerPath || "function" == typeof __HLS_WORKER_BUNDLE__) {
                            try {
                                n.workerPath ? (Ee.log(`loading Web Worker ${n.workerPath} for "${t}"`), this.workerContext = function(e) {
                                    const t = new self.URL(e, self.location.href).href;
                                    return {
                                        worker: new self.Worker(t),
                                        scriptURL: t
                                    }
                                }(n.workerPath)) : (Ee.log(`injecting Web Worker for "${t}"`), this.workerContext = function() {
                                    const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
                                            type: "text/javascript"
                                        }),
                                        t = self.URL.createObjectURL(e);
                                    return {
                                        worker: new self.Worker(t),
                                        objectURL: t
                                    }
                                }()), this.onwmsg = e => this.onWorkerMessage(e);
                                const {
                                    worker: e
                                } = this.workerContext;
                                e.addEventListener("message", this.onwmsg), e.onerror = e => {
                                    const i = new Error(`${e.message}  (${e.filename}:${e.lineno})`);
                                    n.enableWorker = !1, Ee.warn(`Error in "${t}" Web Worker, fallback to inline`), this.hls.trigger(me.ERROR, {
                                        type: pe.OTHER_ERROR,
                                        details: ge.INTERNAL_EXCEPTION,
                                        fatal: !1,
                                        event: "demuxerWorker",
                                        error: i
                                    })
                                }, e.postMessage({
                                    cmd: "init",
                                    typeSupported: a,
                                    vendor: o,
                                    id: t,
                                    config: JSON.stringify(n)
                                })
                            } catch (e) {
                                Ee.warn(`Error setting up "${t}" Web Worker, fallback to inline`, e), this.resetWorker(), this.error = null, this.transmuxer = new jn(this.observer, a, n, o, t)
                            }
                            return
                        }
                    }
                    this.transmuxer = new jn(this.observer, a, n, o, t)
                }
                resetWorker() {
                    if (this.workerContext) {
                        const {
                            worker: e,
                            objectURL: t
                        } = this.workerContext;
                        t && self.URL.revokeObjectURL(t), e.removeEventListener("message", this.onwmsg), e.onerror = null, e.terminate(), this.workerContext = null
                    }
                }
                destroy() {
                    if (this.workerContext) this.resetWorker(), this.onwmsg = void 0;
                    else {
                        const e = this.transmuxer;
                        e && (e.destroy(), this.transmuxer = null)
                    }
                    const e = this.observer;
                    e && e.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null
                }
                push(e, t, i, r, n, s, a, o, l, c) {
                    var d, u;
                    l.transmuxing.start = self.performance.now();
                    const {
                        transmuxer: h
                    } = this, f = s ? s.start : n.start, m = n.decryptdata, p = this.frag, g = !(p && n.cc === p.cc), y = !(p && l.level === p.level), v = p ? l.sn - p.sn : -1, b = this.part ? l.part - this.part.index : -1, T = 0 === v && l.id > 1 && l.id === (null == p ? void 0 : p.stats.chunkCount), E = !y && (1 === v || 0 === v && (1 === b || T && b <= 0)), A = self.performance.now();
                    (y || v || 0 === n.stats.parsing.start) && (n.stats.parsing.start = A), !s || !b && E || (s.stats.parsing.start = A);
                    const w = !(p && (null == (d = n.initSegment) ? void 0 : d.url) === (null == (u = p.initSegment) ? void 0 : u.url)),
                        _ = new Kn(g, E, o, y, f, w);
                    if (!E || g || w) {
                        Ee.log(`[transmuxer-interface, ${n.type}]: Starting new transmux session for sn: ${l.sn} p: ${l.part} level: ${l.level} id: ${l.id}\n        discontinuity: ${g}\n        trackSwitch: ${y}\n        contiguous: ${E}\n        accurateTimeOffset: ${o}\n        timeOffset: ${f}\n        initSegmentChange: ${w}`);
                        const e = new qn(i, r, t, a, c);
                        this.configureTransmuxer(e)
                    }
                    if (this.frag = n, this.part = s, this.workerContext) this.workerContext.worker.postMessage({
                        cmd: "demux",
                        data: e,
                        decryptdata: m,
                        chunkMeta: l,
                        state: _
                    }, e instanceof ArrayBuffer ? [e] : []);
                    else if (h) {
                        const t = h.push(e, m, l, _);
                        Vn(t) ? (h.async = !0, t.then((e => {
                            this.handleTransmuxComplete(e)
                        })).catch((e => {
                            this.transmuxerError(e, l, "transmuxer-interface push error")
                        }))) : (h.async = !1, this.handleTransmuxComplete(t))
                    }
                }
                flush(e) {
                    e.transmuxing.start = self.performance.now();
                    const {
                        transmuxer: t
                    } = this;
                    if (this.workerContext) this.workerContext.worker.postMessage({
                        cmd: "flush",
                        chunkMeta: e
                    });
                    else if (t) {
                        let i = t.flush(e);
                        Vn(i) || t.async ? (Vn(i) || (i = Promise.resolve(i)), i.then((t => {
                            this.handleFlushResult(t, e)
                        })).catch((t => {
                            this.transmuxerError(t, e, "transmuxer-interface flush error")
                        }))) : this.handleFlushResult(i, e)
                    }
                }
                transmuxerError(e, t, i) {
                    this.hls && (this.error = e, this.hls.trigger(me.ERROR, {
                        type: pe.MEDIA_ERROR,
                        details: ge.FRAG_PARSING_ERROR,
                        chunkMeta: t,
                        fatal: !1,
                        error: e,
                        err: e,
                        reason: i
                    }))
                }
                handleFlushResult(e, t) {
                    e.forEach((e => {
                        this.handleTransmuxComplete(e)
                    })), this.onFlush(t)
                }
                onWorkerMessage(e) {
                    const t = e.data,
                        i = this.hls;
                    switch (t.event) {
                        case "init":
                            {
                                var r;
                                const e = null == (r = this.workerContext) ? void 0 : r.objectURL;e && self.URL.revokeObjectURL(e);
                                break
                            }
                        case "transmuxComplete":
                            this.handleTransmuxComplete(t.data);
                            break;
                        case "flush":
                            this.onFlush(t.data);
                            break;
                        case "workerLog":
                            Ee[t.data.logType] && Ee[t.data.logType](t.data.message);
                            break;
                        default:
                            t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, i.trigger(t.event, t.data)
                    }
                }
                configureTransmuxer(e) {
                    const {
                        transmuxer: t
                    } = this;
                    this.workerContext ? this.workerContext.worker.postMessage({
                        cmd: "configure",
                        config: e
                    }) : t && t.configure(e)
                }
                handleTransmuxComplete(e) {
                    e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e)
                }
            }
            class Qn {
                constructor(e, t, i, r) {
                    this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = i, this.hls = r
                }
                destroy() {
                    this.media = null, this.hls = this.fragmentTracker = null
                }
                poll(e, t) {
                    const {
                        config: i,
                        media: r,
                        stalled: n
                    } = this;
                    if (null === r) return;
                    const {
                        currentTime: s,
                        seeking: a
                    } = r, o = this.seeking && !a, l = !this.seeking && a;
                    if (this.seeking = a, s !== e) {
                        if (this.moved = !0, null !== n) {
                            if (this.stallReported) {
                                const e = self.performance.now() - n;
                                Ee.warn(`playback not stuck anymore @${s}, after ${Math.round(e)}ms`), this.stallReported = !1
                            }
                            this.stalled = null, this.nudgeRetry = 0
                        }
                        return
                    }
                    if (l || o) return void(this.stalled = null);
                    if (r.paused && !a || r.ended || 0 === r.playbackRate || !Tr.getBuffered(r).length) return;
                    const c = Tr.bufferInfo(r, s, 0),
                        d = c.len > 0,
                        u = c.nextStart || 0;
                    if (!d && !u) return;
                    if (a) {
                        const e = c.len > 2,
                            i = !u || t && t.start <= s || u - s > 2 && !this.fragmentTracker.getPartialFragment(s);
                        if (e || i) return;
                        this.moved = !1
                    }
                    if (!this.moved && null !== this.stalled) {
                        var h;
                        const e = Math.max(u, c.start || 0) - s,
                            t = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
                            i = (null == t || null == (h = t.details) ? void 0 : h.live) ? 2 * t.details.targetduration : 2,
                            r = this.fragmentTracker.getPartialFragment(s);
                        if (e > 0 && (e <= i || r)) return void this._trySkipBufferHole(r)
                    }
                    const f = self.performance.now();
                    if (null === n) return void(this.stalled = f);
                    const m = f - n;
                    if (!a && m >= 250 && (this._reportStall(c), !this.media)) return;
                    const p = Tr.bufferInfo(r, s, i.maxBufferHole);
                    this._tryFixBufferStall(p, m)
                }
                _tryFixBufferStall(e, t) {
                    const {
                        config: i,
                        fragmentTracker: r,
                        media: n
                    } = this;
                    if (null === n) return;
                    const s = n.currentTime,
                        a = r.getPartialFragment(s);
                    if (a) {
                        if (this._trySkipBufferHole(a) || !this.media) return
                    }(e.len > i.maxBufferHole || e.nextStart && e.nextStart - s < i.maxBufferHole) && t > 1e3 * i.highBufferWatchdogPeriod && (Ee.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
                }
                _reportStall(e) {
                    const {
                        hls: t,
                        media: i,
                        stallReported: r
                    } = this;
                    if (!r && i) {
                        this.stallReported = !0;
                        const r = new Error(`Playback stalling at @${i.currentTime} due to low buffer (${JSON.stringify(e)})`);
                        Ee.warn(r.message), t.trigger(me.ERROR, {
                            type: pe.MEDIA_ERROR,
                            details: ge.BUFFER_STALLED_ERROR,
                            fatal: !1,
                            error: r,
                            buffer: e.len
                        })
                    }
                }
                _trySkipBufferHole(e) {
                    const {
                        config: t,
                        hls: i,
                        media: r
                    } = this;
                    if (null === r) return 0;
                    const n = r.currentTime,
                        s = Tr.bufferInfo(r, n, 0),
                        a = n < s.start ? s.start : s.nextStart;
                    if (a) {
                        const o = s.len <= t.maxBufferHole,
                            l = s.len > 0 && s.len < 1 && r.readyState < 3,
                            c = a - n;
                        if (c > 0 && (o || l)) {
                            if (c > t.maxBufferHole) {
                                const {
                                    fragmentTracker: t
                                } = this;
                                let i = !1;
                                if (0 === n) {
                                    const e = t.getAppendedFrag(0, ai);
                                    e && a < e.end && (i = !0)
                                }
                                if (!i) {
                                    const i = e || t.getAppendedFrag(n, ai);
                                    if (i) {
                                        let e = !1,
                                            r = i.end;
                                        for (; r < a;) {
                                            const i = t.getPartialFragment(r);
                                            if (!i) {
                                                e = !0;
                                                break
                                            }
                                            r += i.duration
                                        }
                                        if (e) return 0
                                    }
                                }
                            }
                            const s = Math.max(a + .05, n + .1);
                            if (Ee.warn(`skipping hole, adjusting currentTime from ${n} to ${s}`), this.moved = !0, this.stalled = null, r.currentTime = s, e && !e.gap) {
                                const t = new Error(`fragment loaded with buffer holes, seeking from ${n} to ${s}`);
                                i.trigger(me.ERROR, {
                                    type: pe.MEDIA_ERROR,
                                    details: ge.BUFFER_SEEK_OVER_HOLE,
                                    fatal: !1,
                                    error: t,
                                    reason: t.message,
                                    frag: e
                                })
                            }
                            return s
                        }
                    }
                    return 0
                }
                _tryNudgeBuffer() {
                    const {
                        config: e,
                        hls: t,
                        media: i,
                        nudgeRetry: r
                    } = this;
                    if (null === i) return;
                    const n = i.currentTime;
                    if (this.nudgeRetry++, r < e.nudgeMaxRetry) {
                        const s = n + (r + 1) * e.nudgeOffset,
                            a = new Error(`Nudging 'currentTime' from ${n} to ${s}`);
                        Ee.warn(a.message), i.currentTime = s, t.trigger(me.ERROR, {
                            type: pe.MEDIA_ERROR,
                            details: ge.BUFFER_NUDGE_ON_STALL,
                            error: a,
                            fatal: !1
                        })
                    } else {
                        const i = new Error(`Playhead still not moving while enough data buffered @${n} after ${e.nudgeMaxRetry} nudges`);
                        Ee.error(i.message), t.trigger(me.ERROR, {
                            type: pe.MEDIA_ERROR,
                            details: ge.BUFFER_STALLED_ERROR,
                            error: i,
                            fatal: !0
                        })
                    }
                }
            }
            class Jn extends Vr {
                constructor(e, t, i) {
                    super(e, t, i, "[stream-controller]", ai), this.audioCodecSwap = !1, this.gapController = null, this.level = -1, this._forceStartLoad = !1, this.altAudio = !1, this.audioOnly = !1, this.fragPlaying = null, this.onvplaying = null, this.onvseeked = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this._registerListeners()
                }
                _registerListeners() {
                    const {
                        hls: e
                    } = this;
                    e.on(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.MANIFEST_PARSED, this.onManifestParsed, this), e.on(me.LEVEL_LOADING, this.onLevelLoading, this), e.on(me.LEVEL_LOADED, this.onLevelLoaded, this), e.on(me.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(me.ERROR, this.onError, this), e.on(me.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(me.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(me.BUFFER_CREATED, this.onBufferCreated, this), e.on(me.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(me.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(me.FRAG_BUFFERED, this.onFragBuffered, this)
                }
                _unregisterListeners() {
                    const {
                        hls: e
                    } = this;
                    e.off(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.MANIFEST_PARSED, this.onManifestParsed, this), e.off(me.LEVEL_LOADED, this.onLevelLoaded, this), e.off(me.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(me.ERROR, this.onError, this), e.off(me.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(me.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(me.BUFFER_CREATED, this.onBufferCreated, this), e.off(me.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(me.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(me.FRAG_BUFFERED, this.onFragBuffered, this)
                }
                onHandlerDestroying() {
                    this._unregisterListeners(), this.onMediaDetaching()
                }
                startLoad(e) {
                    if (this.levels) {
                        const {
                            lastCurrentTime: t,
                            hls: i
                        } = this;
                        if (this.stopLoad(), this.setInterval(100), this.level = -1, !this.startFragRequested) {
                            let e = i.startLevel; - 1 === e && (i.config.testBandwidth && this.levels.length > 1 ? (e = 0, this.bitrateTest = !0) : e = i.nextAutoLevel), this.level = i.nextLoadLevel = e, this.loadedmetadata = !1
                        }
                        t > 0 && -1 === e && (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t), this.state = xr, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
                    } else this._forceStartLoad = !0, this.state = Pr
                }
                stopLoad() {
                    this._forceStartLoad = !1, super.stopLoad()
                }
                doTick() {
                    switch (this.state) {
                        case Gr:
                            {
                                var e;
                                const {
                                    levels: t,
                                    level: i
                                } = this,
                                r = null == t || null == (e = t[i]) ? void 0 : e.details;
                                if (r && (!r.live || this.levelLastLoaded === this.level)) {
                                    if (this.waitForCdnTuneIn(r)) break;
                                    this.state = xr;
                                    break
                                }
                                if (this.hls.nextLoadLevel !== this.level) {
                                    this.state = xr;
                                    break
                                }
                                break
                            }
                        case Nr:
                            {
                                var t;
                                const e = self.performance.now(),
                                    i = this.retryDate;
                                (!i || e >= i || null != (t = this.media) && t.seeking) && (this.resetStartWhenNotLoaded(this.level), this.state = xr)
                            }
                    }
                    this.state === xr && this.doTickIdle(), this.onTickEnd()
                }
                onTickEnd() {
                    super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged()
                }
                doTickIdle() {
                    const {
                        hls: e,
                        levelLastLoaded: t,
                        levels: i,
                        media: r
                    } = this, {
                        config: n,
                        nextLoadLevel: s
                    } = e;
                    if (null === t || !r && (this.startFragRequested || !n.startFragPrefetch)) return;
                    if (this.altAudio && this.audioOnly) return;
                    if (null == i || !i[s]) return;
                    const a = i[s],
                        o = this.getMainFwdBufferInfo();
                    if (null === o) return;
                    const l = this.getLevelDetails();
                    if (l && this._streamEnded(o, l)) {
                        const e = {};
                        return this.altAudio && (e.type = "video"), this.hls.trigger(me.BUFFER_EOS, e), void(this.state = $r)
                    }
                    e.loadLevel !== s && -1 === e.manualLevel && this.log(`Adapting to level ${s} from level ${this.level}`), this.level = e.nextLoadLevel = s;
                    const c = a.details;
                    if (!c || this.state === Gr || c.live && this.levelLastLoaded !== s) return this.level = s, void(this.state = Gr);
                    const d = o.len,
                        u = this.getMaxBufferLength(a.maxBitrate);
                    if (d >= u) return;
                    this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null);
                    const h = this.backtrackFragment ? this.backtrackFragment.start : o.end;
                    let f = this.getNextFragment(h, c);
                    if (this.couldBacktrack && !this.fragPrevious && f && "initSegment" !== f.sn && this.fragmentTracker.getState(f) !== lr) {
                        var m;
                        const e = (null != (m = this.backtrackFragment) ? m : f).sn - c.startSN,
                            t = c.fragments[e - 1];
                        t && f.cc === t.cc && (f = t, this.fragmentTracker.removeFragment(t))
                    } else this.backtrackFragment && o.len && (this.backtrackFragment = null);
                    if (f && this.isLoopLoading(f, h)) {
                        if (!f.gap) {
                            const e = this.audioOnly && !this.altAudio ? Re : De,
                                t = (e === De ? this.videoBuffer : this.mediaBuffer) || this.media;
                            t && this.afterBufferFlushed(t, e, ai)
                        }
                        f = this.getNextFragmentLoopLoading(f, c, o, ai, u)
                    }
                    f && (!f.initSegment || f.initSegment.data || this.bitrateTest || (f = f.initSegment), this.loadFragment(f, a, h))
                }
                loadFragment(e, t, i) {
                    const r = this.fragmentTracker.getState(e);
                    this.fragCurrent = e, r === sr || r === or ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : (this.startFragRequested = !0, super.loadFragment(e, t, i)) : this.clearTrackerIfNeeded(e)
                }
                getBufferedFrag(e) {
                    return this.fragmentTracker.getBufferedFrag(e, ai)
                }
                followingBufferedFrag(e) {
                    return e ? this.getBufferedFrag(e.end + .5) : null
                }
                immediateLevelSwitch() {
                    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
                }
                nextLevelSwitch() {
                    const {
                        levels: e,
                        media: t
                    } = this;
                    if (null != t && t.readyState) {
                        let i;
                        const r = this.getAppendedFrag(t.currentTime);
                        r && r.start > 1 && this.flushMainBuffer(0, r.start - 1);
                        const n = this.getLevelDetails();
                        if (null != n && n.live) {
                            const e = this.getMainFwdBufferInfo();
                            if (!e || e.len < 2 * n.targetduration) return
                        }
                        if (!t.paused && e) {
                            const t = e[this.hls.nextLoadLevel],
                                r = this.fragLastKbps;
                            i = r && this.fragCurrent ? this.fragCurrent.duration * t.maxBitrate / (1e3 * r) + 1 : 0
                        } else i = 0;
                        const s = this.getBufferedFrag(t.currentTime + i);
                        if (s) {
                            const e = this.followingBufferedFrag(s);
                            if (e) {
                                this.abortCurrentFrag();
                                const t = e.maxStartPTS ? e.maxStartPTS : e.start,
                                    i = e.duration,
                                    r = Math.max(s.end, t + Math.min(Math.max(i - this.config.maxFragLookUpTolerance, .5 * i), .75 * i));
                                this.flushMainBuffer(r, Number.POSITIVE_INFINITY)
                            }
                        }
                    }
                }
                abortCurrentFrag() {
                    const e = this.fragCurrent;
                    switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {
                        case Or:
                        case Mr:
                        case Nr:
                        case Br:
                        case Ur:
                            this.state = xr
                    }
                    this.nextLoadPosition = this.getLoadPosition()
                }
                flushMainBuffer(e, t) {
                    super.flushMainBuffer(e, t, this.altAudio ? "video" : null)
                }
                onMediaAttached(e, t) {
                    super.onMediaAttached(e, t);
                    const i = t.media;
                    this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener("playing", this.onvplaying), i.addEventListener("seeked", this.onvseeked), this.gapController = new Qn(this.config, i, this.fragmentTracker, this.hls)
                }
                onMediaDetaching() {
                    const {
                        media: e
                    } = this;
                    e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), super.onMediaDetaching()
                }
                onMediaPlaying() {
                    this.tick()
                }
                onMediaSeeked() {
                    const e = this.media,
                        t = e ? e.currentTime : null;
                    ue(t) && this.log(`Media seeked to ${t.toFixed(3)}`);
                    const i = this.getMainFwdBufferInfo();
                    null !== i && 0 !== i.len ? this.tick() : this.warn(`Main forward buffer length on "seeked" event ${i?i.len:"empty"})`)
                }
                onManifestLoading() {
                    this.log("Trigger BUFFER_RESET"), this.hls.trigger(me.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = 0, this.levels = this.fragPlaying = this.backtrackFragment = null, this.altAudio = this.audioOnly = !1
                }
                onManifestParsed(e, t) {
                    let i, r = !1,
                        n = !1;
                    t.levels.forEach((e => {
                        i = e.audioCodec, i && (-1 !== i.indexOf("mp4a.40.2") && (r = !0), -1 !== i.indexOf("mp4a.40.5") && (n = !0))
                    })), this.audioCodecSwitch = r && n && ! function() {
                        var e;
                        const t = qr();
                        return "function" == typeof(null == t || null == (e = t.prototype) ? void 0 : e.changeType)
                    }(), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = t.levels, this.startFragRequested = !1
                }
                onLevelLoading(e, t) {
                    const {
                        levels: i
                    } = this;
                    if (!i || this.state !== xr) return;
                    const r = i[t.level];
                    (!r.details || r.details.live && this.levelLastLoaded !== t.level || this.waitForCdnTuneIn(r.details)) && (this.state = Gr)
                }
                onLevelLoaded(e, t) {
                    var i;
                    const {
                        levels: r
                    } = this, n = t.level, s = t.details, a = s.totalduration;
                    if (!r) return void this.warn(`Levels were reset while loading level ${n}`);
                    this.log(`Level ${n} loaded [${s.startSN},${s.endSN}]${s.lastPartSn?`[part-${s.lastPartSn}-${s.lastPartIndex}]`:""}, cc [${s.startCC}, ${s.endCC}] duration:${a}`);
                    const o = r[n],
                        l = this.fragCurrent;
                    !l || this.state !== Mr && this.state !== Nr || l.level === t.level && l.urlId === o.urlId || !l.loader || this.abortCurrentFrag();
                    let c = 0;
                    if (s.live || null != (i = o.details) && i.live) {
                        if (this.checkLiveUpdate(s), s.deltaUpdateFailed) return;
                        c = this.alignPlaylists(s, o.details)
                    }
                    if (o.details = s, this.levelLastLoaded = n, this.hls.trigger(me.LEVEL_UPDATED, {
                            details: s,
                            level: n
                        }), this.state === Gr) {
                        if (this.waitForCdnTuneIn(s)) return;
                        this.state = xr
                    }
                    this.startFragRequested ? s.live && this.synchronizeToLiveEdge(s) : this.setStartPosition(s, c), this.tick()
                }
                _handleFragmentLoadProgress(e) {
                    var t;
                    const {
                        frag: i,
                        part: r,
                        payload: n
                    } = e, {
                        levels: s
                    } = this;
                    if (!s) return void this.warn(`Levels were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
                    const a = s[i.level],
                        o = a.details;
                    if (!o) return this.warn(`Dropping fragment ${i.sn} of level ${i.level} after level details were reset`), void this.fragmentTracker.removeFragment(i);
                    const l = a.videoCodec,
                        c = o.PTSKnown || !o.live,
                        d = null == (t = i.initSegment) ? void 0 : t.data,
                        u = this._getAudioCodec(a),
                        h = this.transmuxer = this.transmuxer || new Xn(this.hls, ai, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
                        f = r ? r.index : -1,
                        m = -1 !== f,
                        p = new Er(i.level, i.sn, i.stats.chunkCount, n.byteLength, f, m),
                        g = this.initPTS[i.cc];
                    h.push(n, d, u, l, i, r, o.totalduration, c, p, g)
                }
                onAudioTrackSwitching(e, t) {
                    const i = this.altAudio;
                    if (!!!t.url) {
                        if (this.mediaBuffer !== this.media) {
                            this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                            const e = this.fragCurrent;
                            e && (this.log("Switching to main audio track, cancel main fragment load"), e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.resetLoadingState()
                        } else this.audioOnly && this.resetTransmuxer();
                        const e = this.hls;
                        i && (e.trigger(me.BUFFER_FLUSHING, {
                            startOffset: 0,
                            endOffset: Number.POSITIVE_INFINITY,
                            type: null
                        }), this.fragmentTracker.removeAllFragments()), e.trigger(me.AUDIO_TRACK_SWITCHED, t)
                    }
                }
                onAudioTrackSwitched(e, t) {
                    const i = t.id,
                        r = !!this.hls.audioTracks[i].url;
                    if (r) {
                        const e = this.videoBuffer;
                        e && this.mediaBuffer !== e && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = e)
                    }
                    this.altAudio = r, this.tick()
                }
                onBufferCreated(e, t) {
                    const i = t.tracks;
                    let r, n, s = !1;
                    for (const e in i) {
                        const t = i[e];
                        if ("main" === t.id) {
                            if (n = e, r = t, "video" === e) {
                                const t = i[e];
                                t && (this.videoBuffer = t.buffer)
                            }
                        } else s = !0
                    }
                    s && r ? (this.log(`Alternate track found, use ${n}.buffered to schedule main fragment loading`), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
                }
                onFragBuffered(e, t) {
                    const {
                        frag: i,
                        part: r
                    } = t;
                    if (i && i.type !== ai) return;
                    if (this.fragContextChanged(i)) return this.warn(`Fragment ${i.sn}${r?" p: "+r.index:""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}`), void(this.state === Ur && (this.state = xr));
                    const n = r ? r.stats : i.stats;
                    this.fragLastKbps = Math.round(8 * n.total / (n.buffering.end - n.loading.first)), "initSegment" !== i.sn && (this.fragPrevious = i), this.fragBufferedComplete(i, r)
                }
                onError(e, t) {
                    var i;
                    if (t.fatal) this.state = Hr;
                    else switch (t.details) {
                        case ge.FRAG_GAP:
                        case ge.FRAG_PARSING_ERROR:
                        case ge.FRAG_DECRYPT_ERROR:
                        case ge.FRAG_LOAD_ERROR:
                        case ge.FRAG_LOAD_TIMEOUT:
                        case ge.KEY_LOAD_ERROR:
                        case ge.KEY_LOAD_TIMEOUT:
                            this.onFragmentOrKeyLoadError(ai, t);
                            break;
                        case ge.LEVEL_LOAD_ERROR:
                        case ge.LEVEL_LOAD_TIMEOUT:
                        case ge.LEVEL_PARSING_ERROR:
                            t.levelRetry || this.state !== Gr || (null == (i = t.context) ? void 0 : i.type) !== ri || (this.state = xr);
                            break;
                        case ge.BUFFER_FULL_ERROR:
                            if (!t.parent || "main" !== t.parent) return;
                            this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                            break;
                        case ge.INTERNAL_EXCEPTION:
                            this.recoverWorkerError(t)
                    }
                }
                checkBuffer() {
                    const {
                        media: e,
                        gapController: t
                    } = this;
                    if (e && t && e.readyState) {
                        if (this.loadedmetadata || !Tr.getBuffered(e).length) {
                            const e = this.state !== xr ? this.fragCurrent : null;
                            t.poll(this.lastCurrentTime, e)
                        }
                        this.lastCurrentTime = e.currentTime
                    }
                }
                onFragLoadEmergencyAborted() {
                    this.state = xr, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
                }
                onBufferFlushed(e, {
                    type: t
                }) {
                    if (t !== Re || this.audioOnly && !this.altAudio) {
                        const e = (t === De ? this.videoBuffer : this.mediaBuffer) || this.media;
                        this.afterBufferFlushed(e, t, ai)
                    }
                }
                onLevelsUpdated(e, t) {
                    this.levels = t.levels
                }
                swapAudioCodec() {
                    this.audioCodecSwap = !this.audioCodecSwap
                }
                seekToStartPos() {
                    const {
                        media: e
                    } = this;
                    if (!e) return;
                    const t = e.currentTime;
                    let i = this.startPosition;
                    if (i >= 0 && t < i) {
                        if (e.seeking) return void this.log(`could not seek to ${i}, already seeking at ${t}`);
                        const r = Tr.getBuffered(e),
                            n = (r.length ? r.start(0) : 0) - i;
                        n > 0 && (n < this.config.maxBufferHole || n < this.config.maxFragLookUpTolerance) && (this.log(`adjusting start position by ${n} to match buffer start`), i += n, this.startPosition = i), this.log(`seek to target start position ${i} from current time ${t}`), e.currentTime = i
                    }
                }
                _getAudioCodec(e) {
                    let t = this.config.defaultAudioCodec || e.audioCodec;
                    return this.audioCodecSwap && t && (this.log("Swapping audio codec"), t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), t
                }
                _loadBitrateTestFrag(e, t) {
                    e.bitrateTest = !0, this._doFragLoad(e, t).then((i => {
                        const {
                            hls: r
                        } = this;
                        if (!i || this.fragContextChanged(e)) return;
                        t.fragmentError = 0, this.state = xr, this.startFragRequested = !1, this.bitrateTest = !1;
                        const n = e.stats;
                        n.parsing.start = n.parsing.end = n.buffering.start = n.buffering.end = self.performance.now(), r.trigger(me.FRAG_LOADED, i), e.bitrateTest = !1
                    }))
                }
                _handleTransmuxComplete(e) {
                    var t;
                    const i = "main",
                        {
                            hls: r
                        } = this,
                        {
                            remuxResult: n,
                            chunkMeta: s
                        } = e,
                        a = this.getCurrentContext(s);
                    if (!a) return void this.resetWhenMissingContext(s);
                    const {
                        frag: o,
                        part: l,
                        level: c
                    } = a, {
                        video: d,
                        text: u,
                        id3: h,
                        initSegment: f
                    } = n, {
                        details: m
                    } = c, p = this.altAudio ? void 0 : n.audio;
                    if (this.fragContextChanged(o)) this.fragmentTracker.removeFragment(o);
                    else {
                        if (this.state = Br, f) {
                            if (null != f && f.tracks) {
                                const e = o.initSegment || o;
                                this._bufferInitSegment(c, f.tracks, e, s), r.trigger(me.FRAG_PARSING_INIT_SEGMENT, {
                                    frag: e,
                                    id: i,
                                    tracks: f.tracks
                                })
                            }
                            const e = f.initPTS,
                                t = f.timescale;
                            ue(e) && (this.initPTS[o.cc] = {
                                baseTime: e,
                                timescale: t
                            }, r.trigger(me.INIT_PTS_FOUND, {
                                frag: o,
                                id: i,
                                initPTS: e,
                                timescale: t
                            }))
                        }
                        if (d && m && "initSegment" !== o.sn) {
                            const e = m.fragments[o.sn - 1 - m.startSN],
                                t = o.sn === m.startSN,
                                i = !e || o.cc > e.cc;
                            if (!1 !== n.independent) {
                                const {
                                    startPTS: e,
                                    endPTS: r,
                                    startDTS: n,
                                    endDTS: a
                                } = d;
                                if (l) l.elementaryStreams[d.type] = {
                                    startPTS: e,
                                    endPTS: r,
                                    startDTS: n,
                                    endDTS: a
                                };
                                else if (d.firstKeyFrame && d.independent && 1 === s.id && !i && (this.couldBacktrack = !0), d.dropped && d.independent) {
                                    const n = this.getMainFwdBufferInfo(),
                                        s = (n ? n.end : this.getLoadPosition()) + this.config.maxBufferHole,
                                        l = d.firstKeyFramePTS ? d.firstKeyFramePTS : e;
                                    if (!t && s < l - this.config.maxBufferHole && !i) return void this.backtrack(o);
                                    i && (o.gap = !0), o.setElementaryStreamInfo(d.type, o.start, r, o.start, a, !0)
                                }
                                o.setElementaryStreamInfo(d.type, e, r, n, a), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(d, o, l, s, t || i)
                            } else {
                                if (!t && !i) return void this.backtrack(o);
                                o.gap = !0
                            }
                        }
                        if (p) {
                            const {
                                startPTS: e,
                                endPTS: t,
                                startDTS: i,
                                endDTS: r
                            } = p;
                            l && (l.elementaryStreams[Re] = {
                                startPTS: e,
                                endPTS: t,
                                startDTS: i,
                                endDTS: r
                            }), o.setElementaryStreamInfo(Re, e, t, i, r), this.bufferFragmentData(p, o, l, s)
                        }
                        if (m && null != h && null != (t = h.samples) && t.length) {
                            const e = {
                                id: i,
                                frag: o,
                                details: m,
                                samples: h.samples
                            };
                            r.trigger(me.FRAG_PARSING_METADATA, e)
                        }
                        if (m && u) {
                            const e = {
                                id: i,
                                frag: o,
                                details: m,
                                samples: u.samples
                            };
                            r.trigger(me.FRAG_PARSING_USERDATA, e)
                        }
                    }
                }
                _bufferInitSegment(e, t, i, r) {
                    if (this.state !== Br) return;
                    this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio;
                    const {
                        audio: n,
                        video: s,
                        audiovideo: a
                    } = t;
                    if (n) {
                        let t = e.audioCodec;
                        const i = navigator.userAgent.toLowerCase();
                        this.audioCodecSwitch && (t && (t = -1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== n.metadata.channelCount && -1 === i.indexOf("firefox") && (t = "mp4a.40.5")), -1 !== i.indexOf("android") && "audio/mpeg" !== n.container && (t = "mp4a.40.2", this.log(`Android: force audio codec to ${t}`)), e.audioCodec && e.audioCodec !== t && this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${t}"`), n.levelCodec = t, n.id = "main", this.log(`Init audio buffer, container:${n.container}, codecs[selected/level/parsed]=[${t||""}/${e.audioCodec||""}/${n.codec}]`)
                    }
                    s && (s.levelCodec = e.videoCodec, s.id = "main", this.log(`Init video buffer, container:${s.container}, codecs[level/parsed]=[${e.videoCodec||""}/${s.codec}]`)), a && this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.attrs.CODECS||""}/${a.codec}]`), this.hls.trigger(me.BUFFER_CODECS, t), Object.keys(t).forEach((e => {
                        const n = t[e].initSegment;
                        null != n && n.byteLength && this.hls.trigger(me.BUFFER_APPENDING, {
                            type: e,
                            data: n,
                            frag: i,
                            part: null,
                            chunkMeta: r,
                            parent: i.type
                        })
                    })), this.tick()
                }
                getMainFwdBufferInfo() {
                    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, ai)
                }
                backtrack(e) {
                    this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = xr
                }
                checkFragmentChanged() {
                    const e = this.media;
                    let t = null;
                    if (e && e.readyState > 1 && !1 === e.seeking) {
                        const i = e.currentTime;
                        if (Tr.isBuffered(e, i) ? t = this.getAppendedFrag(i) : Tr.isBuffered(e, i + .1) && (t = this.getAppendedFrag(i + .1)), t) {
                            this.backtrackFragment = null;
                            const e = this.fragPlaying,
                                i = t.level;
                            e && t.sn === e.sn && e.level === i && t.urlId === e.urlId || (this.fragPlaying = t, this.hls.trigger(me.FRAG_CHANGED, {
                                frag: t
                            }), e && e.level === i || this.hls.trigger(me.LEVEL_SWITCHED, {
                                level: i
                            }))
                        }
                    }
                }
                get nextLevel() {
                    const e = this.nextBufferedFrag;
                    return e ? e.level : -1
                }
                get currentFrag() {
                    const e = this.media;
                    return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null
                }
                get currentProgramDateTime() {
                    const e = this.media;
                    if (e) {
                        const t = e.currentTime,
                            i = this.currentFrag;
                        if (i && ue(t) && ue(i.programDateTime)) {
                            const e = i.programDateTime + 1e3 * (t - i.start);
                            return new Date(e)
                        }
                    }
                    return null
                }
                get currentLevel() {
                    const e = this.currentFrag;
                    return e ? e.level : -1
                }
                get nextBufferedFrag() {
                    const e = this.currentFrag;
                    return e ? this.followingBufferedFrag(e) : null
                }
                get forceStartLoad() {
                    return this._forceStartLoad
                }
            }
            class Zn {
                constructor(e, t = 0, i = 0) {
                    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = i
                }
                sample(e, t) {
                    const i = Math.pow(this.alpha_, e);
                    this.estimate_ = t * (1 - i) + i * this.estimate_, this.totalWeight_ += e
                }
                getTotalWeight() {
                    return this.totalWeight_
                }
                getEstimate() {
                    if (this.alpha_) {
                        const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
                        if (e) return this.estimate_ / e
                    }
                    return this.estimate_
                }
            }
            class es {
                constructor(e, t, i, r = 100) {
                    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = i, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new Zn(e), this.fast_ = new Zn(t), this.defaultTTFB_ = r, this.ttfb_ = new Zn(e)
                }
                update(e, t) {
                    const {
                        slow_: i,
                        fast_: r,
                        ttfb_: n
                    } = this;
                    i.halfLife !== e && (this.slow_ = new Zn(e, i.getEstimate(), i.getTotalWeight())), r.halfLife !== t && (this.fast_ = new Zn(t, r.getEstimate(), r.getTotalWeight())), n.halfLife !== e && (this.ttfb_ = new Zn(e, n.getEstimate(), n.getTotalWeight()))
                }
                sample(e, t) {
                    const i = (e = Math.max(e, this.minDelayMs_)) / 1e3,
                        r = 8 * t / i;
                    this.fast_.sample(i, r), this.slow_.sample(i, r)
                }
                sampleTTFB(e) {
                    const t = e / 1e3,
                        i = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
                    this.ttfb_.sample(i, Math.max(e, 5))
                }
                canEstimate() {
                    return this.fast_.getTotalWeight() >= this.minWeight_
                }
                getEstimate() {
                    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
                }
                getEstimateTTFB() {
                    return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
                }
                destroy() {}
            }
            class ts {
                constructor() {
                    this.chunks = [], this.dataLength = 0
                }
                push(e) {
                    this.chunks.push(e), this.dataLength += e.length
                }
                flush() {
                    const {
                        chunks: e,
                        dataLength: t
                    } = this;
                    let i;
                    return e.length ? (i = 1 === e.length ? e[0] : function(e, t) {
                        const i = new Uint8Array(t);
                        let r = 0;
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            i.set(n, r), r += n.length
                        }
                        return i
                    }(e, t), this.reset(), i) : new Uint8Array(0)
                }
                reset() {
                    this.chunks.length = 0, this.dataLength = 0
                }
            }

            function is(e, t) {
                if (e.length !== t.length) return !1;
                for (let i = 0; i < e.length; i++)
                    if (!rs(e[i].attrs, t[i].attrs)) return !1;
                return !0
            }

            function rs(e, t) {
                const i = e["STABLE-RENDITION-ID"];
                return i ? i === t["STABLE-RENDITION-ID"] : !["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED"].some((i => e[i] !== t[i]))
            }
            class ns {
                constructor(e) {
                    this.buffered = void 0;
                    const t = (t, i, r) => {
                        if ((i >>>= 0) > r - 1) throw new DOMException(`Failed to execute '${t}' on 'TimeRanges': The index provided (${i}) is greater than the maximum bound (${r})`);
                        return e[i][t]
                    };
                    this.buffered = {
                        get length() {
                            return e.length
                        },
                        end: i => t("end", i, e.length),
                        start: i => t("start", i, e.length)
                    }
                }
            }

            function ss(e) {
                const t = [];
                for (let i = 0; i < e.length; i++) {
                    const r = e[i];
                    "subtitles" !== r.kind && "captions" !== r.kind || !r.label || t.push(e[i])
                }
                return t
            }
            class as {
                constructor(e) {
                    this.buffers = void 0, this.queues = {
                        video: [],
                        audio: [],
                        audiovideo: []
                    }, this.buffers = e
                }
                append(e, t) {
                    const i = this.queues[t];
                    i.push(e), 1 === i.length && this.buffers[t] && this.executeNext(t)
                }
                insertAbort(e, t) {
                    this.queues[t].unshift(e), this.executeNext(t)
                }
                appendBlocker(e) {
                    let t;
                    const i = new Promise((e => {
                            t = e
                        })),
                        r = {
                            execute: t,
                            onStart: () => {},
                            onComplete: () => {},
                            onError: () => {}
                        };
                    return this.append(r, e), i
                }
                executeNext(e) {
                    const {
                        buffers: t,
                        queues: i
                    } = this, r = t[e], n = i[e];
                    if (n.length) {
                        const t = n[0];
                        try {
                            t.execute()
                        } catch (i) {
                            Ee.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), t.onError(i), null != r && r.updating || (n.shift(), this.executeNext(e))
                        }
                    }
                }
                shiftAndExecuteNext(e) {
                    this.queues[e].shift(), this.executeNext(e)
                }
                current(e) {
                    return this.queues[e][0]
                }
            }
            const os = Ut(),
                ls = /([ha]vc.)(?:\.[^.,]+)+/;
            const cs = {
                    42: 225,
                    92: 233,
                    94: 237,
                    95: 243,
                    96: 250,
                    123: 231,
                    124: 247,
                    125: 209,
                    126: 241,
                    127: 9608,
                    128: 174,
                    129: 176,
                    130: 189,
                    131: 191,
                    132: 8482,
                    133: 162,
                    134: 163,
                    135: 9834,
                    136: 224,
                    137: 32,
                    138: 232,
                    139: 226,
                    140: 234,
                    141: 238,
                    142: 244,
                    143: 251,
                    144: 193,
                    145: 201,
                    146: 211,
                    147: 218,
                    148: 220,
                    149: 252,
                    150: 8216,
                    151: 161,
                    152: 42,
                    153: 8217,
                    154: 9473,
                    155: 169,
                    156: 8480,
                    157: 8226,
                    158: 8220,
                    159: 8221,
                    160: 192,
                    161: 194,
                    162: 199,
                    163: 200,
                    164: 202,
                    165: 203,
                    166: 235,
                    167: 206,
                    168: 207,
                    169: 239,
                    170: 212,
                    171: 217,
                    172: 249,
                    173: 219,
                    174: 171,
                    175: 187,
                    176: 195,
                    177: 227,
                    178: 205,
                    179: 204,
                    180: 236,
                    181: 210,
                    182: 242,
                    183: 213,
                    184: 245,
                    185: 123,
                    186: 125,
                    187: 92,
                    188: 94,
                    189: 95,
                    190: 124,
                    191: 8764,
                    192: 196,
                    193: 228,
                    194: 214,
                    195: 246,
                    196: 223,
                    197: 165,
                    198: 164,
                    199: 9475,
                    200: 197,
                    201: 229,
                    202: 216,
                    203: 248,
                    204: 9487,
                    205: 9491,
                    206: 9495,
                    207: 9499
                },
                ds = function(e) {
                    let t = e;
                    return cs.hasOwnProperty(e) && (t = cs[e]), String.fromCharCode(t)
                },
                us = 15,
                hs = 100,
                fs = {
                    17: 1,
                    18: 3,
                    21: 5,
                    22: 7,
                    23: 9,
                    16: 11,
                    19: 12,
                    20: 14
                },
                ms = {
                    17: 2,
                    18: 4,
                    21: 6,
                    22: 8,
                    23: 10,
                    19: 13,
                    20: 15
                },
                ps = {
                    25: 1,
                    26: 3,
                    29: 5,
                    30: 7,
                    31: 9,
                    24: 11,
                    27: 12,
                    28: 14
                },
                gs = {
                    25: 2,
                    26: 4,
                    29: 6,
                    30: 8,
                    31: 10,
                    27: 13,
                    28: 15
                },
                ys = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
            class vs {
                constructor() {
                    this.time = null, this.verboseLevel = 0
                }
                log(e, t) {
                    if (this.verboseLevel >= e) {
                        const i = "function" == typeof t ? t() : t;
                        Ee.log(`${this.time} [${e}] ${i}`)
                    }
                }
            }
            const bs = function(e) {
                const t = [];
                for (let i = 0; i < e.length; i++) t.push(e[i].toString(16));
                return t
            };
            class Ts {
                constructor(e, t, i, r, n) {
                    this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || "white", this.underline = t || !1, this.italics = i || !1, this.background = r || "black", this.flash = n || !1
                }
                reset() {
                    this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
                }
                setStyles(e) {
                    const t = ["foreground", "underline", "italics", "background", "flash"];
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        e.hasOwnProperty(r) && (this[r] = e[r])
                    }
                }
                isDefault() {
                    return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
                }
                equals(e) {
                    return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
                }
                copy(e) {
                    this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash
                }
                toString() {
                    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
                }
            }
            class Es {
                constructor(e, t, i, r, n, s) {
                    this.uchar = void 0, this.penState = void 0, this.uchar = e || " ", this.penState = new Ts(t, i, r, n, s)
                }
                reset() {
                    this.uchar = " ", this.penState.reset()
                }
                setChar(e, t) {
                    this.uchar = e, this.penState.copy(t)
                }
                setPenState(e) {
                    this.penState.copy(e)
                }
                equals(e) {
                    return this.uchar === e.uchar && this.penState.equals(e.penState)
                }
                copy(e) {
                    this.uchar = e.uchar, this.penState.copy(e.penState)
                }
                isEmpty() {
                    return " " === this.uchar && this.penState.isDefault()
                }
            }
            class As {
                constructor(e) {
                    this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
                    for (let e = 0; e < hs; e++) this.chars.push(new Es);
                    this.logger = e, this.pos = 0, this.currPenState = new Ts
                }
                equals(e) {
                    let t = !0;
                    for (let i = 0; i < hs; i++)
                        if (!this.chars[i].equals(e.chars[i])) {
                            t = !1;
                            break
                        }
                    return t
                }
                copy(e) {
                    for (let t = 0; t < hs; t++) this.chars[t].copy(e.chars[t])
                }
                isEmpty() {
                    let e = !0;
                    for (let t = 0; t < hs; t++)
                        if (!this.chars[t].isEmpty()) {
                            e = !1;
                            break
                        }
                    return e
                }
                setCursor(e) {
                    this.pos !== e && (this.pos = e), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > hs && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = hs)
                }
                moveCursor(e) {
                    const t = this.pos + e;
                    if (e > 1)
                        for (let e = this.pos + 1; e < t + 1; e++) this.chars[e].setPenState(this.currPenState);
                    this.setCursor(t)
                }
                backSpace() {
                    this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
                }
                insertChar(e) {
                    e >= 144 && this.backSpace();
                    const t = ds(e);
                    this.pos >= hs ? this.logger.log(0, (() => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!")) : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1))
                }
                clearFromPos(e) {
                    let t;
                    for (t = e; t < hs; t++) this.chars[t].reset()
                }
                clear() {
                    this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
                }
                clearToEndOfRow() {
                    this.clearFromPos(this.pos)
                }
                getTextString() {
                    const e = [];
                    let t = !0;
                    for (let i = 0; i < hs; i++) {
                        const r = this.chars[i].uchar;
                        " " !== r && (t = !1), e.push(r)
                    }
                    return t ? "" : e.join("")
                }
                setPenStyles(e) {
                    this.currPenState.setStyles(e);
                    this.chars[this.pos].setPenState(this.currPenState)
                }
            }
            class ws {
                constructor(e) {
                    this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
                    for (let t = 0; t < us; t++) this.rows.push(new As(e));
                    this.logger = e, this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset()
                }
                reset() {
                    for (let e = 0; e < us; e++) this.rows[e].clear();
                    this.currRow = 14
                }
                equals(e) {
                    let t = !0;
                    for (let i = 0; i < us; i++)
                        if (!this.rows[i].equals(e.rows[i])) {
                            t = !1;
                            break
                        }
                    return t
                }
                copy(e) {
                    for (let t = 0; t < us; t++) this.rows[t].copy(e.rows[t])
                }
                isEmpty() {
                    let e = !0;
                    for (let t = 0; t < us; t++)
                        if (!this.rows[t].isEmpty()) {
                            e = !1;
                            break
                        }
                    return e
                }
                backSpace() {
                    this.rows[this.currRow].backSpace()
                }
                clearToEndOfRow() {
                    this.rows[this.currRow].clearToEndOfRow()
                }
                insertChar(e) {
                    this.rows[this.currRow].insertChar(e)
                }
                setPen(e) {
                    this.rows[this.currRow].setPenStyles(e)
                }
                moveCursor(e) {
                    this.rows[this.currRow].moveCursor(e)
                }
                setCursor(e) {
                    this.logger.log(2, "setCursor: " + e);
                    this.rows[this.currRow].setCursor(e)
                }
                setPAC(e) {
                    this.logger.log(2, (() => "pacData = " + JSON.stringify(e)));
                    let t = e.row - 1;
                    if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) {
                        for (let e = 0; e < us; e++) this.rows[e].clear();
                        const e = this.currRow + 1 - this.nrRollUpRows,
                            i = this.lastOutputScreen;
                        if (i) {
                            const r = i.rows[e].cueStartTime,
                                n = this.logger.time;
                            if (r && null !== n && r < n)
                                for (let r = 0; r < this.nrRollUpRows; r++) this.rows[t - this.nrRollUpRows + r + 1].copy(i.rows[e + r])
                        }
                    }
                    this.currRow = t;
                    const i = this.rows[this.currRow];
                    if (null !== e.indent) {
                        const t = e.indent,
                            r = Math.max(t - 1, 0);
                        i.setCursor(e.indent), e.color = i.chars[r].penState.foreground
                    }
                    const r = {
                        foreground: e.color,
                        underline: e.underline,
                        italics: e.italics,
                        background: "black",
                        flash: !1
                    };
                    this.setPen(r)
                }
                setBkgData(e) {
                    this.logger.log(2, (() => "bkgData = " + JSON.stringify(e))), this.backSpace(), this.setPen(e), this.insertChar(32)
                }
                setRollUpRows(e) {
                    this.nrRollUpRows = e
                }
                rollUp() {
                    if (null === this.nrRollUpRows) return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
                    this.logger.log(1, (() => this.getDisplayText()));
                    const e = this.currRow + 1 - this.nrRollUpRows,
                        t = this.rows.splice(e, 1)[0];
                    t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, "Rolling up")
                }
                getDisplayText(e) {
                    e = e || !1;
                    const t = [];
                    let i = "",
                        r = -1;
                    for (let i = 0; i < us; i++) {
                        const n = this.rows[i].getTextString();
                        n && (r = i + 1, e ? t.push("Row " + r + ": '" + n + "'") : t.push(n.trim()))
                    }
                    return t.length > 0 && (i = e ? "[" + t.join(" | ") + "]" : t.join("\n")), i
                }
                getTextAndFormat() {
                    return this.rows
                }
            }
            class _s {
                constructor(e, t, i) {
                    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new ws(i), this.nonDisplayedMemory = new ws(i), this.lastOutputScreen = new ws(i), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = i
                }
                reset() {
                    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
                }
                getHandler() {
                    return this.outputFilter
                }
                setHandler(e) {
                    this.outputFilter = e
                }
                setPAC(e) {
                    this.writeScreen.setPAC(e)
                }
                setBkgData(e) {
                    this.writeScreen.setBkgData(e)
                }
                setMode(e) {
                    e !== this.mode && (this.mode = e, this.logger.log(2, (() => "MODE=" + e)), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e)
                }
                insertChars(e) {
                    for (let t = 0; t < e.length; t++) this.writeScreen.insertChar(e[t]);
                    const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                    this.logger.log(2, (() => t + ": " + this.writeScreen.getDisplayText(!0))), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(1, (() => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0))), this.outputDataUpdate())
                }
                ccRCL() {
                    this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
                }
                ccBS() {
                    this.logger.log(2, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
                }
                ccAOF() {}
                ccAON() {}
                ccDER() {
                    this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
                }
                ccRU(e) {
                    this.logger.log(2, "RU(" + e + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(e)
                }
                ccFON() {
                    this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({
                        flash: !0
                    })
                }
                ccRDC() {
                    this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
                }
                ccTR() {
                    this.logger.log(2, "TR"), this.setMode("MODE_TEXT")
                }
                ccRTD() {
                    this.logger.log(2, "RTD"), this.setMode("MODE_TEXT")
                }
                ccEDM() {
                    this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
                }
                ccCR() {
                    this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
                }
                ccENM() {
                    this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
                }
                ccEOC() {
                    if (this.logger.log(2, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
                        const e = this.displayedMemory;
                        this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, (() => "DISP: " + this.displayedMemory.getDisplayText()))
                    }
                    this.outputDataUpdate(!0)
                }
                ccTO(e) {
                    this.logger.log(2, "TO(" + e + ") - Tab Offset"), this.writeScreen.moveCursor(e)
                }
                ccMIDROW(e) {
                    const t = {
                        flash: !1
                    };
                    if (t.underline = e % 2 == 1, t.italics = e >= 46, t.italics) t.foreground = "white";
                    else {
                        const i = Math.floor(e / 2) - 16,
                            r = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                        t.foreground = r[i]
                    }
                    this.logger.log(2, "MIDROW: " + JSON.stringify(t)), this.writeScreen.setPen(t)
                }
                outputDataUpdate(e = !1) {
                    const t = this.logger.time;
                    null !== t && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory))
                }
                cueSplitAtTime(e) {
                    this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e))
                }
            }
            class ks {
                constructor(e, t, i) {
                    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
                    const r = new vs;
                    this.channels = [null, new _s(e, t, r), new _s(e + 1, i, r)], this.cmdHistory = {
                        a: null,
                        b: null
                    }, this.logger = r
                }
                getHandler(e) {
                    return this.channels[e].getHandler()
                }
                setHandler(e, t) {
                    this.channels[e].setHandler(t)
                }
                addData(e, t) {
                    let i, r, n, s = !1;
                    this.logger.time = e;
                    for (let e = 0; e < t.length; e += 2)
                        if (r = 127 & t[e], n = 127 & t[e + 1], 0 !== r || 0 !== n) {
                            if (this.logger.log(3, "[" + bs([t[e], t[e + 1]]) + "] -> (" + bs([r, n]) + ")"), i = this.parseCmd(r, n), i || (i = this.parseMidrow(r, n)), i || (i = this.parsePAC(r, n)), i || (i = this.parseBackgroundAttributes(r, n)), !i && (s = this.parseChars(r, n), s)) {
                                const e = this.currentChannel;
                                if (e && e > 0) {
                                    this.channels[e].insertChars(s)
                                } else this.logger.log(2, "No channel found yet. TEXT-MODE?")
                            }
                            i || s || this.logger.log(2, "Couldn't parse cleaned data " + bs([r, n]) + " orig: " + bs([t[e], t[e + 1]]))
                        }
                }
                parseCmd(e, t) {
                    const {
                        cmdHistory: i
                    } = this;
                    if (!((20 === e || 28 === e || 21 === e || 29 === e) && t >= 32 && t <= 47) && !((23 === e || 31 === e) && t >= 33 && t <= 35)) return !1;
                    if (Ls(e, t, i)) return Ss(null, null, i), this.logger.log(3, "Repeated command (" + bs([e, t]) + ") is dropped"), !0;
                    const r = 20 === e || 21 === e || 23 === e ? 1 : 2,
                        n = this.channels[r];
                    return 20 === e || 21 === e || 28 === e || 29 === e ? 32 === t ? n.ccRCL() : 33 === t ? n.ccBS() : 34 === t ? n.ccAOF() : 35 === t ? n.ccAON() : 36 === t ? n.ccDER() : 37 === t ? n.ccRU(2) : 38 === t ? n.ccRU(3) : 39 === t ? n.ccRU(4) : 40 === t ? n.ccFON() : 41 === t ? n.ccRDC() : 42 === t ? n.ccTR() : 43 === t ? n.ccRTD() : 44 === t ? n.ccEDM() : 45 === t ? n.ccCR() : 46 === t ? n.ccENM() : 47 === t && n.ccEOC() : n.ccTO(t - 32), Ss(e, t, i), this.currentChannel = r, !0
                }
                parseMidrow(e, t) {
                    let i = 0;
                    if ((17 === e || 25 === e) && t >= 32 && t <= 47) {
                        if (i = 17 === e ? 1 : 2, i !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
                        const r = this.channels[i];
                        return !!r && (r.ccMIDROW(t), this.logger.log(3, "MIDROW (" + bs([e, t]) + ")"), !0)
                    }
                    return !1
                }
                parsePAC(e, t) {
                    let i;
                    const r = this.cmdHistory;
                    if (!((e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127) && !((16 === e || 24 === e) && t >= 64 && t <= 95)) return !1;
                    if (Ls(e, t, r)) return Ss(null, null, r), !0;
                    const n = e <= 23 ? 1 : 2;
                    i = t >= 64 && t <= 95 ? 1 === n ? fs[e] : ps[e] : 1 === n ? ms[e] : gs[e];
                    const s = this.channels[n];
                    return !!s && (s.setPAC(this.interpretPAC(i, t)), Ss(e, t, r), this.currentChannel = n, !0)
                }
                interpretPAC(e, t) {
                    let i;
                    const r = {
                        color: null,
                        italics: !1,
                        indent: null,
                        underline: !1,
                        row: e
                    };
                    return i = t > 95 ? t - 96 : t - 64, r.underline = !(1 & ~i), i <= 13 ? r.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(i / 2)] : i <= 15 ? (r.italics = !0, r.color = "white") : r.indent = 4 * Math.floor((i - 16) / 2), r
                }
                parseChars(e, t) {
                    let i, r = null,
                        n = null;
                    if (e >= 25 ? (i = 2, n = e - 8) : (i = 1, n = e), n >= 17 && n <= 19) {
                        let e;
                        e = 17 === n ? t + 80 : 18 === n ? t + 112 : t + 144, this.logger.log(2, "Special char '" + ds(e) + "' in channel " + i), r = [e]
                    } else e >= 32 && e <= 127 && (r = 0 === t ? [e] : [e, t]);
                    if (r) {
                        const i = bs(r);
                        this.logger.log(3, "Char codes =  " + i.join(",")), Ss(e, t, this.cmdHistory)
                    }
                    return r
                }
                parseBackgroundAttributes(e, t) {
                    if (!((16 === e || 24 === e) && t >= 32 && t <= 47) && !((23 === e || 31 === e) && t >= 45 && t <= 47)) return !1;
                    let i;
                    const r = {};
                    16 === e || 24 === e ? (i = Math.floor((t - 32) / 2), r.background = ys[i], t % 2 == 1 && (r.background = r.background + "_semi")) : 45 === t ? r.background = "transparent" : (r.foreground = "black", 47 === t && (r.underline = !0));
                    const n = e <= 23 ? 1 : 2;
                    return this.channels[n].setBkgData(r), Ss(e, t, this.cmdHistory), !0
                }
                reset() {
                    for (let e = 0; e < Object.keys(this.channels).length; e++) {
                        const t = this.channels[e];
                        t && t.reset()
                    }
                    this.cmdHistory = {
                        a: null,
                        b: null
                    }
                }
                cueSplitAtTime(e) {
                    for (let t = 0; t < this.channels.length; t++) {
                        const i = this.channels[t];
                        i && i.cueSplitAtTime(e)
                    }
                }
            }

            function Ss(e, t, i) {
                i.a = e, i.b = t
            }

            function Ls(e, t, i) {
                return i.a === e && i.b === t
            }
            class Rs {
                constructor(e, t) {
                    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t
                }
                dispatchCue() {
                    null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
                }
                newCue(e, t, i) {
                    (null === this.startTime || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = i, this.timelineController.createCaptionsTrack(this.trackName)
                }
                reset() {
                    this.cueRanges = [], this.startTime = null
                }
            }
            var Ds = function() {
                if ("undefined" != typeof self && self.VTTCue) return self.VTTCue;
                const e = ["", "lr", "rl"],
                    t = ["start", "middle", "end", "left", "right"];

                function i(e, t) {
                    if ("string" != typeof t) return !1;
                    if (!Array.isArray(e)) return !1;
                    const i = t.toLowerCase();
                    return !!~e.indexOf(i) && i
                }

                function r(e) {
                    return i(t, e)
                }

                function n(e, ...t) {
                    let i = 1;
                    for (; i < arguments.length; i++) {
                        const t = arguments[i];
                        for (const i in t) e[i] = t[i]
                    }
                    return e
                }

                function s(t, s, a) {
                    const o = this,
                        l = {
                            enumerable: !0
                        };
                    o.hasBeenReset = !1;
                    let c = "",
                        d = !1,
                        u = t,
                        h = s,
                        f = a,
                        m = null,
                        p = "",
                        g = !0,
                        y = "auto",
                        v = "start",
                        b = 50,
                        T = "middle",
                        E = 50,
                        A = "middle";
                    Object.defineProperty(o, "id", n({}, l, {
                        get: function() {
                            return c
                        },
                        set: function(e) {
                            c = "" + e
                        }
                    })), Object.defineProperty(o, "pauseOnExit", n({}, l, {
                        get: function() {
                            return d
                        },
                        set: function(e) {
                            d = !!e
                        }
                    })), Object.defineProperty(o, "startTime", n({}, l, {
                        get: function() {
                            return u
                        },
                        set: function(e) {
                            if ("number" != typeof e) throw new TypeError("Start time must be set to a number.");
                            u = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "endTime", n({}, l, {
                        get: function() {
                            return h
                        },
                        set: function(e) {
                            if ("number" != typeof e) throw new TypeError("End time must be set to a number.");
                            h = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "text", n({}, l, {
                        get: function() {
                            return f
                        },
                        set: function(e) {
                            f = "" + e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "region", n({}, l, {
                        get: function() {
                            return m
                        },
                        set: function(e) {
                            m = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "vertical", n({}, l, {
                        get: function() {
                            return p
                        },
                        set: function(t) {
                            const r = function(t) {
                                return i(e, t)
                            }(t);
                            if (!1 === r) throw new SyntaxError("An invalid or illegal string was specified.");
                            p = r, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "snapToLines", n({}, l, {
                        get: function() {
                            return g
                        },
                        set: function(e) {
                            g = !!e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "line", n({}, l, {
                        get: function() {
                            return y
                        },
                        set: function(e) {
                            if ("number" != typeof e && "auto" !== e) throw new SyntaxError("An invalid number or illegal string was specified.");
                            y = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "lineAlign", n({}, l, {
                        get: function() {
                            return v
                        },
                        set: function(e) {
                            const t = r(e);
                            if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
                            v = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "position", n({}, l, {
                        get: function() {
                            return b
                        },
                        set: function(e) {
                            if (e < 0 || e > 100) throw new Error("Position must be between 0 and 100.");
                            b = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "positionAlign", n({}, l, {
                        get: function() {
                            return T
                        },
                        set: function(e) {
                            const t = r(e);
                            if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
                            T = t, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "size", n({}, l, {
                        get: function() {
                            return E
                        },
                        set: function(e) {
                            if (e < 0 || e > 100) throw new Error("Size must be between 0 and 100.");
                            E = e, this.hasBeenReset = !0
                        }
                    })), Object.defineProperty(o, "align", n({}, l, {
                        get: function() {
                            return A
                        },
                        set: function(e) {
                            const t = r(e);
                            if (!t) throw new SyntaxError("An invalid or illegal string was specified.");
                            A = t, this.hasBeenReset = !0
                        }
                    })), o.displayState = void 0
                }
                return s.prototype.getCueAsHTML = function() {
                    return self.WebVTT.convertCueToDOMTree(self, this.text)
                }, s
            }();
            class Cs {
                decode(e, t) {
                    if (!e) return "";
                    if ("string" != typeof e) throw new Error("Error - expected string data.");
                    return decodeURIComponent(encodeURIComponent(e))
                }
            }

            function Is(e) {
                function t(e, t, i, r) {
                    return 3600 * (0 | e) + 60 * (0 | t) + (0 | i) + parseFloat(r || 0)
                }
                const i = e.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
                return i ? parseFloat(i[2]) > 59 ? t(i[2], i[3], 0, i[4]) : t(i[1], i[2], i[3], i[4]) : null
            }
            class Ps {
                constructor() {
                    this.values = Object.create(null)
                }
                set(e, t) {
                    this.get(e) || "" === t || (this.values[e] = t)
                }
                get(e, t, i) {
                    return i ? this.has(e) ? this.values[e] : t[i] : this.has(e) ? this.values[e] : t
                }
                has(e) {
                    return e in this.values
                }
                alt(e, t, i) {
                    for (let r = 0; r < i.length; ++r)
                        if (t === i[r]) {
                            this.set(e, t);
                            break
                        }
                }
                integer(e, t) {
                    /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
                }
                percent(e, t) {
                    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
                        const i = parseFloat(t);
                        if (i >= 0 && i <= 100) return this.set(e, i), !0
                    }
                    return !1
                }
            }

            function xs(e, t, i, r) {
                const n = r ? e.split(r) : [e];
                for (const e in n) {
                    if ("string" != typeof n[e]) continue;
                    const r = n[e].split(i);
                    if (2 !== r.length) continue;
                    t(r[0], r[1])
                }
            }
            const Os = new Ds(0, 0, ""),
                Ms = "middle" === Os.align ? "middle" : "center";

            function Ns(e, t, i) {
                const r = e;

                function n() {
                    const t = Is(e);
                    if (null === t) throw new Error("Malformed timestamp: " + r);
                    return e = e.replace(/^[^\sa-zA-Z-]+/, ""), t
                }

                function s() {
                    e = e.replace(/^\s+/, "")
                }
                if (s(), t.startTime = n(), s(), "--\x3e" !== e.slice(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + r);
                e = e.slice(3), s(), t.endTime = n(), s(),
                    function(e, t) {
                        const r = new Ps;
                        xs(e, (function(e, t) {
                            let n;
                            switch (e) {
                                case "region":
                                    for (let n = i.length - 1; n >= 0; n--)
                                        if (i[n].id === t) {
                                            r.set(e, i[n].region);
                                            break
                                        }
                                    break;
                                case "vertical":
                                    r.alt(e, t, ["rl", "lr"]);
                                    break;
                                case "line":
                                    n = t.split(","), r.integer(e, n[0]), r.percent(e, n[0]) && r.set("snapToLines", !1), r.alt(e, n[0], ["auto"]), 2 === n.length && r.alt("lineAlign", n[1], ["start", Ms, "end"]);
                                    break;
                                case "position":
                                    n = t.split(","), r.percent(e, n[0]), 2 === n.length && r.alt("positionAlign", n[1], ["start", Ms, "end", "line-left", "line-right", "auto"]);
                                    break;
                                case "size":
                                    r.percent(e, t);
                                    break;
                                case "align":
                                    r.alt(e, t, ["start", Ms, "end", "left", "right"])
                            }
                        }), /:/, /\s/), t.region = r.get("region", null), t.vertical = r.get("vertical", "");
                        let n = r.get("line", "auto");
                        "auto" === n && -1 === Os.line && (n = -1), t.line = n, t.lineAlign = r.get("lineAlign", "start"), t.snapToLines = r.get("snapToLines", !0), t.size = r.get("size", 100), t.align = r.get("align", Ms);
                        let s = r.get("position", "auto");
                        "auto" === s && 50 === Os.position && (s = "start" === t.align || "left" === t.align ? 0 : "end" === t.align || "right" === t.align ? 100 : 50), t.position = s
                    }(e, t)
            }

            function Fs(e) {
                return e.replace(/<br(?: \/)?>/gi, "\n")
            }
            class Bs {
                constructor() {
                    this.state = "INITIAL", this.buffer = "", this.decoder = new Cs, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
                }
                parse(e) {
                    const t = this;

                    function i() {
                        let e = t.buffer,
                            i = 0;
                        for (e = Fs(e); i < e.length && "\r" !== e[i] && "\n" !== e[i];) ++i;
                        const r = e.slice(0, i);
                        return "\r" === e[i] && ++i, "\n" === e[i] && ++i, t.buffer = e.slice(i), r
                    }
                    e && (t.buffer += t.decoder.decode(e, {
                        stream: !0
                    }));
                    try {
                        let e = "";
                        if ("INITIAL" === t.state) {
                            if (!/\r\n|\n/.test(t.buffer)) return this;
                            e = i();
                            const r = e.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                            if (null == r || !r[0]) throw new Error("Malformed WebVTT signature.");
                            t.state = "HEADER"
                        }
                        let r = !1;
                        for (; t.buffer;) {
                            if (!/\r\n|\n/.test(t.buffer)) return this;
                            switch (r ? r = !1 : e = i(), t.state) {
                                case "HEADER":
                                    /:/.test(e) ? xs(e, (function(e, t) {}), /:/) : e || (t.state = "ID");
                                    continue;
                                case "NOTE":
                                    e || (t.state = "ID");
                                    continue;
                                case "ID":
                                    if (/^NOTE($|[ \t])/.test(e)) {
                                        t.state = "NOTE";
                                        break
                                    }
                                    if (!e) continue;
                                    if (t.cue = new Ds(0, 0, ""), t.state = "CUE", -1 === e.indexOf("--\x3e")) {
                                        t.cue.id = e;
                                        continue
                                    }
                                case "CUE":
                                    if (!t.cue) {
                                        t.state = "BADCUE";
                                        continue
                                    }
                                    try {
                                        Ns(e, t.cue, t.regionList)
                                    } catch (e) {
                                        t.cue = null, t.state = "BADCUE";
                                        continue
                                    }
                                    t.state = "CUETEXT";
                                    continue;
                                case "CUETEXT":
                                    {
                                        const i = -1 !== e.indexOf("--\x3e");
                                        if (!e || i && (r = !0)) {
                                            t.oncue && t.cue && t.oncue(t.cue), t.cue = null, t.state = "ID";
                                            continue
                                        }
                                        if (null === t.cue) continue;t.cue.text && (t.cue.text += "\n"),
                                        t.cue.text += e
                                    }
                                    continue;
                                case "BADCUE":
                                    e || (t.state = "ID")
                            }
                        }
                    } catch (e) {
                        "CUETEXT" === t.state && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = "INITIAL" === t.state ? "BADWEBVTT" : "BADCUE"
                    }
                    return this
                }
                flush() {
                    const e = this;
                    try {
                        if ((e.cue || "HEADER" === e.state) && (e.buffer += "\n\n", e.parse()), "INITIAL" === e.state || "BADWEBVTT" === e.state) throw new Error("Malformed WebVTT signature.")
                    } catch (t) {
                        e.onparsingerror && e.onparsingerror(t)
                    }
                    return e.onflush && e.onflush(), this
                }
            }
            const Us = /\r\n|\n\r|\n|\r/g,
                $s = function(e, t, i = 0) {
                    return e.slice(i, i + t.length) === t
                },
                Hs = function(e) {
                    let t = 5381,
                        i = e.length;
                    for (; i;) t = 33 * t ^ e.charCodeAt(--i);
                    return (t >>> 0).toString()
                };

            function js(e, t, i) {
                return Hs(e.toString()) + Hs(t.toString()) + Hs(i)
            }

            function Gs(e, t, i, r, n, s, a) {
                const o = new Bs,
                    l = lt(new Uint8Array(e)).trim().replace(Us, "\n").split("\n"),
                    c = [],
                    d = t ? function(e, t = 1) {
                        return Dn(e, Rn, 1 / t)
                    }(t.baseTime, t.timescale) : 0;
                let u, h = "00:00.000",
                    f = 0,
                    m = 0,
                    p = !0;
                o.oncue = function(e) {
                    const s = i[r];
                    let a = i.ccOffset;
                    const o = (f - d) / 9e4;
                    if (null != s && s.new && (void 0 !== m ? a = i.ccOffset = s.start : function(e, t, i) {
                            let r = e[t],
                                n = e[r.prevCC];
                            if (!n || !n.new && r.new) return e.ccOffset = e.presentationOffset = r.start, void(r.new = !1);
                            for (; null != (s = n) && s.new;) {
                                var s;
                                e.ccOffset += r.start - n.start, r.new = !1, r = n, n = e[r.prevCC]
                            }
                            e.presentationOffset = i
                        }(i, r, o)), o) {
                        if (!t) return void(u = new Error("Missing initPTS for VTT MPEGTS"));
                        a = o - i.presentationOffset
                    }
                    const l = e.endTime - e.startTime,
                        h = Mn(9e4 * (e.startTime + a - m), 9e4 * n) / 9e4;
                    e.startTime = Math.max(h, 0), e.endTime = Math.max(h + l, 0);
                    const p = e.text.trim();
                    e.text = decodeURIComponent(encodeURIComponent(p)), e.id || (e.id = js(e.startTime, e.endTime, p)), e.endTime > 0 && c.push(e)
                }, o.onparsingerror = function(e) {
                    u = e
                }, o.onflush = function() {
                    u ? a(u) : s(c)
                }, l.forEach((e => {
                    if (p) {
                        if ($s(e, "X-TIMESTAMP-MAP=")) {
                            p = !1, e.slice(16).split(",").forEach((e => {
                                $s(e, "LOCAL:") ? h = e.slice(6) : $s(e, "MPEGTS:") && (f = parseInt(e.slice(7)))
                            }));
                            try {
                                m = function(e) {
                                    let t = parseInt(e.slice(-3));
                                    const i = parseInt(e.slice(-6, -4)),
                                        r = parseInt(e.slice(-9, -7)),
                                        n = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
                                    if (!(ue(t) && ue(i) && ue(r) && ue(n))) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
                                    return t += 1e3 * i, t += 6e4 * r, t += 36e5 * n, t
                                }(h) / 1e3
                            } catch (e) {
                                u = e
                            }
                            return
                        }
                        "" === e && (p = !1)
                    }
                    o.parse(e + "\n")
                })), o.flush()
            }
            const Vs = "stpp.ttml.im1t",
                qs = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
                Ks = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
                Ws = {
                    left: "start",
                    center: "center",
                    right: "end",
                    start: "start",
                    end: "end"
                };

            function Ys(e, t, i, r) {
                const n = Tt(new Uint8Array(e), ["mdat"]);
                if (0 === n.length) return void r(new Error("Could not parse IMSC1 mdat"));
                const s = n.map((e => lt(e))),
                    a = function(e, t, i = 1, r = !1) {
                        return Dn(e, t, 1 / i, r)
                    }(t.baseTime, 1, t.timescale);
                try {
                    s.forEach((e => i(function(e, t) {
                        const i = (new DOMParser).parseFromString(e, "text/xml"),
                            r = i.getElementsByTagName("tt")[0];
                        if (!r) throw new Error("Invalid ttml");
                        const n = {
                                frameRate: 30,
                                subFrameRate: 1,
                                frameRateMultiplier: 0,
                                tickRate: 0
                            },
                            s = Object.keys(n).reduce(((e, t) => (e[t] = r.getAttribute(`ttp:${t}`) || n[t], e)), {}),
                            a = "preserve" !== r.getAttribute("xml:space"),
                            o = Xs(zs(r, "styling", "style")),
                            l = Xs(zs(r, "layout", "region")),
                            c = zs(r, "body", "[begin]");
                        return [].map.call(c, (e => {
                            const i = Qs(e, a);
                            if (!i || !e.hasAttribute("begin")) return null;
                            const r = ea(e.getAttribute("begin"), s),
                                n = ea(e.getAttribute("dur"), s);
                            let c = ea(e.getAttribute("end"), s);
                            if (null === r) throw Zs(e);
                            if (null === c) {
                                if (null === n) throw Zs(e);
                                c = r + n
                            }
                            const d = new Ds(r - t, c - t, i);
                            d.id = js(d.startTime, d.endTime, d.text);
                            const u = function(e, t, i) {
                                    const r = "http://www.w3.org/ns/ttml#styling";
                                    let n = null;
                                    const s = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"],
                                        a = null != e && e.hasAttribute("style") ? e.getAttribute("style") : null;
                                    a && i.hasOwnProperty(a) && (n = i[a]);
                                    return s.reduce(((i, s) => {
                                        const a = Js(t, r, s) || Js(e, r, s) || Js(n, r, s);
                                        return a && (i[s] = a), i
                                    }), {})
                                }(l[e.getAttribute("region")], o[e.getAttribute("style")], o),
                                {
                                    textAlign: h
                                } = u;
                            if (h) {
                                const e = Ws[h];
                                e && (d.lineAlign = e), d.align = h
                            }
                            return de(d, u), d
                        })).filter((e => null !== e))
                    }(e, a))))
                } catch (e) {
                    r(e)
                }
            }

            function zs(e, t, i) {
                const r = e.getElementsByTagName(t)[0];
                return r ? [].slice.call(r.querySelectorAll(i)) : []
            }

            function Xs(e) {
                return e.reduce(((e, t) => {
                    const i = t.getAttribute("xml:id");
                    return i && (e[i] = t), e
                }), {})
            }

            function Qs(e, t) {
                return [].slice.call(e.childNodes).reduce(((e, i, r) => {
                    var n;
                    return "br" === i.nodeName && r ? e + "\n" : null != (n = i.childNodes) && n.length ? Qs(i, t) : t ? e + i.textContent.trim().replace(/\s+/g, " ") : e + i.textContent
                }), "")
            }

            function Js(e, t, i) {
                return e && e.hasAttributeNS(t, i) ? e.getAttributeNS(t, i) : null
            }

            function Zs(e) {
                return new Error(`Could not parse ttml timestamp ${e}`)
            }

            function ea(e, t) {
                if (!e) return null;
                let i = Is(e);
                return null === i && (qs.test(e) ? i = function(e, t) {
                    const i = qs.exec(e),
                        r = (0 | i[4]) + (0 | i[5]) / t.subFrameRate;
                    return 3600 * (0 | i[1]) + 60 * (0 | i[2]) + (0 | i[3]) + r / t.frameRate
                }(e, t) : Ks.test(e) && (i = function(e, t) {
                    const i = Ks.exec(e),
                        r = Number(i[1]);
                    switch (i[2]) {
                        case "h":
                            return 3600 * r;
                        case "m":
                            return 60 * r;
                        case "ms":
                            return 1e3 * r;
                        case "f":
                            return r / t.frameRate;
                        case "t":
                            return r / t.tickRate
                    }
                    return r
                }(e, t))), i
            }

            function ta(e, t) {
                return !!e && e.label === t.name && !(e.textTrack1 || e.textTrack2)
            }
            class ia {
                constructor(e) {
                    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
                }
                setStreamController(e) {
                    this.streamController = e
                }
                destroy() {
                    this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
                }
                registerListeners() {
                    const {
                        hls: e
                    } = this;
                    e.on(me.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(me.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(me.MANIFEST_PARSED, this.onManifestParsed, this), e.on(me.BUFFER_CODECS, this.onBufferCodecs, this), e.on(me.MEDIA_DETACHING, this.onMediaDetaching, this)
                }
                unregisterListener() {
                    const {
                        hls: e
                    } = this;
                    e.off(me.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(me.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(me.MANIFEST_PARSED, this.onManifestParsed, this), e.off(me.BUFFER_CODECS, this.onBufferCodecs, this), e.off(me.MEDIA_DETACHING, this.onMediaDetaching, this)
                }
                onFpsDropLevelCapping(e, t) {
                    const i = this.hls.levels[t.droppedLevel];
                    this.isLevelAllowed(i) && this.restrictedLevels.push({
                        bitrate: i.bitrate,
                        height: i.height,
                        width: i.width
                    })
                }
                onMediaAttaching(e, t) {
                    this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null
                }
                onManifestParsed(e, t) {
                    const i = this.hls;
                    this.restrictedLevels = [], this.firstLevel = t.firstLevel, i.config.capLevelToPlayerSize && t.video && this.startCapping()
                }
                onBufferCodecs(e, t) {
                    this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
                }
                onMediaDetaching() {
                    this.stopCapping()
                }
                detectPlayerSize() {
                    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
                        const e = this.hls.levels;
                        if (e.length) {
                            const t = this.hls;
                            t.autoLevelCapping = this.getMaxLevel(e.length - 1), t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping
                        }
                    }
                }
                getMaxLevel(e) {
                    const t = this.hls.levels;
                    if (!t.length) return -1;
                    const i = t.filter(((t, i) => this.isLevelAllowed(t) && i <= e));
                    return this.clientRect = null, ia.getMaxLevelByMediaSize(i, this.mediaWidth, this.mediaHeight)
                }
                startCapping() {
                    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
                }
                stopCapping() {
                    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
                }
                getDimensions() {
                    if (this.clientRect) return this.clientRect;
                    const e = this.media,
                        t = {
                            width: 0,
                            height: 0
                        };
                    if (e) {
                        const i = e.getBoundingClientRect();
                        t.width = i.width, t.height = i.height, t.width || t.height || (t.width = i.right - i.left || e.width || 0, t.height = i.bottom - i.top || e.height || 0)
                    }
                    return this.clientRect = t, t
                }
                get mediaWidth() {
                    return this.getDimensions().width * this.contentScaleFactor
                }
                get mediaHeight() {
                    return this.getDimensions().height * this.contentScaleFactor
                }
                get contentScaleFactor() {
                    let e = 1;
                    if (!this.hls.config.ignoreDevicePixelRatio) try {
                        e = self.devicePixelRatio
                    } catch (e) {}
                    return e
                }
                isLevelAllowed(e) {
                    return !this.restrictedLevels.some((t => e.bitrate === t.bitrate && e.width === t.width && e.height === t.height))
                }
                static getMaxLevelByMediaSize(e, t, i) {
                    if (null == e || !e.length) return -1;
                    let r = e.length - 1;
                    for (let a = 0; a < e.length; a += 1) {
                        const o = e[a];
                        if ((o.width >= t || o.height >= i) && (n = o, !(s = e[a + 1]) || n.width !== s.width || n.height !== s.height)) {
                            r = a;
                            break
                        }
                    }
                    var n, s;
                    return r
                }
            }
            const ra = "[eme]";
            class na {
                constructor(e) {
                    this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = na.CDMCleanupPromise ? [na.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = Ee.debug.bind(Ee, ra), this.log = Ee.log.bind(Ee, ra), this.warn = Ee.warn.bind(Ee, ra), this.error = Ee.error.bind(Ee, ra), this.hls = e, this.config = e.config, this.registerListeners()
                }
                destroy() {
                    this.unregisterListeners(), this.onMediaDetached();
                    const e = this.config;
                    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null, this.config = null
                }
                registerListeners() {
                    this.hls.on(me.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(me.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(me.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(me.MANIFEST_LOADED, this.onManifestLoaded, this)
                }
                unregisterListeners() {
                    this.hls.off(me.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(me.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(me.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(me.MANIFEST_LOADED, this.onManifestLoaded, this)
                }
                getLicenseServerUrl(e) {
                    const {
                        drmSystems: t,
                        widevineLicenseUrl: i
                    } = this.config, r = t[e];
                    if (r) return r.licenseUrl;
                    if (e === Be.WIDEVINE && i) return i;
                    throw new Error(`no license server URL configured for key-system "${e}"`)
                }
                getServerCertificateUrl(e) {
                    const {
                        drmSystems: t
                    } = this.config, i = t[e];
                    if (i) return i.serverCertificateUrl;
                    this.log(`No Server Certificate in config.drmSystems["${e}"]`)
                }
                attemptKeySystemAccess(e) {
                    const t = this.hls.levels,
                        i = (e, t, i) => !!e && i.indexOf(e) === t,
                        r = t.map((e => e.audioCodec)).filter(i),
                        n = t.map((e => e.videoCodec)).filter(i);
                    return r.length + n.length === 0 && n.push("avc1.42e01e"), new Promise(((t, i) => {
                        const s = e => {
                            const a = e.shift();
                            this.getMediaKeysPromise(a, r, n).then((e => t({
                                keySystem: a,
                                mediaKeys: e
                            }))).catch((t => {
                                e.length ? s(e) : i(t instanceof sa ? t : new sa({
                                    type: pe.KEY_SYSTEM_ERROR,
                                    details: ge.KEY_SYSTEM_NO_ACCESS,
                                    error: t,
                                    fatal: !0
                                }, t.message))
                            }))
                        };
                        s(e)
                    }))
                }
                requestMediaKeySystemAccess(e, t) {
                    const {
                        requestMediaKeySystemAccessFunc: i
                    } = this.config;
                    if ("function" != typeof i) {
                        let e = `Configured requestMediaKeySystemAccess is not a function ${i}`;
                        return null === We && "http:" === self.location.protocol && (e = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(e))
                    }
                    return i(e, t)
                }
                getMediaKeysPromise(e, t, i) {
                    const r = function(e, t, i, r) {
                            let n;
                            switch (e) {
                                case Be.FAIRPLAY:
                                    n = ["cenc", "sinf"];
                                    break;
                                case Be.WIDEVINE:
                                case Be.PLAYREADY:
                                    n = ["cenc"];
                                    break;
                                case Be.CLEARKEY:
                                    n = ["cenc", "keyids"];
                                    break;
                                default:
                                    throw new Error(`Unknown key-system: ${e}`)
                            }
                            return function(e, t, i, r) {
                                return [{
                                    initDataTypes: e,
                                    persistentState: r.persistentState || "not-allowed",
                                    distinctiveIdentifier: r.distinctiveIdentifier || "not-allowed",
                                    sessionTypes: r.sessionTypes || [r.sessionType || "temporary"],
                                    audioCapabilities: t.map((e => ({
                                        contentType: `audio/mp4; codecs="${e}"`,
                                        robustness: r.audioRobustness || "",
                                        encryptionScheme: r.audioEncryptionScheme || null
                                    }))),
                                    videoCapabilities: i.map((e => ({
                                        contentType: `video/mp4; codecs="${e}"`,
                                        robustness: r.videoRobustness || "",
                                        encryptionScheme: r.videoEncryptionScheme || null
                                    })))
                                }]
                            }(n, t, i, r)
                        }(e, t, i, this.config.drmSystemOptions),
                        n = this.keySystemAccessPromises[e];
                    let s = null == n ? void 0 : n.keySystemAccess;
                    if (!s) {
                        this.log(`Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(r)}`), s = this.requestMediaKeySystemAccess(e, r);
                        const t = this.keySystemAccessPromises[e] = {
                            keySystemAccess: s
                        };
                        return s.catch((t => {
                            this.log(`Failed to obtain access to key-system "${e}": ${t}`)
                        })), s.then((i => {
                            this.log(`Access for key-system "${i.keySystem}" obtained`);
                            const r = this.fetchServerCertificate(e);
                            return this.log(`Create media-keys for "${e}"`), t.mediaKeys = i.createMediaKeys().then((t => (this.log(`Media-keys created for "${e}"`), r.then((i => i ? this.setMediaKeysServerCertificate(t, e, i) : t))))), t.mediaKeys.catch((t => {
                                this.error(`Failed to create media-keys for "${e}"}: ${t}`)
                            })), t.mediaKeys
                        }))
                    }
                    return s.then((() => n.mediaKeys))
                }
                createMediaKeySessionContext({
                    decryptdata: e,
                    keySystem: t,
                    mediaKeys: i
                }) {
                    this.log(`Creating key-system session "${t}" keyId: ${ut(e.keyId||[])}`);
                    const r = i.createSession(),
                        n = {
                            decryptdata: e,
                            keySystem: t,
                            mediaKeys: i,
                            mediaKeysSession: r,
                            keyStatus: "status-pending"
                        };
                    return this.mediaKeySessions.push(n), n
                }
                renewKeySession(e) {
                    const t = e.decryptdata;
                    if (t.pssh) {
                        const i = this.createMediaKeySessionContext(e),
                            r = this.getKeyIdString(t),
                            n = "cenc";
                        this.keyIdToKeySessionPromise[r] = this.generateRequestWithPreferredKeySession(i, n, t.pssh, "expired")
                    } else this.warn("Could not renew expired session. Missing pssh initData.");
                    this.removeSession(e)
                }
                getKeyIdString(e) {
                    if (!e) throw new Error("Could not read keyId of undefined decryptdata");
                    if (null === e.keyId) throw new Error("keyId is null");
                    return ut(e.keyId)
                }
                updateKeySession(e, t) {
                    var i;
                    const r = e.mediaKeysSession;
                    return this.log(`Updating key-session "${r.sessionId}" for keyID ${ut((null==(i=e.decryptdata)?void 0:i.keyId)||[])}\n      } (data length: ${t?t.byteLength:t})`), r.update(t)
                }
                selectKeySystemFormat(e) {
                    const t = Object.keys(e.levelkeys || {});
                    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise
                }
                getKeyFormatPromise(e) {
                    return new Promise(((t, i) => {
                        const r = Ke(this.config),
                            n = e.map(Ge).filter((e => !!e && -1 !== r.indexOf(e)));
                        return this.getKeySystemSelectionPromise(n).then((({
                            keySystem: e
                        }) => {
                            const r = qe(e);
                            r ? t(r) : i(new Error(`Unable to find format for key-system "${e}"`))
                        })).catch(i)
                    }))
                }
                loadKey(e) {
                    const t = e.keyInfo.decryptdata,
                        i = this.getKeyIdString(t),
                        r = `(keyId: ${i} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
                    this.log(`Starting session for key ${r}`);
                    let n = this.keyIdToKeySessionPromise[i];
                    return n || (n = this.keyIdToKeySessionPromise[i] = this.getKeySystemForKeyPromise(t).then((({
                        keySystem: i,
                        mediaKeys: n
                    }) => (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${r}`), this.attemptSetMediaKeys(i, n).then((() => {
                        this.throwIfDestroyed();
                        const e = this.createMediaKeySessionContext({
                            keySystem: i,
                            mediaKeys: n,
                            decryptdata: t
                        });
                        return this.generateRequestWithPreferredKeySession(e, "cenc", t.pssh, "playlist-key")
                    }))))), n.catch((e => this.handleError(e)))), n
                }
                throwIfDestroyed(e = "Invalid state") {
                    if (!this.hls) throw new Error("invalid state")
                }
                handleError(e) {
                    this.hls && (this.error(e.message), e instanceof sa ? this.hls.trigger(me.ERROR, e.data) : this.hls.trigger(me.ERROR, {
                        type: pe.KEY_SYSTEM_ERROR,
                        details: ge.KEY_SYSTEM_NO_KEYS,
                        error: e,
                        fatal: !0
                    }))
                }
                getKeySystemForKeyPromise(e) {
                    const t = this.getKeyIdString(e),
                        i = this.keyIdToKeySessionPromise[t];
                    if (!i) {
                        const t = Ge(e.keyFormat),
                            i = t ? [t] : Ke(this.config);
                        return this.attemptKeySystemAccess(i)
                    }
                    return i
                }
                getKeySystemSelectionPromise(e) {
                    if (e.length || (e = Ke(this.config)), 0 === e.length) throw new sa({
                        type: pe.KEY_SYSTEM_ERROR,
                        details: ge.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
                        fatal: !0
                    }, `Missing key-system license configuration options ${JSON.stringify({drmSystems:this.config.drmSystems})}`);
                    return this.attemptKeySystemAccess(e)
                }
                _onMediaEncrypted(e) {
                    const {
                        initDataType: t,
                        initData: i
                    } = e;
                    if (this.debug(`"${e.type}" event: init data type: "${t}"`), null === i) return;
                    let r, n;
                    if ("sinf" === t && this.config.drmSystems[Be.FAIRPLAY]) {
                        const e = pt(new Uint8Array(i));
                        try {
                            const t = Me(JSON.parse(e).sinf),
                                i = wt(new Uint8Array(t));
                            if (!i) return;
                            r = i.subarray(8, 24), n = Be.FAIRPLAY
                        } catch (e) {
                            return void this.warn('Failed to parse sinf "encrypted" event message initData')
                        }
                    } else {
                        const e = function(e) {
                            if (!(e instanceof ArrayBuffer) || e.byteLength < 32) return null;
                            const t = {
                                    version: 0,
                                    systemId: "",
                                    kids: null,
                                    data: null
                                },
                                i = new DataView(e),
                                r = i.getUint32(0);
                            if (e.byteLength !== r && r > 44) return null;
                            if (1886614376 !== i.getUint32(4)) return null;
                            if (t.version = i.getUint32(8) >>> 24, t.version > 1) return null;
                            t.systemId = ut(new Uint8Array(e, 12, 16));
                            const n = i.getUint32(28);
                            if (0 === t.version) {
                                if (r - 32 < n) return null;
                                t.data = new Uint8Array(e, 32, n)
                            } else if (1 === t.version) {
                                t.kids = [];
                                for (let i = 0; i < n; i++) t.kids.push(new Uint8Array(e, 32 + 16 * i, 16))
                            }
                            return t
                        }(i);
                        if (null === e) return;
                        0 === e.version && e.systemId === Ve && e.data && (r = e.data.subarray(8, 24)), n = function(e) {
                            if (e === Ve) return Be.WIDEVINE
                        }(e.systemId)
                    }
                    if (!n || !r) return;
                    const s = ut(r),
                        {
                            keyIdToKeySessionPromise: a,
                            mediaKeySessions: o
                        } = this;
                    let l = a[s];
                    for (let e = 0; e < o.length; e++) {
                        const n = o[e],
                            c = n.decryptdata;
                        if (c.pssh || !c.keyId) continue;
                        const d = ut(c.keyId);
                        if (s === d || -1 !== c.uri.replace(/-/g, "").indexOf(s)) {
                            l = a[d], delete a[d], c.pssh = new Uint8Array(i), c.keyId = r, l = a[s] = l.then((() => this.generateRequestWithPreferredKeySession(n, t, i, "encrypted-event-key-match")));
                            break
                        }
                    }
                    l || (l = a[s] = this.getKeySystemSelectionPromise([n]).then((({
                        keySystem: e,
                        mediaKeys: n
                    }) => {
                        var a;
                        this.throwIfDestroyed();
                        const o = new Pt("ISO-23001-7", s, null != (a = qe(e)) ? a : "");
                        return o.pssh = new Uint8Array(i), o.keyId = r, this.attemptSetMediaKeys(e, n).then((() => {
                            this.throwIfDestroyed();
                            const r = this.createMediaKeySessionContext({
                                decryptdata: o,
                                keySystem: e,
                                mediaKeys: n
                            });
                            return this.generateRequestWithPreferredKeySession(r, t, i, "encrypted-event-no-match")
                        }))
                    }))), l.catch((e => this.handleError(e)))
                }
                _onWaitingForKey(e) {
                    this.log(`"${e.type}" event`)
                }
                attemptSetMediaKeys(e, t) {
                    const i = this.setMediaKeysQueue.slice();
                    this.log(`Setting media-keys for "${e}"`);
                    const r = Promise.all(i).then((() => {
                        if (!this.media) throw new Error("Attempted to set mediaKeys without media element attached");
                        return this.media.setMediaKeys(t)
                    }));
                    return this.setMediaKeysQueue.push(r), r.then((() => {
                        this.log(`Media-keys set for "${e}"`), i.push(r), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((e => -1 === i.indexOf(e)))
                    }))
                }
                generateRequestWithPreferredKeySession(e, t, i, r) {
                    var n, s;
                    const a = null == (n = this.config.drmSystems) || null == (s = n[e.keySystem]) ? void 0 : s.generateRequest;
                    if (a) try {
                        const r = a.call(this.hls, t, i, e);
                        if (!r) throw new Error("Invalid response from configured generateRequest filter");
                        t = r.initDataType, i = e.decryptdata.pssh = r.initData ? new Uint8Array(r.initData) : null
                    } catch (e) {
                        var o;
                        if (this.warn(e.message), null != (o = this.hls) && o.config.debug) throw e
                    }
                    if (null === i) return this.log(`Skipping key-session request for "${r}" (no initData)`), Promise.resolve(e);
                    const l = this.getKeyIdString(e.decryptdata);
                    this.log(`Generating key-session request for "${r}": ${l} (init data type: ${t} length: ${i?i.byteLength:null})`);
                    const c = new Yn;
                    e.mediaKeysSession.onmessage = t => {
                        const i = e.mediaKeysSession;
                        if (!i) return void c.emit("error", new Error("invalid state"));
                        const {
                            messageType: r,
                            message: n
                        } = t;
                        this.log(`"${r}" message event for session "${i.sessionId}" message size: ${n.byteLength}`), "license-request" === r || "license-renewal" === r ? this.renewLicense(e, n).catch((e => {
                            this.handleError(e), c.emit("error", e)
                        })) : "license-release" === r ? e.keySystem === Be.FAIRPLAY && (this.updateKeySession(e, Fe("acknowledged")), this.removeSession(e)) : this.warn(`unhandled media key message type "${r}"`)
                    }, e.mediaKeysSession.onkeystatuseschange = t => {
                        if (!e.mediaKeysSession) return void c.emit("error", new Error("invalid state"));
                        this.onKeyStatusChange(e);
                        const i = e.keyStatus;
                        c.emit("keyStatus", i), "expired" === i && (this.warn(`${e.keySystem} expired for key ${l}`), this.renewKeySession(e))
                    };
                    const d = new Promise(((e, t) => {
                        c.on("error", t), c.on("keyStatus", (i => {
                            i.startsWith("usable") ? e() : "output-restricted" === i ? t(new sa({
                                type: pe.KEY_SYSTEM_ERROR,
                                details: ge.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                                fatal: !1
                            }, "HDCP level output restricted")) : "internal-error" === i ? t(new sa({
                                type: pe.KEY_SYSTEM_ERROR,
                                details: ge.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                                fatal: !0
                            }, `key status changed to "${i}"`)) : "expired" === i ? t(new Error("key expired while generating request")) : this.warn(`unhandled key status change "${i}"`)
                        }))
                    }));
                    return e.mediaKeysSession.generateRequest(t, i).then((() => {
                        var t;
                        this.log(`Request generated for key-session "${null==(t=e.mediaKeysSession)?void 0:t.sessionId}" keyId: ${l}`)
                    })).catch((e => {
                        throw new sa({
                            type: pe.KEY_SYSTEM_ERROR,
                            details: ge.KEY_SYSTEM_NO_SESSION,
                            error: e,
                            fatal: !1
                        }, `Error generating key-session request: ${e}`)
                    })).then((() => d)).catch((t => {
                        throw c.removeAllListeners(), this.removeSession(e), t
                    })).then((() => (c.removeAllListeners(), e)))
                }
                onKeyStatusChange(e) {
                    e.mediaKeysSession.keyStatuses.forEach(((t, i) => {
                        this.log(`key status change "${t}" for keyStatuses keyId: ${ut("buffer"in i?new Uint8Array(i.buffer,i.byteOffset,i.byteLength):new Uint8Array(i))} session keyId: ${ut(new Uint8Array(e.decryptdata.keyId||[]))} uri: ${e.decryptdata.uri}`), e.keyStatus = t
                    }))
                }
                fetchServerCertificate(e) {
                    const t = this.config,
                        i = new(0, t.loader)(t),
                        r = this.getServerCertificateUrl(e);
                    return r ? (this.log(`Fetching serverCertificate for "${e}"`), new Promise(((n, s) => {
                        const a = {
                                responseType: "arraybuffer",
                                url: r
                            },
                            o = t.certLoadPolicy.default,
                            l = {
                                loadPolicy: o,
                                timeout: o.maxLoadTimeMs,
                                maxRetry: 0,
                                retryDelay: 0,
                                maxRetryDelay: 0
                            },
                            c = {
                                onSuccess: (e, t, i, r) => {
                                    n(e.data)
                                },
                                onError: (t, i, n, o) => {
                                    s(new sa({
                                        type: pe.KEY_SYSTEM_ERROR,
                                        details: ge.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: n,
                                        response: le({
                                            url: a.url,
                                            data: void 0
                                        }, t)
                                    }, `"${e}" certificate request failed (${r}). Status: ${t.code} (${t.text})`))
                                },
                                onTimeout: (t, i, n) => {
                                    s(new sa({
                                        type: pe.KEY_SYSTEM_ERROR,
                                        details: ge.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: n,
                                        response: {
                                            url: a.url,
                                            data: void 0
                                        }
                                    }, `"${e}" certificate request timed out (${r})`))
                                },
                                onAbort: (e, t, i) => {
                                    s(new Error("aborted"))
                                }
                            };
                        i.load(a, l, c)
                    }))) : Promise.resolve()
                }
                setMediaKeysServerCertificate(e, t, i) {
                    return new Promise(((r, n) => {
                        e.setServerCertificate(i).then((n => {
                            this.log(`setServerCertificate ${n?"success":"not supported by CDM"} (${null==i?void 0:i.byteLength}) on "${t}"`), r(e)
                        })).catch((e => {
                            n(new sa({
                                type: pe.KEY_SYSTEM_ERROR,
                                details: ge.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                                error: e,
                                fatal: !0
                            }, e.message))
                        }))
                    }))
                }
                renewLicense(e, t) {
                    return this.requestLicense(e, new Uint8Array(t)).then((t => this.updateKeySession(e, new Uint8Array(t)).catch((e => {
                        throw new sa({
                            type: pe.KEY_SYSTEM_ERROR,
                            details: ge.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                            error: e,
                            fatal: !0
                        }, e.message)
                    }))))
                }
                setupLicenseXHR(e, t, i, r) {
                    const n = this.config.licenseXhrSetup;
                    return n ? Promise.resolve().then((() => {
                        if (!i.decryptdata) throw new Error("Key removed");
                        return n.call(this.hls, e, t, i, r)
                    })).catch((s => {
                        if (!i.decryptdata) throw s;
                        return e.open("POST", t, !0), n.call(this.hls, e, t, i, r)
                    })).then((i => {
                        e.readyState || e.open("POST", t, !0);
                        return {
                            xhr: e,
                            licenseChallenge: i || r
                        }
                    })) : (e.open("POST", t, !0), Promise.resolve({
                        xhr: e,
                        licenseChallenge: r
                    }))
                }
                requestLicense(e, t) {
                    const i = this.config.keyLoadPolicy.default;
                    return new Promise(((r, n) => {
                        const s = this.getLicenseServerUrl(e.keySystem);
                        this.log(`Sending license request to URL: ${s}`);
                        const a = new XMLHttpRequest;
                        a.responseType = "arraybuffer", a.onreadystatechange = () => {
                            if (!this.hls || !e.mediaKeysSession) return n(new Error("invalid state"));
                            if (4 === a.readyState)
                                if (200 === a.status) {
                                    this._requestLicenseFailureCount = 0;
                                    let t = a.response;
                                    this.log(`License received ${t instanceof ArrayBuffer?t.byteLength:t}`);
                                    const i = this.config.licenseResponseCallback;
                                    if (i) try {
                                        t = i.call(this.hls, a, s, e)
                                    } catch (e) {
                                        this.error(e)
                                    }
                                    r(t)
                                } else {
                                    const o = i.errorRetry,
                                        l = o ? o.maxNumRetry : 0;
                                    if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount > l || a.status >= 400 && a.status < 500) n(new sa({
                                        type: pe.KEY_SYSTEM_ERROR,
                                        details: ge.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                        fatal: !0,
                                        networkDetails: a,
                                        response: {
                                            url: s,
                                            data: void 0,
                                            code: a.status,
                                            text: a.statusText
                                        }
                                    }, `License Request XHR failed (${s}). Status: ${a.status} (${a.statusText})`));
                                    else {
                                        const i = l - this._requestLicenseFailureCount + 1;
                                        this.warn(`Retrying license request, ${i} attempts left`), this.requestLicense(e, t).then(r, n)
                                    }
                                }
                        }, e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(), e.licenseXhr = a, this.setupLicenseXHR(a, s, e, t).then((({
                            xhr: e,
                            licenseChallenge: t
                        }) => {
                            e.send(t)
                        }))
                    }))
                }
                onMediaAttached(e, t) {
                    if (!this.config.emeEnabled) return;
                    const i = t.media;
                    this.media = i, i.addEventListener("encrypted", this.onMediaEncrypted), i.addEventListener("waitingforkey", this.onWaitingForKey)
                }
                onMediaDetached() {
                    const e = this.media,
                        t = this.mediaKeySessions;
                    e && (e.removeEventListener("encrypted", this.onMediaEncrypted), e.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, Pt.clearKeyUriToKeyIdMap();
                    const i = t.length;
                    na.CDMCleanupPromise = Promise.all(t.map((e => this.removeSession(e))).concat(null == e ? void 0 : e.setMediaKeys(null).catch((t => {
                        this.log(`Could not clear media keys: ${t}. media.src: ${null==e?void 0:e.src}`)
                    })))).then((() => {
                        i && (this.log("finished closing key sessions and clearing media keys"), t.length = 0)
                    })).catch((t => {
                        this.log(`Could not close sessions and clear media keys: ${t}. media.src: ${null==e?void 0:e.src}`)
                    }))
                }
                onManifestLoading() {
                    this.keyFormatPromise = null
                }
                onManifestLoaded(e, {
                    sessionKeys: t
                }) {
                    if (t && this.config.emeEnabled && !this.keyFormatPromise) {
                        const e = t.reduce(((e, t) => (-1 === e.indexOf(t.keyFormat) && e.push(t.keyFormat), e)), []);
                        this.log(`Selecting key-system from session-keys ${e.join(", ")}`), this.keyFormatPromise = this.getKeyFormatPromise(e)
                    }
                }
                removeSession(e) {
                    const {
                        mediaKeysSession: t,
                        licenseXhr: i
                    } = e;
                    if (t) {
                        this.log(`Remove licenses and keys and close session ${t.sessionId}`), t.onmessage = null, t.onkeystatuseschange = null, i && i.readyState !== XMLHttpRequest.DONE && i.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
                        const r = this.mediaKeySessions.indexOf(e);
                        return r > -1 && this.mediaKeySessions.splice(r, 1), t.remove().catch((e => {
                            this.log(`Could not remove session: ${e}`)
                        })).then((() => t.close())).catch((e => {
                            this.log(`Could not close session: ${e}`)
                        }))
                    }
                }
            }
            na.CDMCleanupPromise = void 0;
            class sa extends Error {
                constructor(e, t) {
                    super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error
                }
            }
            var aa = "m",
                oa = "a",
                la = "v",
                ca = "av",
                da = "i",
                ua = "tt";
            class ha {
                constructor(e) {
                    this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () => {
                        this.initialized && (this.starved = !0), this.buffering = !0
                    }, this.onPlaying = () => {
                        this.initialized || (this.initialized = !0), this.buffering = !1
                    }, this.applyPlaylistData = e => {
                        try {
                            this.apply(e, {
                                ot: aa,
                                su: !this.initialized
                            })
                        } catch (e) {
                            Ee.warn("Could not generate manifest CMCD data.", e)
                        }
                    }, this.applyFragmentData = e => {
                        try {
                            const t = e.frag,
                                i = this.hls.levels[t.level],
                                r = this.getObjectType(t),
                                n = {
                                    d: 1e3 * t.duration,
                                    ot: r
                                };
                            r !== la && r !== oa && r != ca || (n.br = i.bitrate / 1e3, n.tb = this.getTopBandwidth(r) / 1e3, n.bl = this.getBufferLength(r)), this.apply(e, n)
                        } catch (e) {
                            Ee.warn("Could not generate segment CMCD data.", e)
                        }
                    }, this.hls = e;
                    const t = this.config = e.config,
                        {
                            cmcd: i
                        } = t;
                    null != i && (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = i.sessionId || ha.uuid(), this.cid = i.contentId, this.useHeaders = !0 === i.useHeaders, this.registerListeners())
                }
                registerListeners() {
                    const e = this.hls;
                    e.on(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(me.MEDIA_DETACHED, this.onMediaDetached, this), e.on(me.BUFFER_CREATED, this.onBufferCreated, this)
                }
                unregisterListeners() {
                    const e = this.hls;
                    e.off(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(me.MEDIA_DETACHED, this.onMediaDetached, this), e.off(me.BUFFER_CREATED, this.onBufferCreated, this)
                }
                destroy() {
                    this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null
                }
                onMediaAttached(e, t) {
                    this.media = t.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
                }
                onMediaDetached() {
                    this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
                }
                onBufferCreated(e, t) {
                    var i, r;
                    this.audioBuffer = null == (i = t.tracks.audio) ? void 0 : i.buffer, this.videoBuffer = null == (r = t.tracks.video) ? void 0 : r.buffer
                }
                createData() {
                    var e;
                    return {
                        v: 1,
                        sf: "h",
                        sid: this.sid,
                        cid: this.cid,
                        pr: null == (e = this.media) ? void 0 : e.playbackRate,
                        mtp: this.hls.bandwidthEstimate / 1e3
                    }
                }
                apply(e, t = {}) {
                    de(t, this.createData());
                    const i = t.ot === da || t.ot === la || t.ot === ca;
                    if (this.starved && i && (t.bs = !0, t.su = !0, this.starved = !1), null == t.su && (t.su = this.buffering), this.useHeaders) {
                        const i = ha.toHeaders(t);
                        if (!Object.keys(i).length) return;
                        e.headers || (e.headers = {}), de(e.headers, i)
                    } else {
                        const i = ha.toQuery(t);
                        if (!i) return;
                        e.url = ha.appendQueryToUri(e.url, i)
                    }
                }
                getObjectType(e) {
                    const {
                        type: t
                    } = e;
                    return "subtitle" === t ? ua : "initSegment" === e.sn ? da : "audio" === t ? oa : "main" === t ? this.hls.audioTracks.length ? la : ca : void 0
                }
                getTopBandwidth(e) {
                    let t, i = 0;
                    const r = this.hls;
                    if (e === oa) t = r.audioTracks;
                    else {
                        const e = r.maxAutoLevel,
                            i = e > -1 ? e + 1 : r.levels.length;
                        t = r.levels.slice(0, i)
                    }
                    for (const e of t) e.bitrate > i && (i = e.bitrate);
                    return i > 0 ? i : NaN
                }
                getBufferLength(e) {
                    const t = this.hls.media,
                        i = e === oa ? this.audioBuffer : this.videoBuffer;
                    if (!i || !t) return NaN;
                    return 1e3 * Tr.bufferInfo(i, t.currentTime, this.config.maxBufferHole).len
                }
                createPlaylistLoader() {
                    const {
                        pLoader: e
                    } = this.config, t = this.applyPlaylistData, i = e || this.config.loader;
                    return class {
                        constructor(e) {
                            this.loader = void 0, this.loader = new i(e)
                        }
                        get stats() {
                            return this.loader.stats
                        }
                        get context() {
                            return this.loader.context
                        }
                        destroy() {
                            this.loader.destroy()
                        }
                        abort() {
                            this.loader.abort()
                        }
                        load(e, i, r) {
                            t(e), this.loader.load(e, i, r)
                        }
                    }
                }
                createFragmentLoader() {
                    const {
                        fLoader: e
                    } = this.config, t = this.applyFragmentData, i = e || this.config.loader;
                    return class {
                        constructor(e) {
                            this.loader = void 0, this.loader = new i(e)
                        }
                        get stats() {
                            return this.loader.stats
                        }
                        get context() {
                            return this.loader.context
                        }
                        destroy() {
                            this.loader.destroy()
                        }
                        abort() {
                            this.loader.abort()
                        }
                        load(e, i, r) {
                            t(e), this.loader.load(e, i, r)
                        }
                    }
                }
                static uuid() {
                    const e = URL.createObjectURL(new Blob),
                        t = e.toString();
                    return URL.revokeObjectURL(e), t.slice(t.lastIndexOf("/") + 1)
                }
                static serialize(e) {
                    const t = [],
                        i = e => !Number.isNaN(e) && null != e && "" !== e && !1 !== e,
                        r = e => Math.round(e),
                        n = e => 100 * r(e / 100),
                        s = {
                            br: r,
                            d: r,
                            bl: n,
                            dl: n,
                            mtp: n,
                            nor: e => encodeURIComponent(e),
                            rtp: n,
                            tb: r
                        },
                        a = Object.keys(e || {}).sort();
                    for (const r of a) {
                        let n = e[r];
                        if (!i(n)) continue;
                        if ("v" === r && 1 === n) continue;
                        if ("pr" == r && 1 === n) continue;
                        const a = s[r];
                        a && (n = a(n));
                        const o = typeof n;
                        let l;
                        l = "ot" === r || "sf" === r || "st" === r ? `${r}=${n}` : "boolean" === o ? r : "number" === o ? `${r}=${n}` : `${r}=${JSON.stringify(n)}`, t.push(l)
                    }
                    return t.join(",")
                }
                static toHeaders(e) {
                    const t = Object.keys(e),
                        i = {},
                        r = ["Object", "Request", "Session", "Status"],
                        n = [{}, {}, {}, {}],
                        s = {
                            br: 0,
                            d: 0,
                            ot: 0,
                            tb: 0,
                            bl: 1,
                            dl: 1,
                            mtp: 1,
                            nor: 1,
                            nrr: 1,
                            su: 1,
                            cid: 2,
                            pr: 2,
                            sf: 2,
                            sid: 2,
                            st: 2,
                            v: 2,
                            bs: 3,
                            rtp: 3
                        };
                    for (const i of t) {
                        n[null != s[i] ? s[i] : 1][i] = e[i]
                    }
                    for (let e = 0; e < n.length; e++) {
                        const t = ha.serialize(n[e]);
                        t && (i[`CMCD-${r[e]}`] = t)
                    }
                    return i
                }
                static toQuery(e) {
                    return `CMCD=${encodeURIComponent(ha.serialize(e))}`
                }
                static appendQueryToUri(e, t) {
                    if (!t) return e;
                    const i = e.includes("?") ? "&" : "?";
                    return `${e}${i}${t}`
                }
            }

            function fa(e, t, i, r) {
                e && Object.keys(t).forEach((n => {
                    const s = e.filter((e => e.groupId === n)).map((e => {
                        const s = de({}, e);
                        return s.details = void 0, s.attrs = new _e(s.attrs), s.url = s.attrs.URI = ma(e.url, e.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", i), s.groupId = s.attrs["GROUP-ID"] = t[n], s.attrs["PATHWAY-ID"] = r, s
                    }));
                    e.push(...s)
                }))
            }

            function ma(e, t, i, r) {
                const {
                    HOST: n,
                    PARAMS: s,
                    [i]: a
                } = r;
                let o;
                t && (o = null == a ? void 0 : a[t], o && (e = o));
                const l = new self.URL(e);
                return n && !o && (l.host = n), s && Object.keys(s).sort().forEach((e => {
                    e && l.searchParams.set(e, s[e])
                })), l.href
            }
            const pa = /^age:\s*[\d.]+\s*$/im;
            class ga {
                constructor(e) {
                    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new Le, this.retryDelay = 0
                }
                destroy() {
                    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null
                }
                abortInternal() {
                    const e = this.loader;
                    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState && (this.stats.aborted = !0, e.abort()))
                }
                abort() {
                    var e;
                    this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
                }
                load(e, t, i) {
                    if (this.stats.loading.start) throw new Error("Loader can only be used once.");
                    this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = i, this.loadInternal()
                }
                loadInternal() {
                    const {
                        config: e,
                        context: t
                    } = this;
                    if (!e) return;
                    const i = this.loader = new self.XMLHttpRequest,
                        r = this.stats;
                    r.loading.first = 0, r.loaded = 0, r.aborted = !1;
                    const n = this.xhrSetup;
                    n ? Promise.resolve().then((() => {
                        if (!this.stats.aborted) return n(i, t.url)
                    })).catch((e => (i.open("GET", t.url, !0), n(i, t.url)))).then((() => {
                        this.stats.aborted || this.openAndSendXhr(i, t, e)
                    })).catch((e => {
                        this.callbacks.onError({
                            code: i.status,
                            text: e.message
                        }, t, i, r)
                    })) : this.openAndSendXhr(i, t, e)
                }
                openAndSendXhr(e, t, i) {
                    e.readyState || e.open("GET", t.url, !0);
                    const r = this.context.headers,
                        {
                            maxTimeToFirstByteMs: n,
                            maxLoadTimeMs: s
                        } = i.loadPolicy;
                    if (r)
                        for (const t in r) e.setRequestHeader(t, r[t]);
                    t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), i.timeout = n && ue(n) ? n : s, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.timeout), e.send()
                }
                readystatechange() {
                    const {
                        context: e,
                        loader: t,
                        stats: i
                    } = this;
                    if (!e || !t) return;
                    const r = t.readyState,
                        n = this.config;
                    if (!i.aborted && r >= 2 && (0 === i.loading.first && (i.loading.first = Math.max(self.performance.now(), i.loading.start), n.timeout !== n.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), n.timeout = n.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.loadPolicy.maxLoadTimeMs - (i.loading.first - i.loading.start)))), 4 === r)) {
                        self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;
                        const r = t.status,
                            s = "text" !== t.responseType;
                        if (r >= 200 && r < 300 && (s && t.response || null !== t.responseText)) {
                            i.loading.end = Math.max(self.performance.now(), i.loading.first);
                            const n = s ? t.response : t.responseText,
                                a = "arraybuffer" === t.responseType ? n.byteLength : n.length;
                            if (i.loaded = i.total = a, i.bwEstimate = 8e3 * i.total / (i.loading.end - i.loading.first), !this.callbacks) return;
                            const o = this.callbacks.onProgress;
                            if (o && o(i, e, n, t), !this.callbacks) return;
                            const l = {
                                url: t.responseURL,
                                data: n,
                                code: r
                            };
                            this.callbacks.onSuccess(l, i, e, t)
                        } else {
                            const s = n.loadPolicy.errorRetry;
                            ji(s, i.retry, !1, r) ? this.retry(s) : (Ee.error(`${r} while loading ${e.url}`), this.callbacks.onError({
                                code: r,
                                text: t.statusText
                            }, e, t, i))
                        }
                    }
                }
                loadtimeout() {
                    var e;
                    const t = null == (e = this.config) ? void 0 : e.loadPolicy.timeoutRetry;
                    if (ji(t, this.stats.retry, !0)) this.retry(t);
                    else {
                        Ee.warn(`timeout while loading ${this.context.url}`);
                        const e = this.callbacks;
                        e && (this.abortInternal(), e.onTimeout(this.stats, this.context, this.loader))
                    }
                }
                retry(e) {
                    const {
                        context: t,
                        stats: i
                    } = this;
                    this.retryDelay = $i(e, i.retry), i.retry++, Ee.warn(`${status?"HTTP Status "+status:"Timeout"} while loading ${t.url}, retrying ${i.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
                }
                loadprogress(e) {
                    const t = this.stats;
                    t.loaded = e.loaded, e.lengthComputable && (t.total = e.total)
                }
                getCacheAge() {
                    let e = null;
                    if (this.loader && pa.test(this.loader.getAllResponseHeaders())) {
                        const t = this.loader.getResponseHeader("age");
                        e = t ? parseFloat(t) : null
                    }
                    return e
                }
                getResponseHeader(e) {
                    return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null
                }
            }
            const ya = /(\d+)-(\d+)\/(\d+)/;
            class va {
                constructor(e) {
                    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || ba, this.controller = new self.AbortController, this.stats = new Le
                }
                destroy() {
                    this.loader = this.callbacks = null, this.abortInternal()
                }
                abortInternal() {
                    const e = this.response;
                    null != e && e.ok || (this.stats.aborted = !0, this.controller.abort())
                }
                abort() {
                    var e;
                    this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
                }
                load(e, t, i) {
                    const r = this.stats;
                    if (r.loading.start) throw new Error("Loader can only be used once.");
                    r.loading.start = self.performance.now();
                    const n = function(e, t) {
                            const i = {
                                method: "GET",
                                mode: "cors",
                                credentials: "same-origin",
                                signal: t,
                                headers: new self.Headers(de({}, e.headers))
                            };
                            e.rangeEnd && i.headers.set("Range", "bytes=" + e.rangeStart + "-" + String(e.rangeEnd - 1));
                            return i
                        }(e, this.controller.signal),
                        s = i.onProgress,
                        a = "arraybuffer" === e.responseType,
                        o = a ? "byteLength" : "length",
                        {
                            maxTimeToFirstByteMs: l,
                            maxLoadTimeMs: c
                        } = t.loadPolicy;
                    this.context = e, this.config = t, this.callbacks = i, this.request = this.fetchSetup(e, n), self.clearTimeout(this.requestTimeout), t.timeout = l && ue(l) ? l : c, this.requestTimeout = self.setTimeout((() => {
                        this.abortInternal(), i.onTimeout(r, e, this.response)
                    }), t.timeout), self.fetch(this.request).then((n => {
                        this.response = this.loader = n;
                        const o = Math.max(self.performance.now(), r.loading.start);
                        if (self.clearTimeout(this.requestTimeout), t.timeout = c, this.requestTimeout = self.setTimeout((() => {
                                this.abortInternal(), i.onTimeout(r, e, this.response)
                            }), c - (o - r.loading.start)), !n.ok) {
                            const {
                                status: e,
                                statusText: t
                            } = n;
                            throw new Ta(t || "fetch, bad network response", e, n)
                        }
                        return r.loading.first = o, r.total = function(e) {
                            const t = e.get("Content-Range");
                            if (t) {
                                const e = function(e) {
                                    const t = ya.exec(e);
                                    if (t) return parseInt(t[2]) - parseInt(t[1]) + 1
                                }(t);
                                if (ue(e)) return e
                            }
                            const i = e.get("Content-Length");
                            if (i) return parseInt(i)
                        }(n.headers) || r.total, s && ue(t.highWaterMark) ? this.loadProgressively(n, r, e, t.highWaterMark, s) : a ? n.arrayBuffer() : "json" === e.responseType ? n.json() : n.text()
                    })).then((n => {
                        const {
                            response: a
                        } = this;
                        self.clearTimeout(this.requestTimeout), r.loading.end = Math.max(self.performance.now(), r.loading.first);
                        const l = n[o];
                        l && (r.loaded = r.total = l);
                        const c = {
                            url: a.url,
                            data: n,
                            code: a.status
                        };
                        s && !ue(t.highWaterMark) && s(r, e, n, a), i.onSuccess(c, r, e, a)
                    })).catch((t => {
                        if (self.clearTimeout(this.requestTimeout), r.aborted) return;
                        const n = t && t.code || 0,
                            s = t ? t.message : null;
                        i.onError({
                            code: n,
                            text: s
                        }, e, t ? t.details : null, r)
                    }))
                }
                getCacheAge() {
                    let e = null;
                    if (this.response) {
                        const t = this.response.headers.get("age");
                        e = t ? parseFloat(t) : null
                    }
                    return e
                }
                getResponseHeader(e) {
                    return this.response ? this.response.headers.get(e) : null
                }
                loadProgressively(e, t, i, r = 0, n) {
                    const s = new ts,
                        a = e.body.getReader(),
                        o = () => a.read().then((a => {
                            if (a.done) return s.dataLength && n(t, i, s.flush(), e), Promise.resolve(new ArrayBuffer(0));
                            const l = a.value,
                                c = l.length;
                            return t.loaded += c, c < r || s.dataLength ? (s.push(l), s.dataLength >= r && n(t, i, s.flush(), e)) : n(t, i, l, e), o()
                        })).catch((() => Promise.reject()));
                    return o()
                }
            }

            function ba(e, t) {
                return new self.Request(e.url, t)
            }
            class Ta extends Error {
                constructor(e, t, i) {
                    super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = i
                }
            }
            const Ea = /\s/,
                Aa = {
                    newCue(e, t, i, r) {
                        const n = [];
                        let s, a, o, l, c;
                        const d = self.VTTCue || self.TextTrackCue;
                        for (let h = 0; h < r.rows.length; h++)
                            if (s = r.rows[h], o = !0, l = 0, c = "", !s.isEmpty()) {
                                var u;
                                for (let e = 0; e < s.chars.length; e++) Ea.test(s.chars[e].uchar) && o ? l++ : (c += s.chars[e].uchar, o = !1);
                                s.cueStartTime = t, t === i && (i += 1e-4), l >= 16 ? l-- : l++;
                                const r = Fs(c.trim()),
                                    f = js(t, i, r);
                                null != e && null != (u = e.cues) && u.getCueById(f) || (a = new d(t, i, r), a.id = f, a.line = h + 1, a.align = "left", a.position = 10 + Math.min(80, 10 * Math.floor(8 * l / 32)), n.push(a))
                            }
                        return e && n.length && (n.sort(((e, t) => "auto" === e.line || "auto" === t.line ? 0 : e.line > 8 && t.line > 8 ? t.line - e.line : e.line - t.line)), n.forEach((t => fi(e, t)))), n
                    }
                },
                wa = le(le({
                    autoStartLoad: !0,
                    startPosition: -1,
                    defaultAudioCodec: void 0,
                    debug: !1,
                    capLevelOnFPSDrop: !1,
                    capLevelToPlayerSize: !1,
                    ignoreDevicePixelRatio: !1,
                    initialLiveManifestSize: 1,
                    maxBufferLength: 30,
                    backBufferLength: 1 / 0,
                    maxBufferSize: 6e7,
                    maxBufferHole: .1,
                    highBufferWatchdogPeriod: 2,
                    nudgeOffset: .1,
                    nudgeMaxRetry: 3,
                    maxFragLookUpTolerance: .25,
                    liveSyncDurationCount: 3,
                    liveMaxLatencyDurationCount: 1 / 0,
                    liveSyncDuration: void 0,
                    liveMaxLatencyDuration: void 0,
                    maxLiveSyncPlaybackRate: 1,
                    liveDurationInfinity: !1,
                    liveBackBufferLength: null,
                    maxMaxBufferLength: 600,
                    enableWorker: !0,
                    workerPath: null,
                    enableSoftwareAES: !0,
                    startLevel: void 0,
                    startFragPrefetch: !1,
                    fpsDroppedMonitoringPeriod: 5e3,
                    fpsDroppedMonitoringThreshold: .2,
                    appendErrorMaxRetry: 3,
                    loader: ga,
                    fLoader: void 0,
                    pLoader: void 0,
                    xhrSetup: void 0,
                    licenseXhrSetup: void 0,
                    licenseResponseCallback: void 0,
                    abrController: class {
                        constructor(e) {
                            this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = -1, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = e;
                            const t = e.config;
                            this.bwEstimator = new es(t.abrEwmaSlowVoD, t.abrEwmaFastVoD, t.abrEwmaDefaultEstimate), this.registerListeners()
                        }
                        registerListeners() {
                            const {
                                hls: e
                            } = this;
                            e.on(me.FRAG_LOADING, this.onFragLoading, this), e.on(me.FRAG_LOADED, this.onFragLoaded, this), e.on(me.FRAG_BUFFERED, this.onFragBuffered, this), e.on(me.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(me.LEVEL_LOADED, this.onLevelLoaded, this)
                        }
                        unregisterListeners() {
                            const {
                                hls: e
                            } = this;
                            e.off(me.FRAG_LOADING, this.onFragLoading, this), e.off(me.FRAG_LOADED, this.onFragLoaded, this), e.off(me.FRAG_BUFFERED, this.onFragBuffered, this), e.off(me.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(me.LEVEL_LOADED, this.onLevelLoaded, this)
                        }
                        destroy() {
                            this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null
                        }
                        onFragLoading(e, t) {
                            var i;
                            const r = t.frag;
                            this.ignoreFragment(r) || (this.fragCurrent = r, this.partCurrent = null != (i = t.part) ? i : null, this.clearTimer(), this.timer = self.setInterval(this.onCheck, 100))
                        }
                        onLevelSwitching(e, t) {
                            this.clearTimer()
                        }
                        getTimeToLoadFrag(e, t, i, r) {
                            return e + i / t + (r ? this.lastLevelLoadSec : 0)
                        }
                        onLevelLoaded(e, t) {
                            const i = this.hls.config,
                                {
                                    total: r,
                                    bwEstimate: n
                                } = t.stats;
                            ue(r) && ue(n) && (this.lastLevelLoadSec = 8 * r / n), t.details.live ? this.bwEstimator.update(i.abrEwmaSlowLive, i.abrEwmaFastLive) : this.bwEstimator.update(i.abrEwmaSlowVoD, i.abrEwmaFastVoD)
                        }
                        _abandonRulesCheck() {
                            const {
                                fragCurrent: e,
                                partCurrent: t,
                                hls: i
                            } = this, {
                                autoLevelEnabled: r,
                                media: n
                            } = i;
                            if (!e || !n) return;
                            const s = performance.now(),
                                a = t ? t.stats : e.stats,
                                o = t ? t.duration : e.duration,
                                l = s - a.loading.start;
                            if (a.aborted || a.loaded && a.loaded === a.total || 0 === e.level) return this.clearTimer(), void(this._nextAutoLevel = -1);
                            if (!r || n.paused || !n.playbackRate || !n.readyState) return;
                            const c = i.mainForwardBufferInfo;
                            if (null === c) return;
                            const d = this.bwEstimator.getEstimateTTFB(),
                                u = Math.abs(n.playbackRate);
                            if (l <= Math.max(d, o / (2 * u) * 1e3)) return;
                            const h = c.len / u;
                            if (h >= 2 * o / u) return;
                            const f = a.loading.first ? a.loading.first - a.loading.start : -1,
                                m = a.loaded && f > -1,
                                p = this.bwEstimator.getEstimate(),
                                {
                                    levels: g,
                                    minAutoLevel: y
                                } = i,
                                v = g[e.level],
                                b = a.total || Math.max(a.loaded, Math.round(o * v.maxBitrate / 8));
                            let T = l - f;
                            T < 1 && m && (T = Math.min(l, 8 * a.loaded / p));
                            const E = m ? 1e3 * a.loaded / T : 0,
                                A = E ? (b - a.loaded) / E : 8 * b / p + d / 1e3;
                            if (A <= h) return;
                            const w = E ? 8 * E : p;
                            let _, k = Number.POSITIVE_INFINITY;
                            for (_ = e.level - 1; _ > y; _--) {
                                const e = g[_].maxBitrate;
                                if (k = this.getTimeToLoadFrag(d / 1e3, w, o * e, !g[_].details), k < h) break
                            }
                            k >= A || k > 10 * o || (i.nextLoadLevel = _, m ? this.bwEstimator.sample(l - Math.min(d, f), a.loaded) : this.bwEstimator.sampleTTFB(l), this.clearTimer(), Ee.warn(`[abr] Fragment ${e.sn}${t?" part "+t.index:""} of level ${e.level} is loading too slowly;\n      Time to underbuffer: ${h.toFixed(3)} s\n      Estimated load time for current fragment: ${A.toFixed(3)} s\n      Estimated load time for down switch fragment: ${k.toFixed(3)} s\n      TTFB estimate: ${f}\n      Current BW estimate: ${ue(p)?(p/1024).toFixed(3):"Unknown"} Kb/s\n      New BW estimate: ${(this.bwEstimator.getEstimate()/1024).toFixed(3)} Kb/s\n      Aborting and switching to level ${_}`), e.loader && (this.fragCurrent = this.partCurrent = null, e.abortRequests()), i.trigger(me.FRAG_LOAD_EMERGENCY_ABORTED, {
                                frag: e,
                                part: t,
                                stats: a
                            }))
                        }
                        onFragLoaded(e, {
                            frag: t,
                            part: i
                        }) {
                            const r = i ? i.stats : t.stats;
                            if (t.type === ai && this.bwEstimator.sampleTTFB(r.loading.first - r.loading.start), !this.ignoreFragment(t)) {
                                if (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                                    const e = i ? i.duration : t.duration,
                                        n = this.hls.levels[t.level],
                                        s = (n.loaded ? n.loaded.bytes : 0) + r.loaded,
                                        a = (n.loaded ? n.loaded.duration : 0) + e;
                                    n.loaded = {
                                        bytes: s,
                                        duration: a
                                    }, n.realBitrate = Math.round(8 * s / a)
                                }
                                if (t.bitrateTest) {
                                    const e = {
                                        stats: r,
                                        frag: t,
                                        part: i,
                                        id: t.type
                                    };
                                    this.onFragBuffered(me.FRAG_BUFFERED, e), t.bitrateTest = !1
                                }
                            }
                        }
                        onFragBuffered(e, t) {
                            const {
                                frag: i,
                                part: r
                            } = t, n = null != r && r.stats.loaded ? r.stats : i.stats;
                            if (n.aborted) return;
                            if (this.ignoreFragment(i)) return;
                            const s = n.parsing.end - n.loading.start - Math.min(n.loading.first - n.loading.start, this.bwEstimator.getEstimateTTFB());
                            this.bwEstimator.sample(s, n.loaded), n.bwEstimate = this.bwEstimator.getEstimate(), i.bitrateTest ? this.bitrateTestDelay = s / 1e3 : this.bitrateTestDelay = 0
                        }
                        ignoreFragment(e) {
                            return e.type !== ai || "initSegment" === e.sn
                        }
                        clearTimer() {
                            self.clearInterval(this.timer)
                        }
                        get nextAutoLevel() {
                            const e = this._nextAutoLevel,
                                t = this.bwEstimator;
                            if (-1 !== e && !t.canEstimate()) return e;
                            let i = this.getNextABRAutoLevel();
                            if (-1 !== e) {
                                const t = this.hls.levels;
                                if (t.length > Math.max(e, i) && t[e].loadError <= t[i].loadError) return e
                            }
                            return -1 !== e && (i = Math.min(e, i)), i
                        }
                        getNextABRAutoLevel() {
                            const {
                                fragCurrent: e,
                                partCurrent: t,
                                hls: i
                            } = this, {
                                maxAutoLevel: r,
                                config: n,
                                minAutoLevel: s,
                                media: a
                            } = i, o = t ? t.duration : e ? e.duration : 0, l = a && 0 !== a.playbackRate ? Math.abs(a.playbackRate) : 1, c = this.bwEstimator ? this.bwEstimator.getEstimate() : n.abrEwmaDefaultEstimate, d = i.mainForwardBufferInfo, u = (d ? d.len : 0) / l;
                            let h = this.findBestLevel(c, s, r, u, n.abrBandWidthFactor, n.abrBandWidthUpFactor);
                            if (h >= 0) return h;
                            Ee.trace(`[abr] ${u?"rebuffering expected":"buffer is empty"}, finding optimal quality level`);
                            let f = o ? Math.min(o, n.maxStarvationDelay) : n.maxStarvationDelay,
                                m = n.abrBandWidthFactor,
                                p = n.abrBandWidthUpFactor;
                            if (!u) {
                                const e = this.bitrateTestDelay;
                                if (e) {
                                    f = (o ? Math.min(o, n.maxLoadingDelay) : n.maxLoadingDelay) - e, Ee.trace(`[abr] bitrate test took ${Math.round(1e3*e)}ms, set first fragment max fetchDuration to ${Math.round(1e3*f)} ms`), m = p = 1
                                }
                            }
                            return h = this.findBestLevel(c, s, r, u + f, m, p), Math.max(h, 0)
                        }
                        findBestLevel(e, t, i, r, n, s) {
                            var a;
                            const {
                                fragCurrent: o,
                                partCurrent: l,
                                lastLoadedFragLevel: c
                            } = this, {
                                levels: d
                            } = this.hls, u = d[c], h = !(null == u || null == (a = u.details) || !a.live), f = null == u ? void 0 : u.codecSet, m = l ? l.duration : o ? o.duration : 0, p = this.bwEstimator.getEstimateTTFB() / 1e3;
                            let g = t,
                                y = -1;
                            for (let a = i; a >= t; a--) {
                                const t = d[a];
                                if (!t || f && t.codecSet !== f) {
                                    t && (g = Math.min(a, g), y = Math.max(a, y));
                                    continue
                                } - 1 !== y && Ee.trace(`[abr] Skipped level(s) ${g}-${y} with CODECS:"${d[y].attrs.CODECS}"; not compatible with "${u.attrs.CODECS}"`);
                                const i = t.details,
                                    o = (l ? null == i ? void 0 : i.partTarget : null == i ? void 0 : i.averagetargetduration) || m;
                                let v;
                                v = a <= c ? n * e : s * e;
                                const b = d[a].maxBitrate,
                                    T = this.getTimeToLoadFrag(p, v, b * o, void 0 === i);
                                if (Ee.trace(`[abr] level:${a} adjustedbw-bitrate:${Math.round(v-b)} avgDuration:${o.toFixed(1)} maxFetchDuration:${r.toFixed(1)} fetchDuration:${T.toFixed(1)}`), v > b && (0 === T || !ue(T) || h && !this.bitrateTestDelay || T < r)) return a
                            }
                            return -1
                        }
                        set nextAutoLevel(e) {
                            this._nextAutoLevel = e
                        }
                    },
                    bufferController: class {
                        constructor(e) {
                            this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = () => {
                                const {
                                    media: e,
                                    mediaSource: t
                                } = this;
                                Ee.log("[buffer-controller]: Media source opened"), e && (e.removeEventListener("emptied", this._onMediaEmptied), this.updateMediaElementDuration(), this.hls.trigger(me.MEDIA_ATTACHED, {
                                    media: e
                                })), t && t.removeEventListener("sourceopen", this._onMediaSourceOpen), this.checkPendingTracks()
                            }, this._onMediaSourceClose = () => {
                                Ee.log("[buffer-controller]: Media source closed")
                            }, this._onMediaSourceEnded = () => {
                                Ee.log("[buffer-controller]: Media source ended")
                            }, this._onMediaEmptied = () => {
                                const {
                                    media: e,
                                    _objectUrl: t
                                } = this;
                                e && e.src !== t && Ee.error(`Media element src was set while attaching MediaSource (${t} > ${e.src})`)
                            }, this.hls = e, this._initSourceBuffer(), this.registerListeners()
                        }
                        hasSourceTypes() {
                            return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
                        }
                        destroy() {
                            this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null
                        }
                        registerListeners() {
                            const {
                                hls: e
                            } = this;
                            e.on(me.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.MANIFEST_PARSED, this.onManifestParsed, this), e.on(me.BUFFER_RESET, this.onBufferReset, this), e.on(me.BUFFER_APPENDING, this.onBufferAppending, this), e.on(me.BUFFER_CODECS, this.onBufferCodecs, this), e.on(me.BUFFER_EOS, this.onBufferEos, this), e.on(me.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(me.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(me.FRAG_PARSED, this.onFragParsed, this), e.on(me.FRAG_CHANGED, this.onFragChanged, this)
                        }
                        unregisterListeners() {
                            const {
                                hls: e
                            } = this;
                            e.off(me.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.MANIFEST_PARSED, this.onManifestParsed, this), e.off(me.BUFFER_RESET, this.onBufferReset, this), e.off(me.BUFFER_APPENDING, this.onBufferAppending, this), e.off(me.BUFFER_CODECS, this.onBufferCodecs, this), e.off(me.BUFFER_EOS, this.onBufferEos, this), e.off(me.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(me.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(me.FRAG_PARSED, this.onFragParsed, this), e.off(me.FRAG_CHANGED, this.onFragChanged, this)
                        }
                        _initSourceBuffer() {
                            this.sourceBuffer = {}, this.operationQueue = new as(this.sourceBuffer), this.listeners = {
                                audio: [],
                                video: [],
                                audiovideo: []
                            }, this.lastMpegAudioChunk = null
                        }
                        onManifestLoading() {
                            this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null
                        }
                        onManifestParsed(e, t) {
                            let i = 2;
                            (t.audio && !t.video || !t.altAudio) && (i = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = i, Ee.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`)
                        }
                        onMediaAttaching(e, t) {
                            const i = this.media = t.media;
                            if (i && os) {
                                const e = this.mediaSource = new os;
                                e.addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), i.src = self.URL.createObjectURL(e), this._objectUrl = i.src, i.addEventListener("emptied", this._onMediaEmptied)
                            }
                        }
                        onMediaDetaching() {
                            const {
                                media: e,
                                mediaSource: t,
                                _objectUrl: i
                            } = this;
                            if (t) {
                                if (Ee.log("[buffer-controller]: media source detaching"), "open" === t.readyState) try {
                                    t.endOfStream()
                                } catch (e) {
                                    Ee.warn(`[buffer-controller]: onMediaDetaching: ${e.message} while calling endOfStream`)
                                }
                                this.onBufferReset(), t.removeEventListener("sourceopen", this._onMediaSourceOpen), t.removeEventListener("sourceended", this._onMediaSourceEnded), t.removeEventListener("sourceclose", this._onMediaSourceClose), e && (e.removeEventListener("emptied", this._onMediaEmptied), i && self.URL.revokeObjectURL(i), e.src === i ? (e.removeAttribute("src"), e.load()) : Ee.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
                            }
                            this.hls.trigger(me.MEDIA_DETACHED, void 0)
                        }
                        onBufferReset() {
                            this.getSourceBufferTypes().forEach((e => {
                                const t = this.sourceBuffer[e];
                                try {
                                    t && (this.removeBufferListeners(e), this.mediaSource && this.mediaSource.removeSourceBuffer(t), this.sourceBuffer[e] = void 0)
                                } catch (t) {
                                    Ee.warn(`[buffer-controller]: Failed to reset the ${e} buffer`, t)
                                }
                            })), this._initSourceBuffer()
                        }
                        onBufferCodecs(e, t) {
                            const i = this.getSourceBufferTypes().length;
                            Object.keys(t).forEach((e => {
                                if (i) {
                                    const i = this.tracks[e];
                                    if (i && "function" == typeof i.buffer.changeType) {
                                        const {
                                            id: r,
                                            codec: n,
                                            levelCodec: s,
                                            container: a,
                                            metadata: o
                                        } = t[e], l = (i.levelCodec || i.codec).replace(ls, "$1"), c = (s || n).replace(ls, "$1");
                                        if (l !== c) {
                                            const t = `${a};codecs=${s||n}`;
                                            this.appendChangeType(e, t), Ee.log(`[buffer-controller]: switching codec ${l} to ${c}`), this.tracks[e] = {
                                                buffer: i.buffer,
                                                codec: n,
                                                container: a,
                                                levelCodec: s,
                                                metadata: o,
                                                id: r
                                            }
                                        }
                                    }
                                } else this.pendingTracks[e] = t[e]
                            })), i || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
                        }
                        appendChangeType(e, t) {
                            const {
                                operationQueue: i
                            } = this, r = {
                                execute: () => {
                                    const r = this.sourceBuffer[e];
                                    r && (Ee.log(`[buffer-controller]: changing ${e} sourceBuffer type to ${t}`), r.changeType(t)), i.shiftAndExecuteNext(e)
                                },
                                onStart: () => {},
                                onComplete: () => {},
                                onError: t => {
                                    Ee.warn(`[buffer-controller]: Failed to change ${e} SourceBuffer type`, t)
                                }
                            };
                            i.append(r, e)
                        }
                        onBufferAppending(e, t) {
                            const {
                                hls: i,
                                operationQueue: r,
                                tracks: n
                            } = this, {
                                data: s,
                                type: a,
                                frag: o,
                                part: l,
                                chunkMeta: c
                            } = t, d = c.buffering[a], u = self.performance.now();
                            d.start = u;
                            const h = o.stats.buffering,
                                f = l ? l.stats.buffering : null;
                            0 === h.start && (h.start = u), f && 0 === f.start && (f.start = u);
                            const m = n.audio;
                            let p = !1;
                            "audio" === a && "audio/mpeg" === (null == m ? void 0 : m.container) && (p = !this.lastMpegAudioChunk || 1 === c.id || this.lastMpegAudioChunk.sn !== c.sn, this.lastMpegAudioChunk = c);
                            const g = o.start,
                                y = {
                                    execute: () => {
                                        if (d.executeStart = self.performance.now(), p) {
                                            const e = this.sourceBuffer[a];
                                            if (e) {
                                                const t = g - e.timestampOffset;
                                                Math.abs(t) >= .1 && (Ee.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${g} (delta: ${t}) sn: ${o.sn})`), e.timestampOffset = g)
                                            }
                                        }
                                        this.appendExecutor(s, a)
                                    },
                                    onStart: () => {},
                                    onComplete: () => {
                                        const e = self.performance.now();
                                        d.executeEnd = d.end = e, 0 === h.first && (h.first = e), f && 0 === f.first && (f.first = e);
                                        const {
                                            sourceBuffer: t
                                        } = this, i = {};
                                        for (const e in t) i[e] = Tr.getBuffered(t[e]);
                                        this.appendError = 0, this.hls.trigger(me.BUFFER_APPENDED, {
                                            type: a,
                                            frag: o,
                                            part: l,
                                            chunkMeta: c,
                                            parent: o.type,
                                            timeRanges: i
                                        })
                                    },
                                    onError: e => {
                                        Ee.error(`[buffer-controller]: Error encountered while trying to append to the ${a} SourceBuffer`, e);
                                        const t = {
                                            type: pe.MEDIA_ERROR,
                                            parent: o.type,
                                            details: ge.BUFFER_APPEND_ERROR,
                                            frag: o,
                                            part: l,
                                            chunkMeta: c,
                                            error: e,
                                            err: e,
                                            fatal: !1
                                        };
                                        e.code === DOMException.QUOTA_EXCEEDED_ERR ? t.details = ge.BUFFER_FULL_ERROR : (this.appendError++, t.details = ge.BUFFER_APPEND_ERROR, this.appendError > i.config.appendErrorMaxRetry && (Ee.error(`[buffer-controller]: Failed ${i.config.appendErrorMaxRetry} times to append segment in sourceBuffer`), t.fatal = !0)), i.trigger(me.ERROR, t)
                                    }
                                };
                            r.append(y, a)
                        }
                        onBufferFlushing(e, t) {
                            const {
                                operationQueue: i
                            } = this, r = e => ({
                                execute: this.removeExecutor.bind(this, e, t.startOffset, t.endOffset),
                                onStart: () => {},
                                onComplete: () => {
                                    this.hls.trigger(me.BUFFER_FLUSHED, {
                                        type: e
                                    })
                                },
                                onError: t => {
                                    Ee.warn(`[buffer-controller]: Failed to remove from ${e} SourceBuffer`, t)
                                }
                            });
                            t.type ? i.append(r(t.type), t.type) : this.getSourceBufferTypes().forEach((e => {
                                i.append(r(e), e)
                            }))
                        }
                        onFragParsed(e, t) {
                            const {
                                frag: i,
                                part: r
                            } = t, n = [], s = r ? r.elementaryStreams : i.elementaryStreams;
                            s[Ce] ? n.push("audiovideo") : (s[Re] && n.push("audio"), s[De] && n.push("video"));
                            0 === n.length && Ee.warn(`Fragments must have at least one ElementaryStreamType set. type: ${i.type} level: ${i.level} sn: ${i.sn}`), this.blockBuffers((() => {
                                const e = self.performance.now();
                                i.stats.buffering.end = e, r && (r.stats.buffering.end = e);
                                const t = r ? r.stats : i.stats;
                                this.hls.trigger(me.FRAG_BUFFERED, {
                                    frag: i,
                                    part: r,
                                    stats: t,
                                    id: i.type
                                })
                            }), n)
                        }
                        onFragChanged(e, t) {
                            this.flushBackBuffer()
                        }
                        onBufferEos(e, t) {
                            this.getSourceBufferTypes().reduce(((e, i) => {
                                const r = this.sourceBuffer[i];
                                return !r || t.type && t.type !== i || (r.ending = !0, r.ended || (r.ended = !0, Ee.log(`[buffer-controller]: ${i} sourceBuffer now EOS`))), e && !(r && !r.ended)
                            }), !0) && (Ee.log("[buffer-controller]: Queueing mediaSource.endOfStream()"), this.blockBuffers((() => {
                                this.getSourceBufferTypes().forEach((e => {
                                    const t = this.sourceBuffer[e];
                                    t && (t.ending = !1)
                                }));
                                const {
                                    mediaSource: e
                                } = this;
                                e && "open" === e.readyState ? (Ee.log("[buffer-controller]: Calling mediaSource.endOfStream()"), e.endOfStream()) : e && Ee.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${e.readyState}`)
                            })))
                        }
                        onLevelUpdated(e, {
                            details: t
                        }) {
                            t.fragments.length && (this.details = t, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
                        }
                        flushBackBuffer() {
                            const {
                                hls: e,
                                details: t,
                                media: i,
                                sourceBuffer: r
                            } = this;
                            if (!i || null === t) return;
                            const n = this.getSourceBufferTypes();
                            if (!n.length) return;
                            const s = t.live && null !== e.config.liveBackBufferLength ? e.config.liveBackBufferLength : e.config.backBufferLength;
                            if (!ue(s) || s < 0) return;
                            const a = i.currentTime,
                                o = t.levelTargetDuration,
                                l = Math.max(s, o),
                                c = Math.floor(a / o) * o - l;
                            n.forEach((i => {
                                const n = r[i];
                                if (n) {
                                    const r = Tr.getBuffered(n);
                                    if (r.length > 0 && c > r.start(0)) {
                                        if (e.trigger(me.BACK_BUFFER_REACHED, {
                                                bufferEnd: c
                                            }), t.live) e.trigger(me.LIVE_BACK_BUFFER_REACHED, {
                                            bufferEnd: c
                                        });
                                        else if (n.ended && r.end(r.length - 1) - a < 2 * o) return void Ee.info(`[buffer-controller]: Cannot flush ${i} back buffer while SourceBuffer is in ended state`);
                                        e.trigger(me.BUFFER_FLUSHING, {
                                            startOffset: 0,
                                            endOffset: c,
                                            type: i
                                        })
                                    }
                                }
                            }))
                        }
                        updateMediaElementDuration() {
                            if (!this.details || !this.media || !this.mediaSource || "open" !== this.mediaSource.readyState) return;
                            const {
                                details: e,
                                hls: t,
                                media: i,
                                mediaSource: r
                            } = this, n = e.fragments[0].start + e.totalduration, s = i.duration, a = ue(r.duration) ? r.duration : 0;
                            e.live && t.config.liveDurationInfinity ? (Ee.log("[buffer-controller]: Media Source duration is set to Infinity"), r.duration = 1 / 0, this.updateSeekableRange(e)) : (n > a && n > s || !ue(s)) && (Ee.log(`[buffer-controller]: Updating Media Source duration to ${n.toFixed(3)}`), r.duration = n)
                        }
                        updateSeekableRange(e) {
                            const t = this.mediaSource,
                                i = e.fragments;
                            if (i.length && e.live && null != t && t.setLiveSeekableRange) {
                                const r = Math.max(0, i[0].start),
                                    n = Math.max(r, r + e.totalduration);
                                t.setLiveSeekableRange(r, n)
                            }
                        }
                        checkPendingTracks() {
                            const {
                                bufferCodecEventsExpected: e,
                                operationQueue: t,
                                pendingTracks: i
                            } = this, r = Object.keys(i).length;
                            if (r && !e || 2 === r) {
                                this.createSourceBuffers(i), this.pendingTracks = {};
                                const e = this.getSourceBufferTypes();
                                if (e.length) this.hls.trigger(me.BUFFER_CREATED, {
                                    tracks: this.tracks
                                }), e.forEach((e => {
                                    t.executeNext(e)
                                }));
                                else {
                                    const e = new Error("could not create source buffer for media codec(s)");
                                    this.hls.trigger(me.ERROR, {
                                        type: pe.MEDIA_ERROR,
                                        details: ge.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                                        fatal: !0,
                                        error: e,
                                        reason: e.message
                                    })
                                }
                            }
                        }
                        createSourceBuffers(e) {
                            const {
                                sourceBuffer: t,
                                mediaSource: i
                            } = this;
                            if (!i) throw Error("createSourceBuffers called when mediaSource was null");
                            for (const r in e)
                                if (!t[r]) {
                                    const n = e[r];
                                    if (!n) throw Error(`source buffer exists for track ${r}, however track does not`);
                                    const s = n.levelCodec || n.codec,
                                        a = `${n.container};codecs=${s}`;
                                    Ee.log(`[buffer-controller]: creating sourceBuffer(${a})`);
                                    try {
                                        const e = t[r] = i.addSourceBuffer(a),
                                            o = r;
                                        this.addBufferListener(o, "updatestart", this._onSBUpdateStart), this.addBufferListener(o, "updateend", this._onSBUpdateEnd), this.addBufferListener(o, "error", this._onSBUpdateError), this.tracks[r] = {
                                            buffer: e,
                                            codec: s,
                                            container: n.container,
                                            levelCodec: n.levelCodec,
                                            metadata: n.metadata,
                                            id: n.id
                                        }
                                    } catch (e) {
                                        Ee.error(`[buffer-controller]: error while trying to add sourceBuffer: ${e.message}`), this.hls.trigger(me.ERROR, {
                                            type: pe.MEDIA_ERROR,
                                            details: ge.BUFFER_ADD_CODEC_ERROR,
                                            fatal: !1,
                                            error: e,
                                            mimeType: a
                                        })
                                    }
                                }
                        }
                        _onSBUpdateStart(e) {
                            const {
                                operationQueue: t
                            } = this;
                            t.current(e).onStart()
                        }
                        _onSBUpdateEnd(e) {
                            const {
                                operationQueue: t
                            } = this;
                            t.current(e).onComplete(), t.shiftAndExecuteNext(e)
                        }
                        _onSBUpdateError(e, t) {
                            const i = new Error(`${e} SourceBuffer error`);
                            Ee.error(`[buffer-controller]: ${i}`, t), this.hls.trigger(me.ERROR, {
                                type: pe.MEDIA_ERROR,
                                details: ge.BUFFER_APPENDING_ERROR,
                                error: i,
                                fatal: !1
                            });
                            const r = this.operationQueue.current(e);
                            r && r.onError(t)
                        }
                        removeExecutor(e, t, i) {
                            const {
                                media: r,
                                mediaSource: n,
                                operationQueue: s,
                                sourceBuffer: a
                            } = this, o = a[e];
                            if (!r || !n || !o) return Ee.warn(`[buffer-controller]: Attempting to remove from the ${e} SourceBuffer, but it does not exist`), void s.shiftAndExecuteNext(e);
                            const l = ue(r.duration) ? r.duration : 1 / 0,
                                c = ue(n.duration) ? n.duration : 1 / 0,
                                d = Math.max(0, t),
                                u = Math.min(i, l, c);
                            u > d && !o.ending ? (o.ended = !1, Ee.log(`[buffer-controller]: Removing [${d},${u}] from the ${e} SourceBuffer`), o.remove(d, u)) : s.shiftAndExecuteNext(e)
                        }
                        appendExecutor(e, t) {
                            const {
                                operationQueue: i,
                                sourceBuffer: r
                            } = this, n = r[t];
                            if (!n) return Ee.warn(`[buffer-controller]: Attempting to append to the ${t} SourceBuffer, but it does not exist`), void i.shiftAndExecuteNext(t);
                            n.ended = !1, n.appendBuffer(e)
                        }
                        blockBuffers(e, t = this.getSourceBufferTypes()) {
                            if (!t.length) return Ee.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), void Promise.resolve().then(e);
                            const {
                                operationQueue: i
                            } = this, r = t.map((e => i.appendBlocker(e)));
                            Promise.all(r).then((() => {
                                e(), t.forEach((e => {
                                    const t = this.sourceBuffer[e];
                                    null != t && t.updating || i.shiftAndExecuteNext(e)
                                }))
                            }))
                        }
                        getSourceBufferTypes() {
                            return Object.keys(this.sourceBuffer)
                        }
                        addBufferListener(e, t, i) {
                            const r = this.sourceBuffer[e];
                            if (!r) return;
                            const n = i.bind(this, e);
                            this.listeners[e].push({
                                event: t,
                                listener: n
                            }), r.addEventListener(t, n)
                        }
                        removeBufferListeners(e) {
                            const t = this.sourceBuffer[e];
                            t && this.listeners[e].forEach((e => {
                                t.removeEventListener(e.event, e.listener)
                            }))
                        }
                    },
                    capLevelController: ia,
                    errorController: class {
                        constructor(e) {
                            this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = Ee.log.bind(Ee, "[info]:"), this.warn = Ee.warn.bind(Ee, "[warning]:"), this.error = Ee.error.bind(Ee, "[error]:"), this.registerListeners()
                        }
                        registerListeners() {
                            const e = this.hls;
                            e.on(me.ERROR, this.onError, this), e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.LEVEL_UPDATED, this.onLevelUpdated, this)
                        }
                        unregisterListeners() {
                            const e = this.hls;
                            e && (e.off(me.ERROR, this.onError, this), e.off(me.ERROR, this.onErrorOut, this), e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.LEVEL_UPDATED, this.onLevelUpdated, this))
                        }
                        destroy() {
                            this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {}
                        }
                        startLoad(e) {
                            this.playlistError = 0
                        }
                        stopLoad() {}
                        getVariantLevelIndex(e) {
                            return (null == e ? void 0 : e.type) === ai ? e.level : this.hls.loadLevel
                        }
                        onManifestLoading() {
                            this.playlistError = 0, this.penalizedRenditions = {}
                        }
                        onLevelUpdated() {
                            this.playlistError = 0
                        }
                        onError(e, t) {
                            var i, r;
                            if (t.fatal) return;
                            const n = this.hls,
                                s = t.context;
                            switch (t.details) {
                                case ge.FRAG_LOAD_ERROR:
                                case ge.FRAG_LOAD_TIMEOUT:
                                case ge.KEY_LOAD_ERROR:
                                case ge.KEY_LOAD_TIMEOUT:
                                    return void(t.errorAction = this.getFragRetryOrSwitchAction(t));
                                case ge.FRAG_PARSING_ERROR:
                                    if (null != (i = t.frag) && i.gap) return void(t.errorAction = {
                                        action: Wi,
                                        flags: Xi
                                    });
                                case ge.FRAG_GAP:
                                case ge.FRAG_DECRYPT_ERROR:
                                    return t.errorAction = this.getFragRetryOrSwitchAction(t), void(t.errorAction.action = Yi);
                                case ge.LEVEL_EMPTY_ERROR:
                                case ge.LEVEL_PARSING_ERROR:
                                    {
                                        var a, o;
                                        const e = t.parent === ai ? t.level : n.loadLevel;t.details === ge.LEVEL_EMPTY_ERROR && null != (a = t.context) && null != (o = a.levelDetails) && o.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, e) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, e))
                                    }
                                    return;
                                case ge.LEVEL_LOAD_ERROR:
                                case ge.LEVEL_LOAD_TIMEOUT:
                                    return void("number" == typeof(null == s ? void 0 : s.level) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, s.level)));
                                case ge.AUDIO_TRACK_LOAD_ERROR:
                                case ge.AUDIO_TRACK_LOAD_TIMEOUT:
                                case ge.SUBTITLE_LOAD_ERROR:
                                case ge.SUBTITLE_TRACK_LOAD_TIMEOUT:
                                    if (s) {
                                        const e = n.levels[n.loadLevel];
                                        if (e && (s.type === ni && s.groupId === e.audioGroupId || s.type === si && s.groupId === e.textGroupId)) return t.errorAction = this.getPlaylistRetryOrSwitchAction(t, n.loadLevel), t.errorAction.action = Yi, void(t.errorAction.flags = Qi)
                                    }
                                    return;
                                case ge.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
                                    {
                                        const e = n.levels[n.loadLevel],
                                            i = null == e ? void 0 : e.attrs["HDCP-LEVEL"];i && (t.errorAction = {
                                            action: Yi,
                                            flags: Ji,
                                            hdcpLevel: i
                                        })
                                    }
                                    return;
                                case ge.BUFFER_ADD_CODEC_ERROR:
                                case ge.REMUX_ALLOC_ERROR:
                                    return void(t.errorAction = this.getLevelSwitchAction(t, null != (r = t.level) ? r : n.loadLevel));
                                case ge.INTERNAL_EXCEPTION:
                                case ge.BUFFER_APPENDING_ERROR:
                                case ge.BUFFER_APPEND_ERROR:
                                case ge.BUFFER_FULL_ERROR:
                                case ge.LEVEL_SWITCH_ERROR:
                                case ge.BUFFER_STALLED_ERROR:
                                case ge.BUFFER_SEEK_OVER_HOLE:
                                case ge.BUFFER_NUDGE_ON_STALL:
                                    return void(t.errorAction = {
                                        action: Wi,
                                        flags: Xi
                                    })
                            }
                            if (t.type === pe.KEY_SYSTEM_ERROR) {
                                const e = this.getVariantLevelIndex(t.frag);
                                return t.levelRetry = !1, void(t.errorAction = this.getLevelSwitchAction(t, e))
                            }
                        }
                        getPlaylistRetryOrSwitchAction(e, t) {
                            var i;
                            const r = Ui(this.hls.config.playlistLoadPolicy, e),
                                n = this.playlistError++,
                                s = null == (i = e.response) ? void 0 : i.code;
                            if (ji(r, n, Bi(e), s)) return {
                                action: zi,
                                flags: Xi,
                                retryConfig: r,
                                retryCount: n
                            };
                            const a = this.getLevelSwitchAction(e, t);
                            return r && (a.retryConfig = r, a.retryCount = n), a
                        }
                        getFragRetryOrSwitchAction(e) {
                            const t = this.hls,
                                i = this.getVariantLevelIndex(e.frag),
                                r = t.levels[i],
                                {
                                    fragLoadPolicy: n,
                                    keyLoadPolicy: s
                                } = t.config,
                                a = Ui(e.details.startsWith("key") ? s : n, e),
                                o = t.levels.reduce(((e, t) => e + t.fragmentError), 0);
                            if (r) {
                                var l;
                                e.details !== ge.FRAG_GAP && r.fragmentError++;
                                const t = null == (l = e.response) ? void 0 : l.code;
                                if (ji(a, o, Bi(e), t)) return {
                                    action: zi,
                                    flags: Xi,
                                    retryConfig: a,
                                    retryCount: o
                                }
                            }
                            const c = this.getLevelSwitchAction(e, i);
                            return a && (c.retryConfig = a, c.retryCount = o), c
                        }
                        getLevelSwitchAction(e, t) {
                            const i = this.hls;
                            null == t && (t = i.loadLevel);
                            const r = this.hls.levels[t];
                            if (r && (r.loadError++, i.autoLevelEnabled)) {
                                var n, s;
                                let t = -1;
                                const {
                                    levels: a,
                                    loadLevel: o,
                                    minAutoLevel: l,
                                    maxAutoLevel: c
                                } = i, d = null == (n = e.frag) ? void 0 : n.type, {
                                    type: u,
                                    groupId: h
                                } = null != (s = e.context) ? s : {};
                                for (let i = a.length; i--;) {
                                    const n = (i + o) % a.length;
                                    if (n !== o && n >= l && n <= c && 0 === a[n].loadError) {
                                        const i = a[n];
                                        if (e.details === ge.FRAG_GAP && e.frag) {
                                            const t = a[n].details;
                                            if (t) {
                                                const i = Vi(e.frag, t.fragments, e.frag.start);
                                                if (null != i && i.gap) continue
                                            }
                                        } else {
                                            if (u === ni && h === i.audioGroupId || u === si && h === i.textGroupId) continue;
                                            if (d === oi && r.audioGroupId === i.audioGroupId || d === li && r.textGroupId === i.textGroupId) continue
                                        }
                                        t = n;
                                        break
                                    }
                                }
                                if (t > -1 && i.loadLevel !== t) return e.levelRetry = !0, this.playlistError = 0, {
                                    action: Yi,
                                    flags: Xi,
                                    nextAutoLevel: t
                                }
                            }
                            return {
                                action: Yi,
                                flags: Qi
                            }
                        }
                        onErrorOut(e, t) {
                            var i;
                            switch (null == (i = t.errorAction) ? void 0 : i.action) {
                                case Wi:
                                    break;
                                case Yi:
                                    this.sendAlternateToPenaltyBox(t), t.errorAction.resolved || t.details === ge.FRAG_GAP || (t.fatal = !0)
                            }
                            t.fatal && this.hls.stopLoad()
                        }
                        sendAlternateToPenaltyBox(e) {
                            const t = this.hls,
                                i = e.errorAction;
                            if (!i) return;
                            const {
                                flags: r,
                                hdcpLevel: n,
                                nextAutoLevel: s
                            } = i;
                            switch (r) {
                                case Xi:
                                    this.switchLevel(e, s);
                                    break;
                                case Qi:
                                    i.resolved || (i.resolved = this.redundantFailover(e));
                                    break;
                                case Ji:
                                    n && (t.maxHdcpLevel = ki[ki.indexOf(n) - 1], i.resolved = !0), this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`)
                            }
                            i.resolved || this.switchLevel(e, s)
                        }
                        switchLevel(e, t) {
                            void 0 !== t && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel)
                        }
                        redundantFailover(e) {
                            const {
                                hls: t,
                                penalizedRenditions: i
                            } = this, r = e.parent === ai ? e.level : t.loadLevel, n = t.levels[r], s = n.url.length, a = e.frag ? e.frag.urlId : n.urlId;
                            n.urlId !== a || e.frag && !n.details || this.penalizeRendition(n, e);
                            for (let o = 1; o < s; o++) {
                                const l = (a + o) % s,
                                    c = i[l];
                                if (!c || Zi(c, e, i[a])) return this.warn(`Switching to Redundant Stream ${l+1}/${s}: "${n.url[l]}" after ${e.details}`), this.playlistError = 0, t.levels.forEach((e => {
                                    e.urlId = l
                                })), t.nextLoadLevel = r, !0
                            }
                            return !1
                        }
                        penalizeRendition(e, t) {
                            const {
                                penalizedRenditions: i
                            } = this, r = i[e.urlId] || {
                                lastErrorPerfMs: 0,
                                errors: [],
                                details: void 0
                            };
                            r.lastErrorPerfMs = performance.now(), r.errors.push(t), r.details = e.details, i[e.urlId] = r
                        }
                    },
                    fpsController: class {
                        constructor(e) {
                            this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners()
                        }
                        setStreamController(e) {
                            this.streamController = e
                        }
                        registerListeners() {
                            this.hls.on(me.MEDIA_ATTACHING, this.onMediaAttaching, this)
                        }
                        unregisterListeners() {
                            this.hls.off(me.MEDIA_ATTACHING, this.onMediaAttaching, this)
                        }
                        destroy() {
                            this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
                        }
                        onMediaAttaching(e, t) {
                            const i = this.hls.config;
                            if (i.capLevelOnFPSDrop) {
                                const e = t.media instanceof self.HTMLVideoElement ? t.media : null;
                                this.media = e, e && "function" == typeof e.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), i.fpsDroppedMonitoringPeriod)
                            }
                        }
                        checkFPS(e, t, i) {
                            const r = performance.now();
                            if (t) {
                                if (this.lastTime) {
                                    const e = r - this.lastTime,
                                        n = i - this.lastDroppedFrames,
                                        s = t - this.lastDecodedFrames,
                                        a = 1e3 * n / e,
                                        o = this.hls;
                                    if (o.trigger(me.FPS_DROP, {
                                            currentDropped: n,
                                            currentDecoded: s,
                                            totalDroppedFrames: i
                                        }), a > 0 && n > o.config.fpsDroppedMonitoringThreshold * s) {
                                        let e = o.currentLevel;
                                        Ee.warn("drop FPS ratio greater than max allowed value for currentLevel: " + e), e > 0 && (-1 === o.autoLevelCapping || o.autoLevelCapping >= e) && (e -= 1, o.trigger(me.FPS_DROP_LEVEL_CAPPING, {
                                            level: e,
                                            droppedLevel: o.currentLevel
                                        }), o.autoLevelCapping = e, this.streamController.nextLevelSwitch())
                                    }
                                }
                                this.lastTime = r, this.lastDroppedFrames = i, this.lastDecodedFrames = t
                            }
                        }
                        checkFPSInterval() {
                            const e = this.media;
                            if (e)
                                if (this.isVideoPlaybackQualityAvailable) {
                                    const t = e.getVideoPlaybackQuality();
                                    this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
                                } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
                        }
                    },
                    stretchShortVideoTrack: !1,
                    maxAudioFramesDrift: 1,
                    forceKeyFrameOnDiscontinuity: !0,
                    abrEwmaFastLive: 3,
                    abrEwmaSlowLive: 9,
                    abrEwmaFastVoD: 3,
                    abrEwmaSlowVoD: 9,
                    abrEwmaDefaultEstimate: 5e5,
                    abrBandWidthFactor: .95,
                    abrBandWidthUpFactor: .7,
                    abrMaxWithRealBitrate: !1,
                    maxStarvationDelay: 4,
                    maxLoadingDelay: 4,
                    minAutoBitrate: 0,
                    emeEnabled: !1,
                    widevineLicenseUrl: void 0,
                    drmSystems: {},
                    drmSystemOptions: {},
                    requestMediaKeySystemAccessFunc: We,
                    testBandwidth: !0,
                    progressive: !1,
                    lowLatencyMode: !0,
                    cmcd: void 0,
                    enableDateRangeMetadataCues: !0,
                    enableEmsgMetadataCues: !0,
                    enableID3MetadataCues: !0,
                    certLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 8e3,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: null,
                            errorRetry: null
                        }
                    },
                    keyLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 8e3,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: {
                                maxNumRetry: 1,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 2e4,
                                backoff: "linear"
                            },
                            errorRetry: {
                                maxNumRetry: 8,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 2e4,
                                backoff: "linear"
                            }
                        }
                    },
                    manifestLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 1 / 0,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: {
                                maxNumRetry: 2,
                                retryDelayMs: 0,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 1,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 8e3
                            }
                        }
                    },
                    playlistLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 1e4,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: {
                                maxNumRetry: 2,
                                retryDelayMs: 0,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 2,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 8e3
                            }
                        }
                    },
                    fragLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 1e4,
                            maxLoadTimeMs: 12e4,
                            timeoutRetry: {
                                maxNumRetry: 4,
                                retryDelayMs: 0,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 6,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 8e3
                            }
                        }
                    },
                    steeringManifestLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 1e4,
                            maxLoadTimeMs: 2e4,
                            timeoutRetry: {
                                maxNumRetry: 2,
                                retryDelayMs: 0,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 1,
                                retryDelayMs: 1e3,
                                maxRetryDelayMs: 8e3
                            }
                        }
                    },
                    manifestLoadingTimeOut: 1e4,
                    manifestLoadingMaxRetry: 1,
                    manifestLoadingRetryDelay: 1e3,
                    manifestLoadingMaxRetryTimeout: 64e3,
                    levelLoadingTimeOut: 1e4,
                    levelLoadingMaxRetry: 4,
                    levelLoadingRetryDelay: 1e3,
                    levelLoadingMaxRetryTimeout: 64e3,
                    fragLoadingTimeOut: 2e4,
                    fragLoadingMaxRetry: 6,
                    fragLoadingRetryDelay: 1e3,
                    fragLoadingMaxRetryTimeout: 64e3
                }, {
                    cueHandler: Aa,
                    enableWebVTT: !0,
                    enableIMSC1: !0,
                    enableCEA708Captions: !0,
                    captionsTextTrack1Label: "English",
                    captionsTextTrack1LanguageCode: "en",
                    captionsTextTrack2Label: "Spanish",
                    captionsTextTrack2LanguageCode: "es",
                    captionsTextTrack3Label: "Unknown CC",
                    captionsTextTrack3LanguageCode: "",
                    captionsTextTrack4Label: "Unknown CC",
                    captionsTextTrack4LanguageCode: "",
                    renderTextTracksNatively: !0
                }), {}, {
                    subtitleStreamController: class extends Vr {
                        constructor(e, t, i) {
                            super(e, t, i, "[subtitle-stream-controller]", li), this.levels = [], this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this._registerListeners()
                        }
                        onHandlerDestroying() {
                            this._unregisterListeners(), this.mainDetails = null
                        }
                        _registerListeners() {
                            const {
                                hls: e
                            } = this;
                            e.on(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.LEVEL_LOADED, this.onLevelLoaded, this), e.on(me.ERROR, this.onError, this), e.on(me.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(me.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(me.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(me.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(me.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(me.FRAG_BUFFERED, this.onFragBuffered, this)
                        }
                        _unregisterListeners() {
                            const {
                                hls: e
                            } = this;
                            e.off(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.LEVEL_LOADED, this.onLevelLoaded, this), e.off(me.ERROR, this.onError, this), e.off(me.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(me.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(me.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(me.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(me.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(me.FRAG_BUFFERED, this.onFragBuffered, this)
                        }
                        startLoad(e) {
                            this.stopLoad(), this.state = xr, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
                        }
                        onManifestLoading() {
                            this.mainDetails = null, this.fragmentTracker.removeAllFragments()
                        }
                        onMediaDetaching() {
                            this.tracksBuffered = [], super.onMediaDetaching()
                        }
                        onLevelLoaded(e, t) {
                            this.mainDetails = t.details
                        }
                        onSubtitleFragProcessed(e, t) {
                            const {
                                frag: i,
                                success: r
                            } = t;
                            if (this.fragPrevious = i, this.state = xr, !r) return;
                            const n = this.tracksBuffered[this.currentTrackId];
                            if (!n) return;
                            let s;
                            const a = i.start;
                            for (let e = 0; e < n.length; e++)
                                if (a >= n[e].start && a <= n[e].end) {
                                    s = n[e];
                                    break
                                }
                            const o = i.start + i.duration;
                            s ? s.end = o : (s = {
                                start: a,
                                end: o
                            }, n.push(s)), this.fragmentTracker.fragBuffered(i)
                        }
                        onBufferFlushing(e, t) {
                            const {
                                startOffset: i,
                                endOffset: r
                            } = t;
                            if (0 === i && r !== Number.POSITIVE_INFINITY) {
                                const e = r - 1;
                                if (e <= 0) return;
                                t.endOffsetSubtitles = Math.max(0, e), this.tracksBuffered.forEach((t => {
                                    for (let i = 0; i < t.length;)
                                        if (t[i].end <= e) t.shift();
                                        else {
                                            if (!(t[i].start < e)) break;
                                            t[i].start = e, i++
                                        }
                                })), this.fragmentTracker.removeFragmentsInRange(i, e, li)
                            }
                        }
                        onFragBuffered(e, t) {
                            var i;
                            this.loadedmetadata || t.frag.type !== ai || null != (i = this.media) && i.buffered.length && (this.loadedmetadata = !0)
                        }
                        onError(e, t) {
                            const i = t.frag;
                            (null == i ? void 0 : i.type) === li && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state !== Pr && (this.state = xr))
                        }
                        onSubtitleTracksUpdated(e, {
                            subtitleTracks: t
                        }) {
                            is(this.levels, t) ? this.levels = t.map((e => new Ci(e))) : (this.tracksBuffered = [], this.levels = t.map((e => {
                                const t = new Ci(e);
                                return this.tracksBuffered[t.id] = [], t
                            })), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, li), this.fragPrevious = null, this.mediaBuffer = null)
                        }
                        onSubtitleTrackSwitch(e, t) {
                            if (this.currentTrackId = t.id, !this.levels.length || -1 === this.currentTrackId) return void this.clearInterval();
                            const i = this.levels[this.currentTrackId];
                            null != i && i.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, i && this.setInterval(500)
                        }
                        onSubtitleTrackLoaded(e, t) {
                            var i;
                            const {
                                details: r,
                                id: n
                            } = t, {
                                currentTrackId: s,
                                levels: a
                            } = this;
                            if (!a.length) return;
                            const o = a[s];
                            if (n >= a.length || n !== s || !o) return;
                            this.mediaBuffer = this.mediaBufferTimeRanges;
                            let l = 0;
                            if (r.live || null != (i = o.details) && i.live) {
                                const e = this.mainDetails;
                                if (r.deltaUpdateFailed || !e) return;
                                const t = e.fragments[0];
                                o.details ? (l = this.alignPlaylists(r, o.details), 0 === l && t && (l = t.start, Mi(r, l))) : r.hasProgramDateTime && e.hasProgramDateTime ? (Sr(r, e), l = r.fragments[0].start) : t && (l = t.start, Mi(r, l))
                            }
                            if (o.details = r, this.levelLastLoaded = n, this.startFragRequested || !this.mainDetails && r.live || this.setStartPosition(o.details, l), this.tick(), r.live && !this.fragCurrent && this.media && this.state === xr) {
                                Vi(null, r.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), o.details = void 0)
                            }
                        }
                        _handleFragmentLoadComplete(e) {
                            const {
                                frag: t,
                                payload: i
                            } = e, r = t.decryptdata, n = this.hls;
                            if (!this.fragContextChanged(t) && i && i.byteLength > 0 && r && r.key && r.iv && "AES-128" === r.method) {
                                const e = performance.now();
                                this.decrypter.decrypt(new Uint8Array(i), r.key.buffer, r.iv.buffer).catch((e => {
                                    throw n.trigger(me.ERROR, {
                                        type: pe.MEDIA_ERROR,
                                        details: ge.FRAG_DECRYPT_ERROR,
                                        fatal: !1,
                                        error: e,
                                        reason: e.message,
                                        frag: t
                                    }), e
                                })).then((i => {
                                    const r = performance.now();
                                    n.trigger(me.FRAG_DECRYPTED, {
                                        frag: t,
                                        payload: i,
                                        stats: {
                                            tstart: e,
                                            tdecrypt: r
                                        }
                                    })
                                })).catch((e => {
                                    this.warn(`${e.name}: ${e.message}`), this.state = xr
                                }))
                            }
                        }
                        doTick() {
                            if (this.media) {
                                if (this.state === xr) {
                                    const {
                                        currentTrackId: e,
                                        levels: t
                                    } = this, i = t[e];
                                    if (!t.length || !i || !i.details) return;
                                    const {
                                        config: r
                                    } = this, n = this.getLoadPosition(), s = Tr.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], n, r.maxBufferHole), {
                                        end: a,
                                        len: o
                                    } = s, l = this.getFwdBufferInfo(this.media, ai), c = i.details;
                                    if (o > this.getMaxBufferLength(null == l ? void 0 : l.len) + c.levelTargetDuration) return;
                                    const d = c.fragments,
                                        u = d.length,
                                        h = c.edge;
                                    let f = null;
                                    const m = this.fragPrevious;
                                    if (a < h) {
                                        const e = r.maxFragLookUpTolerance,
                                            t = a > h - e ? 0 : e;
                                        f = Vi(m, d, Math.max(d[0].start, a), t), !f && m && m.start < d[0].start && (f = d[0])
                                    } else f = d[u - 1];
                                    if (!f) return;
                                    if (f = this.mapToInitFragWhenRequired(f), "initSegment" !== f.sn) {
                                        const e = d[f.sn - c.startSN - 1];
                                        e && e.cc === f.cc && this.fragmentTracker.getState(e) === sr && (f = e)
                                    }
                                    this.fragmentTracker.getState(f) === sr && this.loadFragment(f, i, a)
                                }
                            } else this.state = xr
                        }
                        getMaxBufferLength(e) {
                            const t = super.getMaxBufferLength();
                            return e ? Math.max(t, e) : t
                        }
                        loadFragment(e, t, i) {
                            this.fragCurrent = e, "initSegment" === e.sn ? this._loadInitSegment(e, t) : (this.startFragRequested = !0, super.loadFragment(e, t, i))
                        }
                        get mediaBufferTimeRanges() {
                            return new ns(this.tracksBuffered[this.currentTrackId] || [])
                        }
                    },
                    subtitleTrackController: class extends er {
                        constructor(e) {
                            super(e, "[subtitle-track-controller]"), this.media = null, this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.trackChangeListener = () => this.onTextTracksChanged(), this.asyncPollTrackChange = () => this.pollTrackChange(0), this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.registerListeners()
                        }
                        destroy() {
                            this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, super.destroy()
                        }
                        get subtitleDisplay() {
                            return this._subtitleDisplay
                        }
                        set subtitleDisplay(e) {
                            this._subtitleDisplay = e, this.trackId > -1 && this.toggleTrackModes(this.trackId)
                        }
                        registerListeners() {
                            const {
                                hls: e
                            } = this;
                            e.on(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.MANIFEST_PARSED, this.onManifestParsed, this), e.on(me.LEVEL_LOADING, this.onLevelLoading, this), e.on(me.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(me.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(me.ERROR, this.onError, this)
                        }
                        unregisterListeners() {
                            const {
                                hls: e
                            } = this;
                            e.off(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.MANIFEST_PARSED, this.onManifestParsed, this), e.off(me.LEVEL_LOADING, this.onLevelLoading, this), e.off(me.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(me.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(me.ERROR, this.onError, this)
                        }
                        onMediaAttached(e, t) {
                            this.media = t.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
                        }
                        pollTrackChange(e) {
                            self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e)
                        }
                        onMediaDetaching() {
                            if (!this.media) return;
                            self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId);
                            ss(this.media.textTracks).forEach((e => {
                                mi(e)
                            })), this.subtitleTrack = -1, this.media = null
                        }
                        onManifestLoading() {
                            this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0
                        }
                        onManifestParsed(e, t) {
                            this.tracks = t.subtitleTracks
                        }
                        onSubtitleTrackLoaded(e, t) {
                            const {
                                id: i,
                                details: r
                            } = t, {
                                trackId: n
                            } = this, s = this.tracksInGroup[n];
                            if (!s) return void this.warn(`Invalid subtitle track id ${i}`);
                            const a = s.details;
                            s.details = t.details, this.log(`subtitle track ${i} loaded [${r.startSN}-${r.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, a)
                        }
                        onLevelLoading(e, t) {
                            this.switchLevel(t.level)
                        }
                        onLevelSwitching(e, t) {
                            this.switchLevel(t.level)
                        }
                        switchLevel(e) {
                            const t = this.hls.levels[e];
                            if (null == t || !t.textGroupIds) return;
                            const i = t.textGroupIds[t.urlId],
                                r = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
                            if (this.groupId !== i) {
                                const e = this.tracks.filter((e => !i || e.groupId === i));
                                this.tracksInGroup = e;
                                const t = this.findTrackId(null == r ? void 0 : r.name) || this.findTrackId();
                                this.groupId = i || null;
                                const n = {
                                    subtitleTracks: e
                                };
                                this.log(`Updating subtitle tracks, ${e.length} track(s) found in "${i}" group-id`), this.hls.trigger(me.SUBTITLE_TRACKS_UPDATED, n), -1 !== t && this.setSubtitleTrack(t, r)
                            } else this.shouldReloadPlaylist(r) && this.setSubtitleTrack(this.trackId, r)
                        }
                        findTrackId(e) {
                            const t = this.tracksInGroup;
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                if ((!this.selectDefaultTrack || r.default) && (!e || e === r.name)) return r.id
                            }
                            return -1
                        }
                        onError(e, t) {
                            !t.fatal && t.context && t.context.type === si && t.context.id === this.trackId && t.context.groupId === this.groupId && this.checkRetry(t)
                        }
                        get subtitleTracks() {
                            return this.tracksInGroup
                        }
                        get subtitleTrack() {
                            return this.trackId
                        }
                        set subtitleTrack(e) {
                            this.selectDefaultTrack = !1;
                            const t = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
                            this.setSubtitleTrack(e, t)
                        }
                        loadPlaylist(e) {
                            super.loadPlaylist();
                            const t = this.tracksInGroup[this.trackId];
                            if (this.shouldLoadPlaylist(t)) {
                                const i = t.id,
                                    r = t.groupId;
                                let n = t.url;
                                if (e) try {
                                    n = e.addDirectives(n)
                                } catch (e) {
                                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
                                }
                                this.log(`Loading subtitle playlist for id ${i}`), this.hls.trigger(me.SUBTITLE_TRACK_LOADING, {
                                    url: n,
                                    id: i,
                                    groupId: r,
                                    deliveryDirectives: e || null
                                })
                            }
                        }
                        toggleTrackModes(e) {
                            const {
                                media: t,
                                trackId: i
                            } = this;
                            if (!t) return;
                            const r = ss(t.textTracks),
                                n = r.filter((e => e.groupId === this.groupId));
                            if (-1 === e)[].slice.call(r).forEach((e => {
                                e.mode = "disabled"
                            }));
                            else {
                                const e = n[i];
                                e && (e.mode = "disabled")
                            }
                            const s = n[e];
                            s && (s.mode = this.subtitleDisplay ? "showing" : "hidden")
                        }
                        setSubtitleTrack(e, t) {
                            var i;
                            const r = this.tracksInGroup;
                            if (!this.media) return void(this.queuedDefaultTrack = e);
                            if (this.trackId !== e && this.toggleTrackModes(e), this.trackId === e && (-1 === e || null != (i = r[e]) && i.details) || e < -1 || e >= r.length) return;
                            this.clearTimer();
                            const n = r[e];
                            if (this.log(`Switching to subtitle-track ${e}` + (n ? ` "${n.name}" lang:${n.lang} group:${n.groupId}` : "")), this.trackId = e, n) {
                                const {
                                    id: e,
                                    groupId: i = "",
                                    name: r,
                                    type: s,
                                    url: a
                                } = n;
                                this.hls.trigger(me.SUBTITLE_TRACK_SWITCH, {
                                    id: e,
                                    groupId: i,
                                    name: r,
                                    type: s,
                                    url: a
                                });
                                const o = this.switchParams(n.url, null == t ? void 0 : t.details);
                                this.loadPlaylist(o)
                            } else this.hls.trigger(me.SUBTITLE_TRACK_SWITCH, {
                                id: e
                            })
                        }
                        onTextTracksChanged() {
                            if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively) return;
                            let e = -1;
                            const t = ss(this.media.textTracks);
                            for (let i = 0; i < t.length; i++)
                                if ("hidden" === t[i].mode) e = i;
                                else if ("showing" === t[i].mode) {
                                e = i;
                                break
                            }
                            this.subtitleTrack !== e && (this.subtitleTrack = e)
                        }
                    },
                    timelineController: class {
                        constructor(e) {
                            if (this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                                    ccOffset: 0,
                                    presentationOffset: 0,
                                    0: {
                                        start: 0,
                                        prevCC: -1,
                                        new: !0
                                    }
                                }, this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {
                                    textTrack1: {
                                        label: this.config.captionsTextTrack1Label,
                                        languageCode: this.config.captionsTextTrack1LanguageCode
                                    },
                                    textTrack2: {
                                        label: this.config.captionsTextTrack2Label,
                                        languageCode: this.config.captionsTextTrack2LanguageCode
                                    },
                                    textTrack3: {
                                        label: this.config.captionsTextTrack3Label,
                                        languageCode: this.config.captionsTextTrack3LanguageCode
                                    },
                                    textTrack4: {
                                        label: this.config.captionsTextTrack4Label,
                                        languageCode: this.config.captionsTextTrack4LanguageCode
                                    }
                                }, this.config.enableCEA708Captions) {
                                const e = new Rs(this, "textTrack1"),
                                    t = new Rs(this, "textTrack2"),
                                    i = new Rs(this, "textTrack3"),
                                    r = new Rs(this, "textTrack4");
                                this.cea608Parser1 = new ks(1, e, t), this.cea608Parser2 = new ks(3, i, r)
                            }
                            e.on(me.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(me.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(me.FRAG_LOADING, this.onFragLoading, this), e.on(me.FRAG_LOADED, this.onFragLoaded, this), e.on(me.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(me.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(me.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(me.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(me.BUFFER_FLUSHING, this.onBufferFlushing, this)
                        }
                        destroy() {
                            const {
                                hls: e
                            } = this;
                            e.off(me.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(me.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(me.FRAG_LOADING, this.onFragLoading, this), e.off(me.FRAG_LOADED, this.onFragLoaded, this), e.off(me.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(me.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(me.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(me.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(me.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null
                        }
                        addCues(e, t, i, r, n) {
                            let s = !1;
                            for (let e = n.length; e--;) {
                                const r = n[e],
                                    d = (a = r[0], o = r[1], l = t, c = i, Math.min(o, c) - Math.max(a, l));
                                if (d >= 0 && (r[0] = Math.min(r[0], t), r[1] = Math.max(r[1], i), s = !0, d / (i - t) > .5)) return
                            }
                            var a, o, l, c;
                            if (s || n.push([t, i]), this.config.renderTextTracksNatively) {
                                const n = this.captionsTracks[e];
                                this.Cues.newCue(n, t, i, r)
                            } else {
                                const n = this.Cues.newCue(null, t, i, r);
                                this.hls.trigger(me.CUES_PARSED, {
                                    type: "captions",
                                    cues: n,
                                    track: e
                                })
                            }
                        }
                        onInitPtsFound(e, {
                            frag: t,
                            id: i,
                            initPTS: r,
                            timescale: n
                        }) {
                            const {
                                unparsedVttFrags: s
                            } = this;
                            "main" === i && (this.initPTS[t.cc] = {
                                baseTime: r,
                                timescale: n
                            }), s.length && (this.unparsedVttFrags = [], s.forEach((e => {
                                this.onFragLoaded(me.FRAG_LOADED, e)
                            })))
                        }
                        getExistingTrack(e) {
                            const {
                                media: t
                            } = this;
                            if (t)
                                for (let i = 0; i < t.textTracks.length; i++) {
                                    const r = t.textTracks[i];
                                    if (r[e]) return r
                                }
                            return null
                        }
                        createCaptionsTrack(e) {
                            this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
                        }
                        createNativeTrack(e) {
                            if (this.captionsTracks[e]) return;
                            const {
                                captionsProperties: t,
                                captionsTracks: i,
                                media: r
                            } = this, {
                                label: n,
                                languageCode: s
                            } = t[e], a = this.getExistingTrack(e);
                            if (a) i[e] = a, mi(i[e]), hi(i[e], r);
                            else {
                                const t = this.createTextTrack("captions", n, s);
                                t && (t[e] = !0, i[e] = t)
                            }
                        }
                        createNonNativeTrack(e) {
                            if (this.nonNativeCaptionsTracks[e]) return;
                            const t = this.captionsProperties[e];
                            if (!t) return;
                            const i = {
                                _id: e,
                                label: t.label,
                                kind: "captions",
                                default: !!t.media && !!t.media.default,
                                closedCaptions: t.media
                            };
                            this.nonNativeCaptionsTracks[e] = i, this.hls.trigger(me.NON_NATIVE_TEXT_TRACKS_FOUND, {
                                tracks: [i]
                            })
                        }
                        createTextTrack(e, t, i) {
                            const r = this.media;
                            if (r) return r.addTextTrack(e, t, i)
                        }
                        onMediaAttaching(e, t) {
                            this.media = t.media, this._cleanTracks()
                        }
                        onMediaDetaching() {
                            const {
                                captionsTracks: e
                            } = this;
                            Object.keys(e).forEach((t => {
                                mi(e[t]), delete e[t]
                            })), this.nonNativeCaptionsTracks = {}
                        }
                        onManifestLoading() {
                            this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
                                ccOffset: 0,
                                presentationOffset: 0,
                                0: {
                                    start: 0,
                                    prevCC: -1,
                                    new: !0
                                }
                            }, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
                        }
                        _cleanTracks() {
                            const {
                                media: e
                            } = this;
                            if (!e) return;
                            const t = e.textTracks;
                            if (t)
                                for (let e = 0; e < t.length; e++) mi(t[e])
                        }
                        onSubtitleTracksUpdated(e, t) {
                            const i = t.subtitleTracks || [],
                                r = i.some((e => e.textCodec === Vs));
                            if (this.config.enableWebVTT || r && this.config.enableIMSC1) {
                                if (is(this.tracks, i)) return void(this.tracks = i);
                                if (this.textTracks = [], this.tracks = i, this.config.renderTextTracksNatively) {
                                    const e = this.media ? this.media.textTracks : null;
                                    this.tracks.forEach(((t, i) => {
                                        let r;
                                        if (e && i < e.length) {
                                            let i = null;
                                            for (let r = 0; r < e.length; r++)
                                                if (ta(e[r], t)) {
                                                    i = e[r];
                                                    break
                                                }
                                            i && (r = i)
                                        }
                                        if (r) mi(r);
                                        else {
                                            const e = this._captionsOrSubtitlesFromCharacteristics(t);
                                            r = this.createTextTrack(e, t.name, t.lang), r && (r.mode = "disabled")
                                        }
                                        r && (r.groupId = t.groupId, this.textTracks.push(r))
                                    }))
                                } else if (this.tracks.length) {
                                    const e = this.tracks.map((e => ({
                                        label: e.name,
                                        kind: e.type.toLowerCase(),
                                        default: e.default,
                                        subtitleTrack: e
                                    })));
                                    this.hls.trigger(me.NON_NATIVE_TEXT_TRACKS_FOUND, {
                                        tracks: e
                                    })
                                }
                            }
                        }
                        _captionsOrSubtitlesFromCharacteristics(e) {
                            if (e.attrs.CHARACTERISTICS) {
                                const t = /transcribes-spoken-dialog/gi.test(e.attrs.CHARACTERISTICS),
                                    i = /describes-music-and-sound/gi.test(e.attrs.CHARACTERISTICS);
                                if (t && i) return "captions"
                            }
                            return "subtitles"
                        }
                        onManifestLoaded(e, t) {
                            this.config.enableCEA708Captions && t.captions && t.captions.forEach((e => {
                                const t = /(?:CC|SERVICE)([1-4])/.exec(e.instreamId);
                                if (!t) return;
                                const i = `textTrack${t[1]}`,
                                    r = this.captionsProperties[i];
                                r && (r.label = e.name, e.lang && (r.languageCode = e.lang), r.media = e)
                            }))
                        }
                        closedCaptionsForLevel(e) {
                            const t = this.hls.levels[e.level];
                            return null == t ? void 0 : t.attrs["CLOSED-CAPTIONS"]
                        }
                        onFragLoading(e, t) {
                            const {
                                cea608Parser1: i,
                                cea608Parser2: r,
                                lastSn: n,
                                lastPartIndex: s
                            } = this;
                            if (this.enabled && i && r && t.frag.type === ai) {
                                var a, o;
                                const e = t.frag.sn,
                                    l = null != (a = null == t || null == (o = t.part) ? void 0 : o.index) ? a : -1;
                                e === n + 1 || e === n && l === s + 1 || (i.reset(), r.reset()), this.lastSn = e, this.lastPartIndex = l
                            }
                        }
                        onFragLoaded(e, t) {
                            const {
                                frag: i,
                                payload: r
                            } = t;
                            if (i.type === li)
                                if (r.byteLength) {
                                    const e = i.decryptdata,
                                        n = "stats" in t;
                                    if (null == e || !e.encrypted || n) {
                                        const e = this.tracks[i.level],
                                            n = this.vttCCs;
                                        n[i.cc] || (n[i.cc] = {
                                            start: i.start,
                                            prevCC: this.prevCC,
                                            new: !0
                                        }, this.prevCC = i.cc), e && e.textCodec === Vs ? this._parseIMSC1(i, r) : this._parseVTTs(t)
                                    }
                                } else this.hls.trigger(me.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: i,
                                    error: new Error("Empty subtitle payload")
                                })
                        }
                        _parseIMSC1(e, t) {
                            const i = this.hls;
                            Ys(t, this.initPTS[e.cc], (t => {
                                this._appendCues(t, e.level), i.trigger(me.SUBTITLE_FRAG_PROCESSED, {
                                    success: !0,
                                    frag: e
                                })
                            }), (t => {
                                Ee.log(`Failed to parse IMSC1: ${t}`), i.trigger(me.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: e,
                                    error: t
                                })
                            }))
                        }
                        _parseVTTs(e) {
                            var t;
                            const {
                                frag: i,
                                payload: r
                            } = e, {
                                initPTS: n,
                                unparsedVttFrags: s
                            } = this, a = n.length - 1;
                            if (!n[i.cc] && -1 === a) return void s.push(e);
                            const o = this.hls;
                            Gs(null != (t = i.initSegment) && t.data ? kt(i.initSegment.data, new Uint8Array(r)) : r, this.initPTS[i.cc], this.vttCCs, i.cc, i.start, (e => {
                                this._appendCues(e, i.level), o.trigger(me.SUBTITLE_FRAG_PROCESSED, {
                                    success: !0,
                                    frag: i
                                })
                            }), (t => {
                                const n = "Missing initPTS for VTT MPEGTS" === t.message;
                                n ? s.push(e) : this._fallbackToIMSC1(i, r), Ee.log(`Failed to parse VTT cue: ${t}`), n && a > i.cc || o.trigger(me.SUBTITLE_FRAG_PROCESSED, {
                                    success: !1,
                                    frag: i,
                                    error: t
                                })
                            }))
                        }
                        _fallbackToIMSC1(e, t) {
                            const i = this.tracks[e.level];
                            i.textCodec || Ys(t, this.initPTS[e.cc], (() => {
                                i.textCodec = Vs, this._parseIMSC1(e, t)
                            }), (() => {
                                i.textCodec = "wvtt"
                            }))
                        }
                        _appendCues(e, t) {
                            const i = this.hls;
                            if (this.config.renderTextTracksNatively) {
                                const i = this.textTracks[t];
                                if (!i || "disabled" === i.mode) return;
                                e.forEach((e => fi(i, e)))
                            } else {
                                const r = this.tracks[t];
                                if (!r) return;
                                const n = r.default ? "default" : "subtitles" + t;
                                i.trigger(me.CUES_PARSED, {
                                    type: "subtitles",
                                    cues: e,
                                    track: n
                                })
                            }
                        }
                        onFragDecrypted(e, t) {
                            const {
                                frag: i
                            } = t;
                            i.type === li && this.onFragLoaded(me.FRAG_LOADED, t)
                        }
                        onSubtitleTracksCleared() {
                            this.tracks = [], this.captionsTracks = {}
                        }
                        onFragParsingUserdata(e, t) {
                            const {
                                cea608Parser1: i,
                                cea608Parser2: r
                            } = this;
                            if (!this.enabled || !i || !r) return;
                            const {
                                frag: n,
                                samples: s
                            } = t;
                            if (n.type !== ai || "NONE" !== this.closedCaptionsForLevel(n))
                                for (let e = 0; e < s.length; e++) {
                                    const t = s[e].bytes;
                                    if (t) {
                                        const n = this.extractCea608Data(t);
                                        i.addData(s[e].pts, n[0]), r.addData(s[e].pts, n[1])
                                    }
                                }
                        }
                        onBufferFlushing(e, {
                            startOffset: t,
                            endOffset: i,
                            endOffsetSubtitles: r,
                            type: n
                        }) {
                            const {
                                media: s
                            } = this;
                            if (s && !(s.currentTime < i)) {
                                if (!n || "video" === n) {
                                    const {
                                        captionsTracks: e
                                    } = this;
                                    Object.keys(e).forEach((r => pi(e[r], t, i)))
                                }
                                if (this.config.renderTextTracksNatively && 0 === t && void 0 !== r) {
                                    const {
                                        textTracks: e
                                    } = this;
                                    Object.keys(e).forEach((i => pi(e[i], t, r)))
                                }
                            }
                        }
                        extractCea608Data(e) {
                            const t = [
                                    [],
                                    []
                                ],
                                i = 31 & e[0];
                            let r = 2;
                            for (let n = 0; n < i; n++) {
                                const i = e[r++],
                                    n = 127 & e[r++],
                                    s = 127 & e[r++];
                                if (0 === n && 0 === s) continue;
                                if (!!(4 & i)) {
                                    const e = 3 & i;
                                    0 !== e && 1 !== e || (t[e].push(n), t[e].push(s))
                                }
                            }
                            return t
                        }
                    },
                    audioStreamController: class extends Vr {
                        constructor(e, t, i) {
                            super(e, t, i, "[audio-stream-controller]", oi), this.videoBuffer = null, this.videoTrackCC = -1, this.waitingVideoCC = -1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this._registerListeners()
                        }
                        onHandlerDestroying() {
                            this._unregisterListeners(), this.mainDetails = null, this.bufferedTrack = null, this.switchingTrack = null
                        }
                        _registerListeners() {
                            const {
                                hls: e
                            } = this;
                            e.on(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.LEVEL_LOADED, this.onLevelLoaded, this), e.on(me.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(me.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(me.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(me.ERROR, this.onError, this), e.on(me.BUFFER_RESET, this.onBufferReset, this), e.on(me.BUFFER_CREATED, this.onBufferCreated, this), e.on(me.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(me.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(me.FRAG_BUFFERED, this.onFragBuffered, this)
                        }
                        _unregisterListeners() {
                            const {
                                hls: e
                            } = this;
                            e.off(me.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(me.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.LEVEL_LOADED, this.onLevelLoaded, this), e.off(me.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(me.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(me.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(me.ERROR, this.onError, this), e.off(me.BUFFER_RESET, this.onBufferReset, this), e.off(me.BUFFER_CREATED, this.onBufferCreated, this), e.off(me.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(me.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(me.FRAG_BUFFERED, this.onFragBuffered, this)
                        }
                        onInitPtsFound(e, {
                            frag: t,
                            id: i,
                            initPTS: r,
                            timescale: n
                        }) {
                            if ("main" === i) {
                                const e = t.cc;
                                this.initPTS[t.cc] = {
                                    baseTime: r,
                                    timescale: n
                                }, this.log(`InitPTS for cc: ${e} found from main: ${r}`), this.videoTrackCC = e, this.state === jr && this.tick()
                            }
                        }
                        startLoad(e) {
                            if (!this.levels) return this.startPosition = e, void(this.state = Pr);
                            const t = this.lastCurrentTime;
                            this.stopLoad(), this.setInterval(100), t > 0 && -1 === e ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t, this.state = xr) : (this.loadedmetadata = !1, this.state = Fr), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick()
                        }
                        doTick() {
                            switch (this.state) {
                                case xr:
                                    this.doTickIdle();
                                    break;
                                case Fr:
                                    {
                                        var e;
                                        const {
                                            levels: t,
                                            trackId: i
                                        } = this,
                                        r = null == t || null == (e = t[i]) ? void 0 : e.details;
                                        if (r) {
                                            if (this.waitForCdnTuneIn(r)) break;
                                            this.state = jr
                                        }
                                        break
                                    }
                                case Nr:
                                    {
                                        var t;
                                        const e = performance.now(),
                                            i = this.retryDate;
                                        (!i || e >= i || null != (t = this.media) && t.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = xr);
                                        break
                                    }
                                case jr:
                                    {
                                        const e = this.waitingData;
                                        if (e) {
                                            const {
                                                frag: t,
                                                part: i,
                                                cache: r,
                                                complete: n
                                            } = e;
                                            if (void 0 !== this.initPTS[t.cc]) {
                                                this.waitingData = null, this.waitingVideoCC = -1, this.state = Mr;
                                                const e = {
                                                    frag: t,
                                                    part: i,
                                                    payload: r.flush(),
                                                    networkDetails: null
                                                };
                                                this._handleFragmentLoadProgress(e), n && super._handleFragmentLoadComplete(e)
                                            } else if (this.videoTrackCC !== this.waitingVideoCC) this.log(`Waiting fragment cc (${t.cc}) cancelled because video is at cc ${this.videoTrackCC}`), this.clearWaitingFragment();
                                            else {
                                                const e = this.getLoadPosition(),
                                                    i = Tr.bufferInfo(this.mediaBuffer, e, this.config.maxBufferHole);
                                                qi(i.end, this.config.maxFragLookUpTolerance, t) < 0 && (this.log(`Waiting fragment cc (${t.cc}) @ ${t.start} cancelled because another fragment at ${i.end} is needed`), this.clearWaitingFragment())
                                            }
                                        } else this.state = xr
                                    }
                            }
                            this.onTickEnd()
                        }
                        clearWaitingFragment() {
                            const e = this.waitingData;
                            e && (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = xr)
                        }
                        resetLoadingState() {
                            this.clearWaitingFragment(), super.resetLoadingState()
                        }
                        onTickEnd() {
                            const {
                                media: e
                            } = this;
                            null != e && e.readyState && (this.lastCurrentTime = e.currentTime)
                        }
                        doTickIdle() {
                            const {
                                hls: e,
                                levels: t,
                                media: i,
                                trackId: r
                            } = this, n = e.config;
                            if (null == t || !t[r]) return;
                            if (!i && (this.startFragRequested || !n.startFragPrefetch)) return;
                            const s = t[r],
                                a = s.details;
                            if (!a || a.live && this.levelLastLoaded !== r || this.waitForCdnTuneIn(a)) return void(this.state = Fr);
                            const o = this.mediaBuffer ? this.mediaBuffer : this.media;
                            this.bufferFlushed && o && (this.bufferFlushed = !1, this.afterBufferFlushed(o, Re, oi));
                            const l = this.getFwdBufferInfo(o, oi);
                            if (null === l) return;
                            const {
                                bufferedTrack: c,
                                switchingTrack: d
                            } = this;
                            if (!d && this._streamEnded(l, a)) return e.trigger(me.BUFFER_EOS, {
                                type: "audio"
                            }), void(this.state = $r);
                            const u = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, ai),
                                h = l.len,
                                f = this.getMaxBufferLength(null == u ? void 0 : u.len);
                            if (h >= f && !d) return;
                            const m = a.fragments[0].start;
                            let p = l.end;
                            if (d && i) {
                                const e = this.getLoadPosition();
                                c && d.attrs !== c.attrs && (p = e), a.PTSKnown && e < m && (l.end > m || l.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), i.currentTime = m + .05)
                            }
                            let g = this.getNextFragment(p, a),
                                y = !1;
                            if (g && this.isLoopLoading(g, p) && (y = !!g.gap, g = this.getNextFragmentLoopLoading(g, a, l, ai, f)), !g) return void(this.bufferFlushed = !0);
                            const v = u && g.start > u.end + a.targetduration;
                            if (v || (null == u || !u.len) && l.len) {
                                const e = this.getAppendedFrag(g.start, ai);
                                if (null === e) return;
                                if (y || (y = !!e.gap || !!v && 0 === u.len), v && !y || y && l.nextStart && l.nextStart < e.end) return
                            }
                            this.loadFragment(g, s, p)
                        }
                        getMaxBufferLength(e) {
                            const t = super.getMaxBufferLength();
                            return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t
                        }
                        onMediaDetaching() {
                            this.videoBuffer = null, super.onMediaDetaching()
                        }
                        onAudioTracksUpdated(e, {
                            audioTracks: t
                        }) {
                            this.resetTransmuxer(), this.levels = t.map((e => new Ci(e)))
                        }
                        onAudioTrackSwitching(e, t) {
                            const i = !!t.url;
                            this.trackId = t.id;
                            const {
                                fragCurrent: r
                            } = this;
                            r && (r.abortRequests(), this.removeUnbufferedFrags(r.start)), this.resetLoadingState(), i ? this.setInterval(100) : this.resetTransmuxer(), i ? (this.switchingTrack = t, this.state = xr) : (this.switchingTrack = null, this.bufferedTrack = t, this.state = Pr), this.tick()
                        }
                        onManifestLoading() {
                            this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1, this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null, this.startFragRequested = !1, this.trackId = this.videoTrackCC = this.waitingVideoCC = -1
                        }
                        onLevelLoaded(e, t) {
                            this.mainDetails = t.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(me.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null)
                        }
                        onAudioTrackLoaded(e, t) {
                            var i;
                            if (null == this.mainDetails) return void(this.cachedTrackLoadedData = t);
                            const {
                                levels: r
                            } = this, {
                                details: n,
                                id: s
                            } = t;
                            if (!r) return void this.warn(`Audio tracks were reset while loading level ${s}`);
                            this.log(`Track ${s} loaded [${n.startSN},${n.endSN}]${n.lastPartSn?`[part-${n.lastPartSn}-${n.lastPartIndex}]`:""},duration:${n.totalduration}`);
                            const a = r[s];
                            let o = 0;
                            if (n.live || null != (i = a.details) && i.live) {
                                this.checkLiveUpdate(n);
                                const e = this.mainDetails;
                                if (n.deltaUpdateFailed || !e) return;
                                !a.details && n.hasProgramDateTime && e.hasProgramDateTime ? (Sr(n, e), o = n.fragments[0].start) : o = this.alignPlaylists(n, a.details)
                            }
                            a.details = n, this.levelLastLoaded = s, this.startFragRequested || !this.mainDetails && n.live || this.setStartPosition(a.details, o), this.state !== Fr || this.waitForCdnTuneIn(n) || (this.state = xr), this.tick()
                        }
                        _handleFragmentLoadProgress(e) {
                            var t;
                            const {
                                frag: i,
                                part: r,
                                payload: n
                            } = e, {
                                config: s,
                                trackId: a,
                                levels: o
                            } = this;
                            if (!o) return void this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${i.sn} of level ${i.level} will not be buffered`);
                            const l = o[a];
                            if (!l) return void this.warn("Audio track is undefined on fragment load progress");
                            const c = l.details;
                            if (!c) return this.warn("Audio track details undefined on fragment load progress"), void this.removeUnbufferedFrags(i.start);
                            const d = s.defaultAudioCodec || l.audioCodec || "mp4a.40.2";
                            let u = this.transmuxer;
                            u || (u = this.transmuxer = new Xn(this.hls, oi, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
                            const h = this.initPTS[i.cc],
                                f = null == (t = i.initSegment) ? void 0 : t.data;
                            if (void 0 !== h) {
                                const e = !1,
                                    t = r ? r.index : -1,
                                    s = -1 !== t,
                                    a = new Er(i.level, i.sn, i.stats.chunkCount, n.byteLength, t, s);
                                u.push(n, f, d, "", i, r, c.totalduration, e, a, h)
                            } else {
                                this.log(`Unknown video PTS for cc ${i.cc}, waiting for video PTS before demuxing audio frag ${i.sn} of [${c.startSN} ,${c.endSN}],track ${a}`);
                                const {
                                    cache: e
                                } = this.waitingData = this.waitingData || {
                                    frag: i,
                                    part: r,
                                    cache: new ts,
                                    complete: !1
                                };
                                e.push(new Uint8Array(n)), this.waitingVideoCC = this.videoTrackCC, this.state = jr
                            }
                        }
                        _handleFragmentLoadComplete(e) {
                            this.waitingData ? this.waitingData.complete = !0 : super._handleFragmentLoadComplete(e)
                        }
                        onBufferReset() {
                            this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
                        }
                        onBufferCreated(e, t) {
                            const i = t.tracks.audio;
                            i && (this.mediaBuffer = i.buffer || null), t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null)
                        }
                        onFragBuffered(e, t) {
                            const {
                                frag: i,
                                part: r
                            } = t;
                            if (i.type === oi)
                                if (this.fragContextChanged(i)) this.warn(`Fragment ${i.sn}${r?" p: "+r.index:""} of level ${i.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack?this.switchingTrack.name:"false"}`);
                                else {
                                    if ("initSegment" !== i.sn) {
                                        this.fragPrevious = i;
                                        const e = this.switchingTrack;
                                        e && (this.bufferedTrack = e, this.switchingTrack = null, this.hls.trigger(me.AUDIO_TRACK_SWITCHED, le({}, e)))
                                    }
                                    this.fragBufferedComplete(i, r)
                                }
                            else if (!this.loadedmetadata && i.type === ai) {
                                const e = this.videoBuffer || this.media;
                                if (e) {
                                    Tr.getBuffered(e).length && (this.loadedmetadata = !0)
                                }
                            }
                        }
                        onError(e, t) {
                            var i;
                            if (t.fatal) this.state = Hr;
                            else switch (t.details) {
                                case ge.FRAG_GAP:
                                case ge.FRAG_PARSING_ERROR:
                                case ge.FRAG_DECRYPT_ERROR:
                                case ge.FRAG_LOAD_ERROR:
                                case ge.FRAG_LOAD_TIMEOUT:
                                case ge.KEY_LOAD_ERROR:
                                case ge.KEY_LOAD_TIMEOUT:
                                    this.onFragmentOrKeyLoadError(oi, t);
                                    break;
                                case ge.AUDIO_TRACK_LOAD_ERROR:
                                case ge.AUDIO_TRACK_LOAD_TIMEOUT:
                                case ge.LEVEL_PARSING_ERROR:
                                    t.levelRetry || this.state !== Fr || (null == (i = t.context) ? void 0 : i.type) !== ni || (this.state = xr);
                                    break;
                                case ge.BUFFER_FULL_ERROR:
                                    if (!t.parent || "audio" !== t.parent) return;
                                    this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
                                    break;
                                case ge.INTERNAL_EXCEPTION:
                                    this.recoverWorkerError(t)
                            }
                        }
                        onBufferFlushed(e, {
                            type: t
                        }) {
                            t === Re && (this.bufferFlushed = !0, this.state === $r && (this.state = xr))
                        }
                        _handleTransmuxComplete(e) {
                            var t;
                            const i = "audio",
                                {
                                    hls: r
                                } = this,
                                {
                                    remuxResult: n,
                                    chunkMeta: s
                                } = e,
                                a = this.getCurrentContext(s);
                            if (!a) return void this.resetWhenMissingContext(s);
                            const {
                                frag: o,
                                part: l,
                                level: c
                            } = a, {
                                details: d
                            } = c, {
                                audio: u,
                                text: h,
                                id3: f,
                                initSegment: m
                            } = n;
                            if (!this.fragContextChanged(o) && d) {
                                if (this.state = Br, this.switchingTrack && u && this.completeAudioSwitch(this.switchingTrack), null != m && m.tracks) {
                                    const e = o.initSegment || o;
                                    this._bufferInitSegment(m.tracks, e, s), r.trigger(me.FRAG_PARSING_INIT_SEGMENT, {
                                        frag: e,
                                        id: i,
                                        tracks: m.tracks
                                    })
                                }
                                if (u) {
                                    const {
                                        startPTS: e,
                                        endPTS: t,
                                        startDTS: i,
                                        endDTS: r
                                    } = u;
                                    l && (l.elementaryStreams[Re] = {
                                        startPTS: e,
                                        endPTS: t,
                                        startDTS: i,
                                        endDTS: r
                                    }), o.setElementaryStreamInfo(Re, e, t, i, r), this.bufferFragmentData(u, o, l, s)
                                }
                                if (null != f && null != (t = f.samples) && t.length) {
                                    const e = de({
                                        id: i,
                                        frag: o,
                                        details: d
                                    }, f);
                                    r.trigger(me.FRAG_PARSING_METADATA, e)
                                }
                                if (h) {
                                    const e = de({
                                        id: i,
                                        frag: o,
                                        details: d
                                    }, h);
                                    r.trigger(me.FRAG_PARSING_USERDATA, e)
                                }
                            } else this.fragmentTracker.removeFragment(o)
                        }
                        _bufferInitSegment(e, t, i) {
                            if (this.state !== Br) return;
                            e.video && delete e.video;
                            const r = e.audio;
                            if (!r) return;
                            r.levelCodec = r.codec, r.id = "audio", this.log(`Init audio buffer, container:${r.container}, codecs[parsed]=[${r.codec}]`), this.hls.trigger(me.BUFFER_CODECS, e);
                            const n = r.initSegment;
                            if (null != n && n.byteLength) {
                                const e = {
                                    type: "audio",
                                    frag: t,
                                    part: null,
                                    chunkMeta: i,
                                    parent: t.type,
                                    data: n
                                };
                                this.hls.trigger(me.BUFFER_APPENDING, e)
                            }
                            this.tick()
                        }
                        loadFragment(e, t, i) {
                            const r = this.fragmentTracker.getState(e);
                            var n;
                            (this.fragCurrent = e, this.switchingTrack || r === sr || r === or) ? "initSegment" === e.sn ? this._loadInitSegment(e, t) : null != (n = t.details) && n.live && !this.initPTS[e.cc] ? (this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = jr) : (this.startFragRequested = !0, super.loadFragment(e, t, i)): this.clearTrackerIfNeeded(e)
                        }
                        completeAudioSwitch(e) {
                            const {
                                hls: t,
                                media: i,
                                bufferedTrack: r
                            } = this, n = null == r ? void 0 : r.attrs, s = e.attrs;
                            i && n && (n.CHANNELS !== s.CHANNELS || n.NAME !== s.NAME || n.LANGUAGE !== s.LANGUAGE) && (this.log("Switching audio track : flushing all audio"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio")), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(me.AUDIO_TRACK_SWITCHED, le({}, e))
                        }
                    },
                    audioTrackController: class extends er {
                        constructor(e) {
                            super(e, "[audio-track-controller]"), this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners()
                        }
                        registerListeners() {
                            const {
                                hls: e
                            } = this;
                            e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.MANIFEST_PARSED, this.onManifestParsed, this), e.on(me.LEVEL_LOADING, this.onLevelLoading, this), e.on(me.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(me.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(me.ERROR, this.onError, this)
                        }
                        unregisterListeners() {
                            const {
                                hls: e
                            } = this;
                            e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.MANIFEST_PARSED, this.onManifestParsed, this), e.off(me.LEVEL_LOADING, this.onLevelLoading, this), e.off(me.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(me.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(me.ERROR, this.onError, this)
                        }
                        destroy() {
                            this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy()
                        }
                        onManifestLoading() {
                            this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0
                        }
                        onManifestParsed(e, t) {
                            this.tracks = t.audioTracks || []
                        }
                        onAudioTrackLoaded(e, t) {
                            const {
                                id: i,
                                groupId: r,
                                details: n
                            } = t, s = this.tracksInGroup[i];
                            if (!s || s.groupId !== r) return void this.warn(`Track with id:${i} and group:${r} not found in active group ${s.groupId}`);
                            const a = s.details;
                            s.details = t.details, this.log(`audio-track ${i} "${s.name}" lang:${s.lang} group:${r} loaded [${n.startSN}-${n.endSN}]`), i === this.trackId && this.playlistLoaded(i, t, a)
                        }
                        onLevelLoading(e, t) {
                            this.switchLevel(t.level)
                        }
                        onLevelSwitching(e, t) {
                            this.switchLevel(t.level)
                        }
                        switchLevel(e) {
                            const t = this.hls.levels[e];
                            if (null == t || !t.audioGroupIds) return;
                            const i = t.audioGroupIds[t.urlId];
                            if (this.groupId !== i) {
                                this.groupId = i || null;
                                const e = this.tracks.filter((e => !i || e.groupId === i));
                                this.selectDefaultTrack && !e.some((e => e.default)) && (this.selectDefaultTrack = !1), this.tracksInGroup = e;
                                const t = {
                                    audioTracks: e
                                };
                                this.log(`Updating audio tracks, ${e.length} track(s) found in group:${i}`), this.hls.trigger(me.AUDIO_TRACKS_UPDATED, t), this.selectInitialTrack()
                            } else this.shouldReloadPlaylist(this.currentTrack) && this.setAudioTrack(this.trackId)
                        }
                        onError(e, t) {
                            !t.fatal && t.context && t.context.type === ni && t.context.id === this.trackId && t.context.groupId === this.groupId && (this.requestScheduled = -1, this.checkRetry(t))
                        }
                        get audioTracks() {
                            return this.tracksInGroup
                        }
                        get audioTrack() {
                            return this.trackId
                        }
                        set audioTrack(e) {
                            this.selectDefaultTrack = !1, this.setAudioTrack(e)
                        }
                        setAudioTrack(e) {
                            const t = this.tracksInGroup;
                            if (e < 0 || e >= t.length) return void this.warn("Invalid id passed to audio-track controller");
                            this.clearTimer();
                            const i = this.currentTrack;
                            t[this.trackId];
                            const r = t[e],
                                {
                                    groupId: n,
                                    name: s
                                } = r;
                            if (this.log(`Switching to audio-track ${e} "${s}" lang:${r.lang} group:${n}`), this.trackId = e, this.currentTrack = r, this.selectDefaultTrack = !1, this.hls.trigger(me.AUDIO_TRACK_SWITCHING, le({}, r)), r.details && !r.details.live) return;
                            const a = this.switchParams(r.url, null == i ? void 0 : i.details);
                            this.loadPlaylist(a)
                        }
                        selectInitialTrack() {
                            const e = this.tracksInGroup,
                                t = this.findTrackId(this.currentTrack) | this.findTrackId(null);
                            if (-1 !== t) this.setAudioTrack(t);
                            else {
                                const t = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${e.length}`);
                                this.warn(t.message), this.hls.trigger(me.ERROR, {
                                    type: pe.MEDIA_ERROR,
                                    details: ge.AUDIO_TRACK_LOAD_ERROR,
                                    fatal: !0,
                                    error: t
                                })
                            }
                        }
                        findTrackId(e) {
                            const t = this.tracksInGroup;
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                if (!this.selectDefaultTrack || r.default) {
                                    if (!e || void 0 !== e.attrs["STABLE-RENDITION-ID"] && e.attrs["STABLE-RENDITION-ID"] === r.attrs["STABLE-RENDITION-ID"]) return r.id;
                                    if (e.name === r.name && e.lang === r.lang) return r.id
                                }
                            }
                            return -1
                        }
                        loadPlaylist(e) {
                            super.loadPlaylist();
                            const t = this.tracksInGroup[this.trackId];
                            if (this.shouldLoadPlaylist(t)) {
                                const i = t.id,
                                    r = t.groupId;
                                let n = t.url;
                                if (e) try {
                                    n = e.addDirectives(n)
                                } catch (e) {
                                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${e}`)
                                }
                                this.log(`loading audio-track playlist ${i} "${t.name}" lang:${t.lang} group:${r}`), this.clearTimer(), this.hls.trigger(me.AUDIO_TRACK_LOADING, {
                                    url: n,
                                    id: i,
                                    groupId: r,
                                    deliveryDirectives: e || null
                                })
                            }
                        }
                    },
                    emeController: na,
                    cmcdController: ha,
                    contentSteeringController: class {
                        constructor(e) {
                            this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = ".", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = Ee.log.bind(Ee, "[content-steering]:"), this.registerListeners()
                        }
                        registerListeners() {
                            const e = this.hls;
                            e.on(me.MANIFEST_LOADING, this.onManifestLoading, this), e.on(me.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(me.MANIFEST_PARSED, this.onManifestParsed, this), e.on(me.ERROR, this.onError, this)
                        }
                        unregisterListeners() {
                            const e = this.hls;
                            e && (e.off(me.MANIFEST_LOADING, this.onManifestLoading, this), e.off(me.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(me.MANIFEST_PARSED, this.onManifestParsed, this), e.off(me.ERROR, this.onError, this))
                        }
                        startLoad() {
                            if (this.started = !0, self.clearTimeout(this.reloadTimer), this.enabled && this.uri)
                                if (this.updated) {
                                    const e = Math.max(1e3 * this.timeToLoad - (performance.now() - this.updated), 0);
                                    this.scheduleRefresh(this.uri, e)
                                } else this.loadSteeringManifest(this.uri)
                        }
                        stopLoad() {
                            this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), self.clearTimeout(this.reloadTimer)
                        }
                        destroy() {
                            this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null
                        }
                        removeLevel(e) {
                            const t = this.levels;
                            t && (this.levels = t.filter((t => t !== e)))
                        }
                        onManifestLoading() {
                            this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = ".", this.levels = this.audioTracks = this.subtitleTracks = null
                        }
                        onManifestLoaded(e, t) {
                            const {
                                contentSteering: i
                            } = t;
                            null !== i && (this.pathwayId = i.pathwayId, this.uri = i.uri, this.started && this.startLoad())
                        }
                        onManifestParsed(e, t) {
                            this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks
                        }
                        onError(e, t) {
                            const {
                                errorAction: i
                            } = t;
                            if ((null == i ? void 0 : i.action) === Yi && i.flags === Qi) {
                                let e = this.pathwayPriority;
                                const t = this.pathwayId;
                                this.penalizedPathways[t] || (this.penalizedPathways[t] = performance.now()), !e && this.levels && (e = this.levels.reduce(((e, t) => (-1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId), e)), [])), e && e.length > 1 && (this.updatePathwayPriority(e), i.resolved = this.pathwayId !== t)
                            }
                        }
                        filterParsedLevels(e) {
                            this.levels = e;
                            let t = this.getLevelsForPathway(this.pathwayId);
                            if (0 === t.length) {
                                const i = e[0].pathwayId;
                                this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${i}"`), t = this.getLevelsForPathway(i), this.pathwayId = i
                            }
                            return t.length !== e.length ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t) : e
                        }
                        getLevelsForPathway(e) {
                            return null === this.levels ? [] : this.levels.filter((t => e === t.pathwayId))
                        }
                        updatePathwayPriority(e) {
                            let t;
                            this.pathwayPriority = e;
                            const i = this.penalizedPathways,
                                r = performance.now();
                            Object.keys(i).forEach((e => {
                                r - i[e] > 3e5 && delete i[e]
                            }));
                            for (let r = 0; r < e.length; r++) {
                                const n = e[r];
                                if (i[n]) continue;
                                if (n === this.pathwayId) return;
                                const s = this.hls.nextLoadLevel,
                                    a = this.hls.levels[s];
                                if (t = this.getLevelsForPathway(n), t.length > 0) {
                                    this.log(`Setting Pathway to "${n}"`), this.pathwayId = n, this.hls.trigger(me.LEVELS_UPDATED, {
                                        levels: t
                                    });
                                    const e = this.hls.levels[s];
                                    a && e && this.levels && (e.attrs["STABLE-VARIANT-ID"] !== a.attrs["STABLE-VARIANT-ID"] && e.bitrate !== a.bitrate && this.log(`Unstable Pathways change from bitrate ${a.bitrate} to ${e.bitrate}`), this.hls.nextLoadLevel = s);
                                    break
                                }
                            }
                        }
                        clonePathways(e) {
                            const t = this.levels;
                            if (!t) return;
                            const i = {},
                                r = {};
                            e.forEach((e => {
                                const {
                                    ID: n,
                                    "BASE-ID": s,
                                    "URI-REPLACEMENT": a
                                } = e;
                                if (t.some((e => e.pathwayId === n))) return;
                                const o = this.getLevelsForPathway(s).map((e => {
                                    const t = de({}, e);
                                    t.details = void 0, t.url = ma(e.uri, e.attrs["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", a);
                                    const s = new _e(e.attrs);
                                    s["PATHWAY-ID"] = n;
                                    const o = s.AUDIO && `${s.AUDIO}_clone_${n}`,
                                        l = s.SUBTITLES && `${s.SUBTITLES}_clone_${n}`;
                                    o && (i[s.AUDIO] = o, s.AUDIO = o), l && (r[s.SUBTITLES] = l, s.SUBTITLES = l), t.attrs = s;
                                    const c = new Ci(t);
                                    return rr(c, "audio", o), rr(c, "text", l), c
                                }));
                                t.push(...o), fa(this.audioTracks, i, a, n), fa(this.subtitleTracks, r, a, n)
                            }))
                        }
                        loadSteeringManifest(e) {
                            const t = this.hls.config,
                                i = t.loader;
                            let r;
                            this.loader && this.loader.destroy(), this.loader = new i(t);
                            try {
                                r = new self.URL(e)
                            } catch (t) {
                                return this.enabled = !1, void this.log(`Failed to parse Steering Manifest URI: ${e}`)
                            }
                            if ("data:" !== r.protocol) {
                                const e = 0 | (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate);
                                r.searchParams.set("_HLS_pathway", this.pathwayId), r.searchParams.set("_HLS_throughput", "" + e)
                            }
                            const n = {
                                    responseType: "json",
                                    url: r.href
                                },
                                s = t.steeringManifestLoadPolicy.default,
                                a = s.errorRetry || s.timeoutRetry || {},
                                o = {
                                    loadPolicy: s,
                                    timeout: s.maxLoadTimeMs,
                                    maxRetry: a.maxNumRetry || 0,
                                    retryDelay: a.retryDelayMs || 0,
                                    maxRetryDelay: a.maxRetryDelayMs || 0
                                },
                                l = {
                                    onSuccess: (e, t, i, n) => {
                                        this.log(`Loaded steering manifest: "${r}"`);
                                        const s = e.data;
                                        if (1 !== s.VERSION) return void this.log(`Steering VERSION ${s.VERSION} not supported!`);
                                        this.updated = performance.now(), this.timeToLoad = s.TTL;
                                        const {
                                            "RELOAD-URI": a,
                                            "PATHWAY-CLONES": o,
                                            "PATHWAY-PRIORITY": l
                                        } = s;
                                        if (a) try {
                                            this.uri = new self.URL(a, r).href
                                        } catch (e) {
                                            return this.enabled = !1, void this.log(`Failed to parse Steering Manifest RELOAD-URI: ${a}`)
                                        }
                                        this.scheduleRefresh(this.uri || i.url), o && this.clonePathways(o), l && this.updatePathwayPriority(l)
                                    },
                                    onError: (e, t, i, r) => {
                                        if (this.log(`Error loading steering manifest: ${e.code} ${e.text} (${t.url})`), this.stopLoad(), 410 === e.code) return this.enabled = !1, void this.log(`Steering manifest ${t.url} no longer available`);
                                        let n = 1e3 * this.timeToLoad;
                                        if (429 !== e.code) this.scheduleRefresh(this.uri || t.url, n);
                                        else {
                                            const e = this.loader;
                                            if ("function" == typeof(null == e ? void 0 : e.getResponseHeader)) {
                                                const t = e.getResponseHeader("Retry-After");
                                                t && (n = 1e3 * parseFloat(t))
                                            }
                                            this.log(`Steering manifest ${t.url} rate limited`)
                                        }
                                    },
                                    onTimeout: (e, t, i) => {
                                        this.log(`Timeout loading steering manifest (${t.url})`), this.scheduleRefresh(this.uri || t.url)
                                    }
                                };
                            this.log(`Requesting steering manifest: ${r}`), this.loader.load(n, o, l)
                        }
                        scheduleRefresh(e, t = 1e3 * this.timeToLoad) {
                            self.clearTimeout(this.reloadTimer), this.reloadTimer = self.setTimeout((() => {
                                this.loadSteeringManifest(e)
                            }), t)
                        }
                    }
                });

            function _a(e) {
                return e && "object" == typeof e ? Array.isArray(e) ? e.map(_a) : Object.keys(e).reduce(((t, i) => (t[i] = _a(e[i]), t)), {}) : e
            }

            function ka(e) {
                const t = e.loader;
                if (t !== va && t !== ga) Ee.log("[config]: Custom loader detected, cannot enable progressive streaming"), e.progressive = !1;
                else {
                    (function() {
                        if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
                            return new self.ReadableStream({}), !0
                        } catch (e) {}
                        return !1
                    })() && (e.loader = va, e.progressive = !0, e.enableSoftwareAES = !0, Ee.log("[config]: Progressive streaming enabled, using FetchLoader"))
                }
            }
            class Sa {
                static get version() {
                    return "1.4.13"
                }
                static isSupported() {
                    return function() {
                        const e = Ut();
                        if (!e) return !1;
                        const t = qr(),
                            i = e && "function" == typeof e.isTypeSupported && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
                            r = !t || t.prototype && "function" == typeof t.prototype.appendBuffer && "function" == typeof t.prototype.remove;
                        return !!i && !!r
                    }()
                }
                static get Events() {
                    return me
                }
                static get ErrorTypes() {
                    return pe
                }
                static get ErrorDetails() {
                    return ge
                }
                static get DefaultConfig() {
                    return Sa.defaultConfig ? Sa.defaultConfig : wa
                }
                static set DefaultConfig(e) {
                    Sa.defaultConfig = e
                }
                constructor(e = {}) {
                    this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Yn, this._autoLevelCapping = void 0, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null,
                        function(e, t) {
                            if (self.console && !0 === e || "object" == typeof e) {
                                Te(e, "debug", "log", "info", "warn", "error");
                                try {
                                    be.log(`Debug logs enabled for "${t}" in hls.js version 1.4.13`)
                                } catch (e) {
                                    be = ve
                                }
                            } else be = ve
                        }(e.debug || !1, "Hls instance");
                    const t = this.config = function(e, t) {
                        if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                        if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                        if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                        const i = _a(e),
                            r = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
                        return ["manifest", "level", "frag"].forEach((e => {
                            const n = `${"level"===e?"playlist":e}LoadPolicy`,
                                s = void 0 === t[n],
                                a = [];
                            r.forEach((r => {
                                const o = `${e}Loading${r}`,
                                    l = t[o];
                                if (void 0 !== l && s) {
                                    a.push(o);
                                    const e = i[n].default;
                                    switch (t[n] = {
                                        default: e
                                    }, r) {
                                        case "TimeOut":
                                            e.maxLoadTimeMs = l, e.maxTimeToFirstByteMs = l;
                                            break;
                                        case "MaxRetry":
                                            e.errorRetry.maxNumRetry = l, e.timeoutRetry.maxNumRetry = l;
                                            break;
                                        case "RetryDelay":
                                            e.errorRetry.retryDelayMs = l, e.timeoutRetry.retryDelayMs = l;
                                            break;
                                        case "MaxRetryTimeout":
                                            e.errorRetry.maxRetryDelayMs = l, e.timeoutRetry.maxRetryDelayMs = l
                                    }
                                }
                            })), a.length && Ee.warn(`hls.js config: "${a.join('", "')}" setting(s) are deprecated, use "${n}": ${JSON.stringify(t[n])}`)
                        })), le(le({}, i), t)
                    }(Sa.DefaultConfig, e);
                    this.userConfig = e, this._autoLevelCapping = -1, t.progressive && ka(t);
                    const {
                        abrController: i,
                        bufferController: r,
                        capLevelController: n,
                        errorController: s,
                        fpsController: a
                    } = t, o = new s(this), l = this.abrController = new i(this), c = this.bufferController = new r(this), d = this.capLevelController = new n(this), u = new a(this), h = new ui(this), f = new wi(this), m = t.contentSteeringController, p = m ? new m(this) : null, g = this.levelController = new ir(this, p), y = new cr(this), v = new yr(this.config), b = this.streamController = new Jn(this, y, v);
                    d.setStreamController(b), u.setStreamController(b);
                    const T = [h, g, b];
                    p && T.splice(1, 0, p), this.networkControllers = T;
                    const E = [l, c, d, u, f, y];
                    this.audioTrackController = this.createController(t.audioTrackController, T);
                    const A = t.audioStreamController;
                    A && T.push(new A(this, y, v)), this.subtitleTrackController = this.createController(t.subtitleTrackController, T);
                    const w = t.subtitleStreamController;
                    w && T.push(new w(this, y, v)), this.createController(t.timelineController, E), v.emeController = this.emeController = this.createController(t.emeController, E), this.cmcdController = this.createController(t.cmcdController, E), this.latencyController = this.createController(_i, E), this.coreComponents = E, T.push(o);
                    const _ = o.onErrorOut;
                    "function" == typeof _ && this.on(me.ERROR, _, o)
                }
                createController(e, t) {
                    if (e) {
                        const i = new e(this);
                        return t && t.push(i), i
                    }
                    return null
                }
                on(e, t, i = this) {
                    this._emitter.on(e, t, i)
                }
                once(e, t, i = this) {
                    this._emitter.once(e, t, i)
                }
                removeAllListeners(e) {
                    this._emitter.removeAllListeners(e)
                }
                off(e, t, i = this, r) {
                    this._emitter.off(e, t, i, r)
                }
                listeners(e) {
                    return this._emitter.listeners(e)
                }
                emit(e, t, i) {
                    return this._emitter.emit(e, t, i)
                }
                trigger(e, t) {
                    if (this.config.debug) return this.emit(e, e, t);
                    try {
                        return this.emit(e, e, t)
                    } catch (t) {
                        Ee.error("An internal error happened while handling event " + e + '. Error message: "' + t.message + '". Here is a stacktrace:', t), this.trigger(me.ERROR, {
                            type: pe.OTHER_ERROR,
                            details: ge.INTERNAL_EXCEPTION,
                            fatal: !1,
                            event: e,
                            error: t
                        })
                    }
                    return !1
                }
                listenerCount(e) {
                    return this._emitter.listenerCount(e)
                }
                destroy() {
                    Ee.log("destroy"), this.trigger(me.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach((e => e.destroy())), this.networkControllers.length = 0, this.coreComponents.forEach((e => e.destroy())), this.coreComponents.length = 0;
                    const e = this.config;
                    e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null
                }
                attachMedia(e) {
                    Ee.log("attachMedia"), this._media = e, this.trigger(me.MEDIA_ATTACHING, {
                        media: e
                    })
                }
                detachMedia() {
                    Ee.log("detachMedia"), this.trigger(me.MEDIA_DETACHING, void 0), this._media = null
                }
                loadSource(e) {
                    this.stopLoad();
                    const t = this.media,
                        i = this.url,
                        r = this.url = ae.buildAbsoluteURL(self.location.href, e, {
                            alwaysNormalize: !0
                        });
                    Ee.log(`loadSource:${r}`), t && i && (i !== r || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(me.MANIFEST_LOADING, {
                        url: e
                    })
                }
                startLoad(e = -1) {
                    Ee.log(`startLoad(${e})`), this.networkControllers.forEach((t => {
                        t.startLoad(e)
                    }))
                }
                stopLoad() {
                    Ee.log("stopLoad"), this.networkControllers.forEach((e => {
                        e.stopLoad()
                    }))
                }
                swapAudioCodec() {
                    Ee.log("swapAudioCodec"), this.streamController.swapAudioCodec()
                }
                recoverMediaError() {
                    Ee.log("recoverMediaError");
                    const e = this._media;
                    this.detachMedia(), e && this.attachMedia(e)
                }
                removeLevel(e, t = 0) {
                    this.levelController.removeLevel(e, t)
                }
                get levels() {
                    const e = this.levelController.levels;
                    return e || []
                }
                get currentLevel() {
                    return this.streamController.currentLevel
                }
                set currentLevel(e) {
                    Ee.log(`set currentLevel:${e}`), this.loadLevel = e, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch()
                }
                get nextLevel() {
                    return this.streamController.nextLevel
                }
                set nextLevel(e) {
                    Ee.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch()
                }
                get loadLevel() {
                    return this.levelController.level
                }
                set loadLevel(e) {
                    Ee.log(`set loadLevel:${e}`), this.levelController.manualLevel = e
                }
                get nextLoadLevel() {
                    return this.levelController.nextLoadLevel
                }
                set nextLoadLevel(e) {
                    this.levelController.nextLoadLevel = e
                }
                get firstLevel() {
                    return Math.max(this.levelController.firstLevel, this.minAutoLevel)
                }
                set firstLevel(e) {
                    Ee.log(`set firstLevel:${e}`), this.levelController.firstLevel = e
                }
                get startLevel() {
                    return this.levelController.startLevel
                }
                set startLevel(e) {
                    Ee.log(`set startLevel:${e}`), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e
                }
                get capLevelToPlayerSize() {
                    return this.config.capLevelToPlayerSize
                }
                set capLevelToPlayerSize(e) {
                    const t = !!e;
                    t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t)
                }
                get autoLevelCapping() {
                    return this._autoLevelCapping
                }
                get bandwidthEstimate() {
                    const {
                        bwEstimator: e
                    } = this.abrController;
                    return e ? e.getEstimate() : NaN
                }
                get ttfbEstimate() {
                    const {
                        bwEstimator: e
                    } = this.abrController;
                    return e ? e.getEstimateTTFB() : NaN
                }
                set autoLevelCapping(e) {
                    this._autoLevelCapping !== e && (Ee.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e)
                }
                get maxHdcpLevel() {
                    return this._maxHdcpLevel
                }
                set maxHdcpLevel(e) {
                    ki.indexOf(e) > -1 && (this._maxHdcpLevel = e)
                }
                get autoLevelEnabled() {
                    return -1 === this.levelController.manualLevel
                }
                get manualLevel() {
                    return this.levelController.manualLevel
                }
                get minAutoLevel() {
                    const {
                        levels: e,
                        config: {
                            minAutoBitrate: t
                        }
                    } = this;
                    if (!e) return 0;
                    const i = e.length;
                    for (let r = 0; r < i; r++)
                        if (e[r].maxBitrate >= t) return r;
                    return 0
                }
                get maxAutoLevel() {
                    const {
                        levels: e,
                        autoLevelCapping: t,
                        maxHdcpLevel: i
                    } = this;
                    let r;
                    if (r = -1 === t && e && e.length ? e.length - 1 : t, i)
                        for (let t = r; t--;) {
                            const r = e[t].attrs["HDCP-LEVEL"];
                            if (r && r <= i) return t
                        }
                    return r
                }
                get nextAutoLevel() {
                    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
                }
                set nextAutoLevel(e) {
                    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
                }
                get playingDate() {
                    return this.streamController.currentProgramDateTime
                }
                get mainForwardBufferInfo() {
                    return this.streamController.getMainFwdBufferInfo()
                }
                get audioTracks() {
                    const e = this.audioTrackController;
                    return e ? e.audioTracks : []
                }
                get audioTrack() {
                    const e = this.audioTrackController;
                    return e ? e.audioTrack : -1
                }
                set audioTrack(e) {
                    const t = this.audioTrackController;
                    t && (t.audioTrack = e)
                }
                get subtitleTracks() {
                    const e = this.subtitleTrackController;
                    return e ? e.subtitleTracks : []
                }
                get subtitleTrack() {
                    const e = this.subtitleTrackController;
                    return e ? e.subtitleTrack : -1
                }
                get media() {
                    return this._media
                }
                set subtitleTrack(e) {
                    const t = this.subtitleTrackController;
                    t && (t.subtitleTrack = e)
                }
                get subtitleDisplay() {
                    const e = this.subtitleTrackController;
                    return !!e && e.subtitleDisplay
                }
                set subtitleDisplay(e) {
                    const t = this.subtitleTrackController;
                    t && (t.subtitleDisplay = e)
                }
                get lowLatencyMode() {
                    return this.config.lowLatencyMode
                }
                set lowLatencyMode(e) {
                    this.config.lowLatencyMode = e
                }
                get liveSyncPosition() {
                    return this.latencyController.liveSyncPosition
                }
                get latency() {
                    return this.latencyController.latency
                }
                get maxLatency() {
                    return this.latencyController.maxLatency
                }
                get targetLatency() {
                    return this.latencyController.targetLatency
                }
                get drift() {
                    return this.latencyController.drift
                }
                get forceStartLoad() {
                    return this.streamController.forceStartLoad
                }
            }
            Sa.defaultConfig = void 0;
            var La = i(72345),
                Ra = i(72505),
                Da = i.n(Ra),
                Ca = (0, T.A)((function e(t, i) {
                    (0, b.A)(this, e), (0, L.A)(this, "errorContainerClassName", "video-player__error"), (0, L.A)(this, "errorMessageElementClassName", "video-player__error-message"), this.player = t, this.message = i, this.errorMessageElement = this.createErrorMessageElement()
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.errorMessageElement) || void 0 === e || e.remove()
                    }
                }, {
                    key: "createErrorMessageElement",
                    value: function() {
                        var e = this.player.elements.container,
                            t = document.createElement("div"),
                            i = document.createElement("p");
                        return t.classList.add(this.errorContainerClassName), i.classList.add(this.errorMessageElementClassName), i.innerText = this.message, t.appendChild(i), null == e || e.appendChild(t), t
                    }
                }]),
                Ia = (0, T.A)((function e(t, i) {
                    var r = this;
                    (0, b.A)(this, e), (0, L.A)(this, "handleError", (function(e) {
                        var t = S.fromError(e);
                        if (r.handleVideoPlayerError(t), t.code === y) throw e;
                        console.error(e)
                    })), (0, L.A)(this, "handleMediaError", (function(e) {
                        var t = S.fromPlayerMedia(e.media);
                        if (r.handleVideoPlayerError(t), t.code === y) throw t;
                        console.error(t)
                    })), (0, L.A)(this, "handleVideoPlayerError", (function(e) {
                        var t = r.mapCodeToMessage(e.code);
                        t && r.showErrorMessageScreen(t)
                    })), (0, L.A)(this, "showErrorMessageScreen", (function(e) {
                        r.errorMessageScreen = new Ca(r.player, e)
                    })), this.player = t, this.isExternalProvider = i, this.translation = t.config.i18n, i || this.player.on("error", (function(e) {
                        return r.handleMediaError(e.detail.plyr)
                    }))
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.errorMessageScreen) || void 0 === e || e.destroy()
                    }
                }, {
                    key: "mapCodeToMessage",
                    value: function(e) {
                        return new Map([
                            [d, this.translation.videoAbortedByUser],
                            [u, this.translation.videoCouldNotBeAccessed],
                            [h, this.translation.videoCouldNotBeDecoded],
                            [f, this.translation.videoCouldNotBePlayed],
                            [m, this.translation.videoCouldNotBePlayed],
                            [v, this.translation.unauthorizedAccess],
                            [p, this.translation.videoCouldNotBePlayed],
                            [y, this.translation.unexpectedError]
                        ]).get(e)
                    }
                }]),
                Pa = function(e) {
                    return (null == e ? void 0 : e.code) === v
                };

            function xa(e, t) {
                var i = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }
            var Oa = function() {
                function e() {
                    (0, b.A)(this, e), (0, L.A)(this, "cancelTokenSource", null)
                }
                return (0, T.A)(e, [{
                    key: "resolve",
                    value: (i = (0, B.A)($().mark((function t(i) {
                        return $().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.prev = 0, t.next = 3, this.requestPlaylist(i);
                                case 3:
                                    return t.abrupt("return", t.sent);
                                case 6:
                                    if (t.prev = 6, t.t0 = t.catch(0), !Da().isAxiosError(t.t0)) {
                                        t.next = 14;
                                        break
                                    }
                                    if (!e.isAuthError(t.t0)) {
                                        t.next = 11;
                                        break
                                    }
                                    return t.abrupt("return", this.resolveWithAuth(i));
                                case 11:
                                    throw e.buildApiError(t.t0);
                                case 14:
                                    throw t.t0;
                                case 15:
                                case "end":
                                    return t.stop()
                            }
                        }), t, this, [
                            [0, 6]
                        ])
                    }))), function(e) {
                        return i.apply(this, arguments)
                    })
                }, {
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.cancelTokenSource) || void 0 === e || e.cancel(), this.cancelTokenSource = null
                    }
                }, {
                    key: "resolveWithAuth",
                    value: (t = (0, B.A)($().mark((function t(i) {
                        var r;
                        return $().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.prev = 0, t.next = 3, this.requestAuthToken();
                                case 3:
                                    return r = t.sent, t.next = 6, this.requestPlaylist(i, r);
                                case 6:
                                    return t.abrupt("return", t.sent);
                                case 9:
                                    if (t.prev = 9, t.t0 = t.catch(0), !Da().isAxiosError(t.t0)) {
                                        t.next = 17;
                                        break
                                    }
                                    if (!e.isAuthError(t.t0)) {
                                        t.next = 14;
                                        break
                                    }
                                    throw new S(v);
                                case 14:
                                    throw e.buildApiError(t.t0);
                                case 17:
                                    throw t.t0;
                                case 18:
                                case "end":
                                    return t.stop()
                            }
                        }), t, this, [
                            [0, 9]
                        ])
                    }))), function(e) {
                        return t.apply(this, arguments)
                    })
                }, {
                    key: "requestPlaylist",
                    value: function(e, t) {
                        var i;
                        return null === (i = this.cancelTokenSource) || void 0 === i || i.cancel(), this.cancelTokenSource = Da().CancelToken.source(), La.Ay.get(e, function(e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i = null != arguments[t] ? arguments[t] : {};
                                t % 2 ? xa(Object(i), !0).forEach((function(t) {
                                    (0, L.A)(e, t, i[t])
                                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : xa(Object(i)).forEach((function(t) {
                                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                                }))
                            }
                            return e
                        }({
                            cancelToken: this.cancelTokenSource.token
                        }, t ? {
                            withCredentials: !0,
                            headers: {
                                Authorization: "Bearer ".concat(t)
                            }
                        } : {})).then((function(e) {
                            return new Blob([e.data], {
                                type: "text/plain"
                            })
                        }))
                    }
                }, {
                    key: "requestAuthToken",
                    value: function() {
                        var t;
                        return null === (t = this.cancelTokenSource) || void 0 === t || t.cancel(), this.cancelTokenSource = Da().CancelToken.source(), La.Ay.get(e.AuthEndpoint, {
                            cancelToken: this.cancelTokenSource.token
                        }).then((function(e) {
                            return e.data.token
                        }))
                    }
                }], [{
                    key: "buildApiError",
                    value: function(e) {
                        return new La.sO.ApiError("Could not load HLS playlist", "PlaylistLoader", e)
                    }
                }, {
                    key: "isAuthError",
                    value: function(e) {
                        var t, i;
                        return 401 === (null === (t = e.response) || void 0 === t ? void 0 : t.status) || 403 === (null === (i = e.response) || void 0 === i ? void 0 : i.status)
                    }
                }]);
                var t, i
            }();
            (0, L.A)(Oa, "AuthEndpoint", "/api/media/auth/v1/asset/authorization");
            var Ma, Na, Fa, Ba = Sa.isSupported,
                Ua = (0, T.A)((function e(t) {
                    (0, b.A)(this, e), (0, L.A)(this, "playlistLoader", new Oa), (0, L.A)(this, "hasMediaErrorOccurred", !1);
                    var i = t.thumbnailSrc,
                        r = t.player,
                        n = t.errorHandler,
                        s = t.onUnauthorizedError;
                    this.player = r, this.hlsJs = new Sa({
                        enableWorker: !1
                    }), this.errorHandler = n, i && (this.player.poster = i), this.initVideo(t).catch((function(e) {
                        s && Pa(e) ? s() : n.handleError(e)
                    }))
                }), [{
                    key: "hlsJsInstance",
                    get: function() {
                        return this.hlsJs
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.hlsJs.destroy(), this.playlistLoader.destroy()
                    }
                }, {
                    key: "onReady",
                    value: function() {
                        var e = this;
                        return this.player.duration ? Promise.resolve() : new Promise((function(t) {
                            e.hlsJs.once(Sa.Events.MEDIA_ATTACHED, (function() {
                                return t()
                            }))
                        }))
                    }
                }, {
                    key: "initVideo",
                    value: (Ma = (0, B.A)($().mark((function e(t) {
                        var i, r, n, s;
                        return $().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return i = t.src, r = t.videoElement, e.next = 3, this.playlistLoader.resolve(i);
                                case 3:
                                    n = e.sent, s = URL.createObjectURL(n), this.hlsJs.loadSource(s), this.hlsJs.attachMedia(r), this.handleErrors(), this.setHighestQuality();
                                case 9:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function(e) {
                        return Ma.apply(this, arguments)
                    })
                }, {
                    key: "setHighestQuality",
                    value: function() {
                        var e = this;
                        this.hlsJs.on(Sa.Events.MANIFEST_PARSED, (function() {
                            e.hlsJs.config.startLevel = e.hlsJs.levels.reduce((function(e, t, i, r) {
                                return t.bitrate > r[e].bitrate ? i : e
                            }), 0)
                        }))
                    }
                }, {
                    key: "handleErrors",
                    value: function() {
                        var e = this;
                        this.hlsJs.on(Sa.Events.ERROR, (function(t, i) {
                            if (i.fatal) switch (i.type) {
                                case Sa.ErrorTypes.NETWORK_ERROR:
                                    e.hlsJs.startLoad();
                                    break;
                                case Sa.ErrorTypes.MEDIA_ERROR:
                                    e.handleMediaError(i);
                                    break;
                                default:
                                    e.errorHandler.handleError(i)
                            }
                        }))
                    }
                }, {
                    key: "handleMediaError",
                    value: function(e) {
                        this.hasMediaErrorOccurred ? this.errorHandler.handleError(e) : (this.hasMediaErrorOccurred = !0, this.hlsJs.recoverMediaError())
                    }
                }]),
                $a = (0, T.A)((function e(t) {
                    (0, b.A)(this, e), (0, L.A)(this, "playlistLoader", new Oa);
                    var i = t.player,
                        r = t.thumbnailSrc,
                        n = t.errorHandler,
                        s = t.onUnauthorizedError;
                    this.player = i, r && (this.player.poster = r), this.initVideo(t).catch((function(e) {
                        s && Pa(e) ? s() : n.handleError(e)
                    }))
                }), [{
                    key: "destroy",
                    value: function() {
                        this.playlistLoader.destroy()
                    }
                }, {
                    key: "onReady",
                    value: (Na = (0, B.A)($().mark((function e() {
                        var t = this;
                        return $().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    if (!this.player.duration) {
                                        e.next = 2;
                                        break
                                    }
                                    return e.abrupt("return", Promise.resolve());
                                case 2:
                                    return e.next = 4, new Promise((function(e) {
                                        var i = function() {
                                            t.player.media.removeEventListener("loadedmetadata", i), e()
                                        };
                                        t.player.media.addEventListener("loadedmetadata", i)
                                    }));
                                case 4:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    }))), function() {
                        return Na.apply(this, arguments)
                    })
                }, {
                    key: "initVideo",
                    value: function() {
                        var e = (0, B.A)($().mark((function e(t) {
                            var i, r, n, s, a;
                            return $().wrap((function(e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return i = t.src, r = t.videoElement, e.next = 3, this.playlistLoader.resolve(i);
                                    case 3:
                                        n = e.sent, s = URL.createObjectURL(n), (a = document.createElement("source")).setAttribute("src", s), a.setAttribute("type", "application/x-mpegURL"), r.appendChild(a), this.setHighestQuality();
                                    case 10:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, this)
                        })));
                        return function(t) {
                            return e.apply(this, arguments)
                        }
                    }()
                }, {
                    key: "setHighestQuality",
                    value: function() {}
                }]),
                Ha = (0, T.A)((function e(t, i) {
                    (0, b.A)(this, e), this.videoProvider = t;
                    var r = i.src,
                        n = i.thumbnailSrc;
                    this.videoProvider = t;
                    var s = this.createPlyrSourceInfo(r, n);
                    i.player.source = s
                }), [{
                    key: "destroy",
                    value: function() {}
                }, {
                    key: "onReady",
                    value: function() {
                        return Promise.resolve()
                    }
                }, {
                    key: "createPlyrSourceInfo",
                    value: function(e, t) {
                        return {
                            type: "video",
                            sources: [{
                                src: e,
                                provider: this.videoProvider
                            }],
                            poster: t
                        }
                    }
                }]),
                ja = (0, L.A)((0, L.A)({}, Q.YouTube, ["youtube.com", "youtube-nocookie.com", "youtu.be"]), Q.Vimeo, ["vimeo.com"]),
                Ga = function(e, t) {
                    var i = Object.keys(ja).find((function(t) {
                        return function(t) {
                            if (ja[t].some((function(t) {
                                    return e.includes(t)
                                }))) return t
                        }(t)
                    }));
                    return null != i ? i : function(e) {
                        var t = Boolean(e.canPlayType("application/vnd.apple.mpegURL") || e.canPlayType("audio/mpegurl"));
                        if (Ba()) return J.HlsJs;
                        if (t) return J.NativeHls;
                        throw new S(m, "No HLS implementation is supported on this platform")
                    }(t)
                },
                Va = (0, T.A)((function e(t, i) {
                    var r = this;
                    (0, b.A)(this, e), (0, L.A)(this, "vimeoButtonClassName", "video-player--vimeo-button"), (0, L.A)(this, "maxContainerWidth", 225), (0, L.A)(this, "maxContainerHeight", 127), this.videoPlayerElement = i, t.provider === J.Vimeo && t.once("ready", (function() {
                        r.resizeObserver = new ResizeObserver((function() {
                            return r.toggleVimeoPlayButtonClassName()
                        })), r.resizeObserver.observe(i)
                    }))
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.resizeObserver) || void 0 === e || e.disconnect(), this.removeVimeoPlayButtonClassName()
                    }
                }, {
                    key: "toggleVimeoPlayButtonClassName",
                    value: function() {
                        var e = this.videoPlayerElement.clientWidth,
                            t = this.videoPlayerElement.clientHeight;
                        e < this.maxContainerWidth || t < this.maxContainerHeight ? this.videoPlayerElement.classList.add(this.vimeoButtonClassName) : this.removeVimeoPlayButtonClassName()
                    }
                }, {
                    key: "removeVimeoPlayButtonClassName",
                    value: function() {
                        this.videoPlayerElement.classList.remove(this.vimeoButtonClassName)
                    }
                }]),
                qa = {
                    DA: "da",
                    DE: "de",
                    EN: "en",
                    ES: "es",
                    FI: "fi",
                    FR: "fr",
                    IT: "it",
                    JA: "ja",
                    NL: "nl",
                    NO: "no",
                    PT: "pt",
                    SV: "sv"
                },
                Ka = function(e, t, i) {
                    return e
                },
                Wa = {
                    play: Ka("Play"),
                    pause: Ka("Pause"),
                    seek: Ka("Seek"),
                    seekLabel: Ka("{currentTime} of {duration}"),
                    currentTime: Ka("Current time"),
                    duration: Ka("Duration"),
                    volume: Ka("Volume"),
                    mute: Ka("Mute"),
                    unmute: Ka("Unmute"),
                    enterFullscreen: Ka("Enter fullscreen"),
                    exitFullscreen: Ka("Exit fullscreen"),
                    settings: Ka("Settings"),
                    menuBack: Ka("Go back to previous menu"),
                    speed: Ka("Speed"),
                    normal: Ka("Normal"),
                    quality: Ka("Quality"),
                    videoAbortedByUser: Ka("You aborted the media playback."),
                    videoCouldNotBeAccessed: Ka("Couldn't load video. Check connection, then try again."),
                    videoCouldNotBeDecoded: Ka("Video unavailable. Try playing something else."),
                    videoCouldNotBePlayed: Ka("Video is not available or format is not supported. Try a different browser."),
                    unauthorizedAccess: Ka("Access denied. Login or contact owner to request access."),
                    unexpectedError: Ka("Unable to load video. Try again later."),
                    paywallCtaButton: Ka("Join Now"),
                    paywallDescription: Ka("Sign up to view this video")
                },
                Ya = (Fa = {}, (0, L.A)((0, L.A)((0, L.A)((0, L.A)((0, L.A)((0, L.A)((0, L.A)((0, L.A)((0, L.A)((0, L.A)(Fa, qa.DA, {
                    play: "Spil",
                    pause: "Sæt på pause",
                    seek: "Søg",
                    seekLabel: "{currentTime} af {duration}",
                    currentTime: "Aktuelt klokkeslæt",
                    duration: "Varighed",
                    volume: "Lydstyrke",
                    mute: "Slå lyden fra",
                    unmute: "Slå lyden til",
                    enterFullscreen: "Åbn fuldskærm",
                    exitFullscreen: "Luk fuldskærm",
                    settings: "Indstillinger",
                    menuBack: "Gå tilbage til forrige menu",
                    speed: "Hastighed",
                    normal: "Normal",
                    quality: "Kvalitet",
                    videoAbortedByUser: "Du har afbrudt medieafspilningen.",
                    videoCouldNotBeAccessed: "Videoen kunne ikke indlæses. Tjek forbindelsen, og prøv derefter igen.",
                    videoCouldNotBeDecoded: "Videoen er ikke tilgængelig. Prøv at spille noget andet.",
                    videoCouldNotBePlayed: "Video er ikke tilgængelig, eller formatet understøttes ikke. Prøv en anden browser.",
                    unauthorizedAccess: "Adgang nægtet. Log ind eller kontakt ejeren for at anmode om adgang.",
                    unexpectedError: "Videoen kunne ikke indlæses. Prøv igen senere.",
                    paywallCtaButton: "Tilmeld dig nu",
                    paywallDescription: "Tilmeld dig for at se denne video"
                }), qa.DE, {
                    play: "Abspielen",
                    pause: "Anhalten",
                    seek: "Suche",
                    seekLabel: "{currentTime} von {duration}",
                    currentTime: "Aktuelle Uhrzeit",
                    duration: "Dauer",
                    volume: "Lautstärke",
                    mute: "Stummschalten",
                    unmute: "Stummschaltung aufheben",
                    enterFullscreen: "Zum Vollbildmodus wechseln",
                    exitFullscreen: "Vollbildmodus verlassen",
                    settings: "Einstellungen",
                    menuBack: "Zurück zum vorherigen Menü",
                    speed: "Geschwindigkeit",
                    normal: "Normal",
                    quality: "Qualität",
                    videoAbortedByUser: "Du hast die Medienwiedergabe abgebrochen.",
                    videoCouldNotBeAccessed: "Video konnte nicht geladen werden. Überprüfe deine Internetverbindung und versuche es erneut.",
                    videoCouldNotBeDecoded: "Video nicht verfügbar. Versuche, etwas anderes abzuspielen.",
                    videoCouldNotBePlayed: "Das Video ist nicht verfügbar oder das Format wird nicht unterstützt. Versuche es mit einem anderen Browser.",
                    unauthorizedAccess: "Zugriff verweigert. Logge dich ein oder bitte den Besitzer um Zugriff.",
                    unexpectedError: "Video konnte nicht geladen werden. Versuche es später erneut.",
                    paywallCtaButton: "Jetzt beitreten",
                    paywallDescription: "Registriere dich, um dieses Video anzusehen"
                }), qa.EN, Wa), qa.ES, {
                    play: "Ver",
                    pause: "Pausar",
                    seek: "Buscar",
                    seekLabel: "{currentTime} de {duration}",
                    currentTime: "Hora actual",
                    duration: "Duración",
                    volume: "Volumen",
                    mute: "Silenciar",
                    unmute: "Activar sonido",
                    enterFullscreen: "Ingresar a pantalla completa",
                    exitFullscreen: "Salir de pantalla completa",
                    settings: "Configuración",
                    menuBack: "Regresar al menú anterior",
                    speed: "Velocidad",
                    normal: "Normal",
                    quality: "Calidad",
                    videoAbortedByUser: "Anulaste la reproducción de medios.",
                    videoCouldNotBeAccessed: "No se pudo cargar el video. Comprueba la conexión y vuelve a intentarlo.",
                    videoCouldNotBeDecoded: "Video no disponible. Prueba ver otro video.",
                    videoCouldNotBePlayed: "El video no está disponible o el formato no es compatible. Prueba con otro navegador.",
                    unauthorizedAccess: "Acceso denegado. Inicia sesión o ponte en contacto con el propietario para solicitar acceso.",
                    unexpectedError: "No se puede cargar el video. Intenta de nuevo más tarde.",
                    paywallCtaButton: "Únete ahora",
                    paywallDescription: "Regístrate para ver este video"
                }), qa.FI, {
                    play: "Toista",
                    pause: "Pysäytä",
                    seek: "Etsi",
                    seekLabel: "{currentTime}/{duration}",
                    currentTime: "Nykyinen aika",
                    duration: "Kesto",
                    volume: "Äänenvoimakkuus",
                    mute: "Mykistä",
                    unmute: "Poista mykistys",
                    enterFullscreen: "Siirry koko näytön tilaan",
                    exitFullscreen: "Poistu koko näytön tilasta",
                    settings: "Asetukset",
                    menuBack: "Palaa edelliseen valikkoon",
                    speed: "Nopeus",
                    normal: "Normaali",
                    quality: "Laatu",
                    videoAbortedByUser: "Keskeytit mediatoiston.",
                    videoCouldNotBeAccessed: "Videon lataaminen ei onnistu. Tarkista yhteys ja yritä sitten uudelleen.",
                    videoCouldNotBeDecoded: "Video ei ole käytettävissä. Kokeile katsoa jotain muuta.",
                    videoCouldNotBePlayed: "Video ei ole saatavilla tai muotoa ei tueta. Kokeile toista selainta.",
                    unauthorizedAccess: "Pääsy kielletty. Kirjaudu sisään tai ota yhteyttä omistajaan pyytääksesi käyttöoikeutta.",
                    unexpectedError: "Videon lataaminen ei onnistu. Yritä myöhemmin uudelleen.",
                    paywallCtaButton: "Liity nyt",
                    paywallDescription: "Rekisteröidy nähdäksesi tämän videon"
                }), qa.FR, {
                    play: "Lecture",
                    pause: "Mettre en pause",
                    seek: "Rechercher",
                    seekLabel: "{currentTime} sur {duration}",
                    currentTime: "Heure actuelle",
                    duration: "Durée",
                    volume: "Volume",
                    mute: "Couper le son",
                    unmute: "Réactiver le son",
                    enterFullscreen: "Activer le mode plein écran",
                    exitFullscreen: "Quitter le mode plein écran",
                    settings: "Paramètres",
                    menuBack: "Revenir au menu précédent",
                    speed: "Vitesse",
                    normal: "Normal",
                    quality: "Qualité",
                    videoAbortedByUser: "Vous avez interrompu la lecture du média.",
                    videoCouldNotBeAccessed: "Impossible de charger la vidéo. Vérifiez votre connexion et réessayez.",
                    videoCouldNotBeDecoded: "Vidéo indisponible. Essayez de lancer une autre vidéo.",
                    videoCouldNotBePlayed: "La vidéo n'est pas disponible ou le format n'est pas pris en charge. Essayez un autre navigateur.",
                    unauthorizedAccess: "Accès refusé. Connectez-vous ou contactez le propriétaire pour obtenir l’accès.",
                    unexpectedError: "Impossible de charger la vidéo. Veuillez réessayer ultérieurement.",
                    paywallCtaButton: "S’inscrire",
                    paywallDescription: "Inscrivez-vous pour visionner cette vidéo"
                }), qa.IT, {
                    play: "Riproduci",
                    pause: "Sospendi",
                    seek: "Cerca",
                    seekLabel: "{currentTime} di {duration}",
                    currentTime: "Ora attuale",
                    duration: "Durata",
                    volume: "Volume",
                    mute: "Disattiva audio",
                    unmute: "Riattiva audio",
                    enterFullscreen: "Attiva modalità schermo intero",
                    exitFullscreen: "Esci dalla modalità schermo intero",
                    settings: "Impostazioni",
                    menuBack: "Torna al menu precedente",
                    speed: "Velocità",
                    normal: "Normale",
                    quality: "Qualità",
                    videoAbortedByUser: "La riproduzione dei contenuti multimediali è stata interrotta.",
                    videoCouldNotBeAccessed: "Impossibile caricare il video. Verifica la connessione, quindi riprova.",
                    videoCouldNotBeDecoded: "Video non disponibile. Prova a riprodurre a qualcos'altro.",
                    videoCouldNotBePlayed: "Il video non disponibile o il formato non è supportato. Prova un browser diverso.",
                    unauthorizedAccess: "Accesso negato. Effettua il login o contatta il proprietario per richiedere l'accesso.",
                    unexpectedError: "Impossibile caricare il video. Riprova più tardi.",
                    paywallCtaButton: "Iscriviti ora",
                    paywallDescription: "Iscriviti per visualizzare questo video"
                }), qa.JA, {
                    play: "再生",
                    pause: "[一時停止]",
                    seek: '"シーク',
                    seekLabel: "{currentTime} の {duration}",
                    currentTime: "現在の時刻",
                    duration: "所要時間",
                    volume: "ボリューム",
                    mute: '"ミュート',
                    unmute: "ミュート解除",
                    enterFullscreen: "フルスクリーンに切り替え",
                    exitFullscreen: "全画面表示を終了",
                    settings: "[設定]",
                    menuBack: '"前のメニューに戻る',
                    speed: "スピード",
                    normal: "ノーマル",
                    quality: "クオリティ",
                    videoAbortedByUser: "メディアの再生を中止しました。",
                    videoCouldNotBeAccessed: "動画を読み込めませんでした。 接続を確認して、もう一度試してください。",
                    videoCouldNotBeDecoded: "ビデオは利用できません。 他のものをプレイしてみてください。",
                    videoCouldNotBePlayed: "ビデオが利用できないか、フォーマットがサポートされていません。 別のブラウザを試してください。",
                    unauthorizedAccess: "アクセスが拒否されました。 ログインするか、所有者に連絡してアクセスをリクエストしてください。",
                    unexpectedError: "ビデオを読み込めません。 後でもう一度試してください。",
                    paywallCtaButton: "今すぐ加入",
                    paywallDescription: "この動画を見るには登録してください"
                }), qa.NL, {
                    play: "Afspelen",
                    pause: "Pauzeren",
                    seek: "Zoeken",
                    seekLabel: "{currentTime} van {duration}",
                    currentTime: "Huidige tijd",
                    duration: "Duur",
                    volume: "Volume",
                    mute: "Dempen",
                    unmute: "Dempen opheffen",
                    enterFullscreen: "Naar volledig scherm",
                    exitFullscreen: "Volledig scherm afsluiten",
                    settings: "Instellingen",
                    menuBack: "Terug naar vorig menu",
                    speed: "Snelheid",
                    normal: "Normaal",
                    quality: "Kwaliteit",
                    videoAbortedByUser: "Je hebt het afspelen van media afgebroken.",
                    videoCouldNotBeAccessed: "Kan video niet laden. Controleer de verbinding en probeer het opnieuw.",
                    videoCouldNotBeDecoded: "Video niet beschikbaar. Probeer om iets anders af te spelen.",
                    videoCouldNotBePlayed: "De video is niet beschikbaar of het formaat wordt niet ondersteund. Probeer een andere browser.",
                    unauthorizedAccess: "Toegang geweigerd. Log in of neem contact op met de eigenaar om toegang te vragen.",
                    unexpectedError: "Kan video niet laden. Probeer het later opnieuw.",
                    paywallCtaButton: "Word nu lid",
                    paywallDescription: "Meld je aan om deze video te bekijken"
                }), qa.NO, {
                    play: "Spill av",
                    pause: "Pause",
                    seek: "Søk",
                    seekLabel: "{currentTime} av {duration}",
                    currentTime: "Nåværende tidspunkt",
                    duration: "Varighet",
                    volume: "Volum",
                    mute: "Demp",
                    unmute: "Slå på lyden",
                    enterFullscreen: "Start fullskjermmodus",
                    exitFullscreen: "Avslutt fullskjermmodus",
                    settings: "Innstillinger",
                    menuBack: "Gå tilbake til forrige meny",
                    speed: "Hastighet",
                    normal: "Normal",
                    quality: "Kvalitet",
                    videoAbortedByUser: "Du avbrøt medieavspillingen.",
                    videoCouldNotBeAccessed: "Kunne ikke laste video. Sjekk tilkoblingen og prøv igjen.",
                    videoCouldNotBeDecoded: "Videoen er utilgjengelig. Prøv å spille av noe annet.",
                    videoCouldNotBePlayed: "Videoen er ikke tilgjengelig eller formatet støttes ikke. Prøv en annen nettleser.",
                    unauthorizedAccess: "Ingen tilgang. Logg på eller be eieren om tilgang.",
                    unexpectedError: "Kan ikke laste video. Prøv igjen senere.",
                    paywallCtaButton: "Bli med nå",
                    paywallDescription: "Registrer deg for å se denne videoen"
                }), (0, L.A)((0, L.A)(Fa, qa.PT, {
                    play: "Reproduzir",
                    pause: "Pausar",
                    seek: "Procurar",
                    seekLabel: "{currentTime} de {duration}",
                    currentTime: "Horário atual",
                    duration: "Duração",
                    volume: "Volume",
                    mute: "Silenciar",
                    unmute: "Ativar o som",
                    enterFullscreen: "Abrir em tela cheia",
                    exitFullscreen: "Sair da tela cheia",
                    settings: "Configurações",
                    menuBack: "Voltar ao menu anterior",
                    speed: "Velocidade",
                    normal: "Normal",
                    quality: "Qualidade",
                    videoAbortedByUser: "Você abortou a reprodução da mídia.",
                    videoCouldNotBeAccessed: "Não foi possível carregar o vídeo. Verifique a conexão e tente novamente.",
                    videoCouldNotBeDecoded: "O vídeo está indisponível. Tente reproduzir outra coisa.",
                    videoCouldNotBePlayed: "O vídeo está indisponível ou o formato não é aceito. Use outro browser.",
                    unauthorizedAccess: "Acesso negado. Faça o login ou solicite o acesso ao proprietário.",
                    unexpectedError: "Não foi possível carregar o vídeo. Tente novamente mais tarde.",
                    paywallCtaButton: "Participe agora",
                    paywallDescription: "Cadastre-se para ver este vídeo"
                }), qa.SV, {
                    play: "Spela",
                    pause: "Paus",
                    seek: "Sök",
                    seekLabel: "{currentTime} av {duration}",
                    currentTime: "Aktuell tid",
                    duration: "Längd",
                    volume: "Volym",
                    mute: "Stäng av ljudet",
                    unmute: "Sätt på ljudet",
                    enterFullscreen: "Öppna helskärmsläge",
                    exitFullscreen: "Lämna helskärmsläge",
                    settings: "Inställningar",
                    menuBack: "Gå tillbaka till föregående meny",
                    speed: "Hastighet",
                    normal: "Normal",
                    quality: "Kvalitet",
                    videoAbortedByUser: "Du avbröt medieuppspelningen.",
                    videoCouldNotBeAccessed: "Det gick inte att läsa in videon. Kontrollera anslutningen och försök igen.",
                    videoCouldNotBeDecoded: "Videon är inte tillgänglig. Försök spela upp något annat.",
                    videoCouldNotBePlayed: "Videofilen är inte tillgänglig, eller så stöds inte videoformatet. Försök med en annan webbläsare.",
                    unauthorizedAccess: "Åtkomst nekad. Logga in eller kontakta ägaren för att begära åtkomst.",
                    unexpectedError: "Videon kunde inte läsas in. Försök igen senare.",
                    paywallCtaButton: "Registrera dig nu",
                    paywallDescription: "Registrera dig för att se den här videon"
                })),
                za = qa.EN;

            function Xa(e, t) {
                var i = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }

            function Qa(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var i = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Xa(Object(i), !0).forEach((function(t) {
                        (0, L.A)(e, t, i[t])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Xa(Object(i)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                    }))
                }
                return e
            }
            var Ja = function(e) {
                    var t;
                    return e && null !== (t = function(e) {
                        var t = e.split("-")[0];
                        return Object.values(qa).find((function(e) {
                            return e === t
                        }))
                    }(e)) && void 0 !== t ? t : za
                },
                Za = function(e) {
                    var t = Ja(e);
                    return function(e) {
                        return Qa(Qa({}, Ya[za]), e)
                    }(Ya[t])
                },
                eo = function() {
                    function e() {
                        (0, b.A)(this, e)
                    }
                    return (0, T.A)(e, null, [{
                        key: "createLoadingIndicatorElement",
                        value: function() {
                            var t = document.createElement("div");
                            return t.classList.add(e.LoadingIndicatorClassName), t.appendChild(e.createLoadingIndicatorIcon()), t
                        }
                    }, {
                        key: "createLoadingIndicatorIcon",
                        value: function() {
                            var e = "http://www.w3.org/2000/svg",
                                t = document.createElementNS(e, "circle");
                            t.setAttribute("cx", "50"), t.setAttribute("cy", "50"), t.setAttribute("r", "20"), t.setAttribute("stroke", "#fff"), t.setAttribute("stroke-width", "6"), t.setAttribute("class", this.LoadingIndicatorPathClassName);
                            var i = document.createElementNS(e, "svg");
                            return i.setAttribute("viewBox", "25 25 50 50"), i.setAttribute("class", this.LoadingIndicatorSpinnerClassName), i.appendChild(t), i
                        }
                    }])
                }();
            (0, L.A)(eo, "LoadingIndicatorClassName", "video-player__loading-indicator"), (0, L.A)(eo, "LoadingIndicatorPathClassName", "loading-indicator__path"), (0, L.A)(eo, "LoadingIndicatorSpinnerClassName", "loading-indicator__spinner");
            var to = (0, T.A)((function e(t, i, r) {
                if ((0, b.A)(this, e), this.player = t, this.isExternalProvider = i, this.controls = r, !i && r.includes(V.LoadingIndicator)) {
                    var n = t.elements.container;
                    this.loadingIndicatorElement = eo.createLoadingIndicatorElement(), this.loadingIndicatorElement.classList.add(e.PlyrLoadingIndicatorClassName), null == n || n.appendChild(this.loadingIndicatorElement)
                } else this.loadingIndicatorElement = null
            }), [{
                key: "destroy",
                value: function() {
                    var e;
                    null === (e = this.loadingIndicatorElement) || void 0 === e || e.remove()
                }
            }]);
            (0, L.A)(to, "PlyrLoadingIndicatorClassName", "video-player__plyr-loading-indicator");
            var io = function() {
                function e(t) {
                    (0, b.A)(this, e), (0, L.A)(this, "loadingScreenClassName", "video-player__loading-screen"), this.loadingScreenElement = this.createLoadingScreenElement(t)
                }
                return (0, T.A)(e, [{
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.loadingScreenElement) || void 0 === e || e.remove()
                    }
                }, {
                    key: "createLoadingScreenElement",
                    value: function(t) {
                        var i = t.elements.container,
                            r = document.createElement("div");
                        return r.setAttribute("data-testid", e.TestId), r.classList.add(this.loadingScreenClassName), r.appendChild(eo.createLoadingIndicatorElement()), null == i || i.appendChild(r), r
                    }
                }])
            }();
            (0, L.A)(io, "TestId", "loading-screen");
            var ro = i(21624),
                no = i.n(ro),
                so = {
                    Production: "tb16k74rdoomqkj011camna48",
                    Staging: "u60tljq3v5gek60ineusdrgb5",
                    QA: "3dalas4vtrnc5h5l5fk06t6q1",
                    Dev: "kci6tb6aqeh5i95l94718otiq"
                },
                ao = ["AhrefsBot", "AhrefsSiteAudit", "Applebot", "Baiduspider", "bingbot", "Cocolyzebot", "DuckDuckBot", "Facebot", "Googlebot", "jooble-bot", "pingbot", "SeobilityBot", "SiteAuditBot", "SMTBot", "Twitterbot", "YandexBot"],
                oo = (0, T.A)((function e(t, i) {
                    var r, n, s;
                    if ((0, b.A)(this, e), r = window.navigator.userAgent, n = ao.map((function(e) {
                            return e.toLowerCase()
                        })), s = r.toLowerCase(), !n.some((function(e) {
                            return s.includes(e)
                        })) && (null == t ? void 0 : t.media) instanceof HTMLVideoElement) {
                        var a = this.getEnvKey(i.environment);
                        this.monitor(t.media, a, i)
                    }
                }), [{
                    key: "getEnvKey",
                    value: function(e) {
                        var t = Object.keys(a).map((function(e) {
                            return e
                        })).find((function(t) {
                            return a[t] === e
                        }));
                        if (!t) throw new S(p, "Provided environment does not match Mux Data environments configuration.");
                        return so[t]
                    }
                }, {
                    key: "monitor",
                    value: function(e, t, i) {
                        var r = this.getOptions(t, i);
                        no().monitor(e, r)
                    }
                }, {
                    key: "getOptions",
                    value: function(e, t) {
                        var i, r, n, s, o = t.environment,
                            c = t.src,
                            d = t.videoPlayerContext,
                            u = t.playerInitTime,
                            h = t.playbackDriver,
                            f = t.sessionId,
                            m = d.squarespaceContext,
                            p = d.videoAssetDetails,
                            g = d.assetDestination,
                            y = d.contentCollectionId,
                            v = d.contentItemId,
                            b = (i = p.alexandriaUrl, r = "/{variant}", i.endsWith(r) && i.replace(r, "").split("/").pop() || null),
                            T = "n/a";
                        return h instanceof Ua && (n = Sa, s = h.hlsJsInstance, T = "hlsJs"), h instanceof $a && (T = "hlsNative"), {
                            Hls: n,
                            hlsjs: s,
                            debug: o === a.Dev,
                            disableCookies: !0,
                            data: {
                                env_key: e,
                                viewer_user_id: f,
                                player_name: "@sqs/video-player",
                                player_version: l,
                                player_init_time: u,
                                video_id: v,
                                video_title: b,
                                video_duration: 1e3 * p.duration,
                                video_stream_type: c,
                                video_series: y,
                                experiment_name: "HLS (".concat(T, ")"),
                                custom_1: m.website.id,
                                custom_2: g
                            }
                        }
                    }
                }]),
                lo = (0, T.A)((function e(t, i, r) {
                    (0, b.A)(this, e), this.element = document.createElement("button"), this.onCtaClick = r, this.element.classList.add(e.ClassName), this.element.innerText = i, this.subscribeEvents(), null == t || t.appendChild(this.element)
                }), [{
                    key: "destroy",
                    value: function() {
                        this.unsubscribeEvents(), this.element.remove()
                    }
                }, {
                    key: "subscribeEvents",
                    value: function() {
                        this.element.addEventListener("click", this.onCtaClick)
                    }
                }, {
                    key: "unsubscribeEvents",
                    value: function() {
                        this.element.removeEventListener("click", this.onCtaClick)
                    }
                }]);
            (0, L.A)(lo, "ClassName", "video-player__paywall-cta-button");
            var co = (0, T.A)((function e(t, i) {
                (0, b.A)(this, e);
                var r = document.createElement("p");
                r.innerHTML = i, this.element = document.createElement("div"), this.element.classList.add(e.ClassName), this.element.appendChild(r), null == t || t.appendChild(this.element)
            }), [{
                key: "destroy",
                value: function() {
                    this.element.remove()
                }
            }]);
            (0, L.A)(co, "ClassName", "video-player__paywall-description");
            var uo = (0, T.A)((function e(t) {
                (0, b.A)(this, e);
                var i = "http://www.w3.org/2000/svg",
                    r = document.createElement("div"),
                    n = document.createElementNS(i, "svg"),
                    s = document.createElementNS(i, "use"),
                    a = "#".concat("video-player__icon", "-").concat("lock");
                r.classList.add(e.ClassName), "href" in s && s.setAttributeNS("http://www.w3.org/1999/xlink", "href", a), s.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", a), n.appendChild(s), r.appendChild(n), this.element = r, null == t || t.appendChild(r)
            }), [{
                key: "destroy",
                value: function() {
                    this.element.remove()
                }
            }]);
            (0, L.A)(uo, "ClassName", "video-player__lock-icon");
            var ho = function() {
                function e(t, i, r) {
                    (0, b.A)(this, e), (0, L.A)(this, "ctaButton", null), (0, L.A)(this, "description", null), (0, L.A)(this, "lockIcon", null), this.player = t, this.screenElement = this.createScreenElement();
                    var n = t.config.i18n,
                        s = n.paywallCtaButton,
                        a = n.paywallDescription;
                    this.createLockIcon(), this.createDescription(a), this.createCtaButton(r.onCtaClick, s), this.hideVideoPlayerControls(), null == i || i.appendChild(this.screenElement)
                }
                return (0, T.A)(e, [{
                    key: "destroy",
                    value: function() {
                        this.removeUIElements(), this.showVideoPlayerControls()
                    }
                }, {
                    key: "createScreenElement",
                    value: function() {
                        var t = document.createElement("div");
                        return t.classList.add(e.ClassName), t
                    }
                }, {
                    key: "createLockIcon",
                    value: function() {
                        this.lockIcon = new uo(this.screenElement)
                    }
                }, {
                    key: "createDescription",
                    value: function(e) {
                        this.description = new co(this.screenElement, e)
                    }
                }, {
                    key: "createCtaButton",
                    value: function(e, t) {
                        this.ctaButton = new lo(this.screenElement, t, e)
                    }
                }, {
                    key: "removeUIElements",
                    value: function() {
                        var e, t, i, r;
                        null === (e = this.lockIcon) || void 0 === e || e.destroy(), null === (t = this.description) || void 0 === t || t.destroy(), null === (i = this.ctaButton) || void 0 === i || i.destroy(), null === (r = this.screenElement) || void 0 === r || r.remove()
                    }
                }, {
                    key: "hideVideoPlayerControls",
                    value: function() {
                        var e = this.player.elements.controls;
                        null == e || e.classList.add("video-player__controls--hidden"), this.player.toggleControls(!1)
                    }
                }, {
                    key: "showVideoPlayerControls",
                    value: function() {
                        var e = this.player.elements.controls;
                        null == e || e.classList.remove("video-player__controls--hidden")
                    }
                }])
            }();
            (0, L.A)(ho, "ClassName", "video-player__paywall-screen");
            var fo = {
                    Small: {
                        minWidth: 0,
                        className: "video-player"
                    },
                    Medium: {
                        minWidth: 480,
                        className: "video-player--medium"
                    },
                    Large: {
                        minWidth: 768,
                        className: "video-player--large"
                    }
                },
                mo = (0, T.A)((function e(t, i) {
                    var r, n = this;
                    (0, b.A)(this, e), this.videoPlayerElement = t, this.getPlayerContainer = i, this.updateContainerClassNames(), this.videoObserver = new ResizeObserver((function() {
                        n.updateContainerClassNames()
                    })), null === (r = this.videoObserver) || void 0 === r || r.observe(t)
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        this.removeContainerClassNames(), null === (e = this.videoObserver) || void 0 === e || e.disconnect()
                    }
                }, {
                    key: "updateContainerClassNames",
                    value: function() {
                        var e, t = this,
                            i = Object.values(fo),
                            r = (null === (e = this.getPlayerContainer()) || void 0 === e ? void 0 : e.clientWidth) || this.videoPlayerElement.clientWidth;
                        i.forEach((function(e) {
                            var i = e.minWidth,
                                n = e.className;
                            r >= i ? t.videoPlayerElement.classList.add(n) : r < i && t.videoPlayerElement.classList.remove(n)
                        }))
                    }
                }, {
                    key: "removeContainerClassNames",
                    value: function() {
                        var e = this;
                        Object.values(fo).forEach((function(t) {
                            var i = t.className;
                            e.videoPlayerElement.classList.remove(i)
                        }))
                    }
                }]),
                po = (["only screen and (pointer: coarse) and (orientation: portrait) and (max-device-width: ".concat(767, "px)"), "only screen and (pointer: coarse) and (orientation: landscape) and (max-device-height: ".concat(767, "px)")].join(","), (0, T.A)((function e(t, i) {
                    var r = this;
                    (0, b.A)(this, e), (0, L.A)(this, "thumbnailFocalPointClassName", "video-player__thumbnail--focal-point"), (0, L.A)(this, "thumbnailYouTubeFailureClassName", "video-player__thumbnail--youtube-failure"), this.player = t, t.once("ready", (function() {
                        r.thumbnailElement = null == t ? void 0 : t.elements.poster, i && r.setFocalPoint(i), r.hideThumbnailOnYouTubeFailure()
                    }))
                }), [{
                    key: "destroy",
                    value: function() {
                        var e, t;
                        null === (e = this.thumbnailElement) || void 0 === e || e.classList.remove(this.thumbnailFocalPointClassName), null === (t = this.thumbnailElement) || void 0 === t || t.classList.remove(this.thumbnailYouTubeFailureClassName), this.thumbnailElement = null
                    }
                }, {
                    key: "setFocalPoint",
                    value: function(e) {
                        this.thumbnailElement && (this.thumbnailElement.classList.add(this.thumbnailFocalPointClassName), this.thumbnailElement.style.backgroundPosition = this.mapFocalPointToBackgroundPosition(e))
                    }
                }, {
                    key: "mapFocalPointToBackgroundPosition",
                    value: function(e) {
                        var t = e.x,
                            i = e.y;
                        return "".concat(100 * t, "% ").concat(100 * i, "%")
                    }
                }, {
                    key: "hideThumbnailOnYouTubeFailure",
                    value: function() {
                        var e, t, i, r = (null === (e = this.player) || void 0 === e ? void 0 : e.provider) === J.YouTube,
                            n = 0 === (null === (t = this.player) || void 0 === t ? void 0 : t.duration);
                        r && n && (null === (i = this.thumbnailElement) || void 0 === i || i.classList.add(this.thumbnailYouTubeFailureClassName))
                    }
                }])),
                go = function(e) {
                    return e.detail.plyr.currentTime || 0
                },
                yo = function(e) {
                    return e.detail.plyr.duration
                };

            function vo(e, t) {
                var i = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }

            function bo(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var i = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? vo(Object(i), !0).forEach((function(t) {
                        (0, L.A)(e, t, i[t])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : vo(Object(i)).forEach((function(t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                    }))
                }
                return e
            }
            var To = function() {
                function e() {
                    (0, b.A)(this, e)
                }
                return (0, T.A)(e, null, [{
                    key: "getOptions",
                    value: function() {
                        if (!e.isSupported()) return null;
                        var t = window.localStorage.getItem(e.StorageKey);
                        return t ? JSON.parse(t) : null
                    }
                }, {
                    key: "setOption",
                    value: function(t, i) {
                        if (e.isSupported()) {
                            var r = bo(bo({}, e.getOptions()), {}, (0, L.A)({}, t, i));
                            window.localStorage.setItem(e.StorageKey, JSON.stringify(r))
                        }
                    }
                }, {
                    key: "isSupported",
                    value: function() {
                        try {
                            if (!window.localStorage) return !1;
                            var e = "is_supported_test";
                            return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0
                        } catch (e) {
                            return !1
                        }
                    }
                }])
            }();
            (0, L.A)(To, "StorageKey", "squarespace-video-player-options");
            var Eo = (0, T.A)((function e(t, i) {
                    var r = this;
                    (0, b.A)(this, e), (0, L.A)(this, "containerClassName", "video-player__container--click-to-play"), i.clickToPlay && (this.plyrContainer = null == t ? void 0 : t.elements.container, t.once("ready", (function() {
                        r.setContainerClassName()
                    })))
                }), [{
                    key: "destroy",
                    value: function() {
                        this.removeContainerClassName()
                    }
                }, {
                    key: "setContainerClassName",
                    value: function() {
                        var e;
                        null === (e = this.plyrContainer) || void 0 === e || e.classList.add(this.containerClassName)
                    }
                }, {
                    key: "removeContainerClassName",
                    value: function() {
                        var e;
                        null === (e = this.plyrContainer) || void 0 === e || e.classList.remove(this.containerClassName)
                    }
                }]),
                Ao = '\n  <?xml version="1.0" encoding="UTF-8"?>\n  <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    '.concat('\n  <symbol id="video-player__icon-backward" viewBox="0 0 72 72">\n    <path d="M23.2519 58H31.1519V56.04H28.5919V43.64H26.4919C26.3919 44.48 26.0519 45 25.4519 45.34C24.8919 45.64 24.1319 45.84 23.0519 45.86V47.72H26.1519V56.04H23.2519V58ZM38.14 43.42C34.08 43.42 33.1 47 33.1 50.88C33.1 55.12 34.18 58.3 38.16 58.3C42.12 58.3 43.22 55.12 43.22 50.88C43.22 47 42.24 43.42 38.14 43.42ZM38.16 45.62C40.18 45.62 40.6 48 40.6 50.88C40.6 53.98 40.1 56.2 38.16 56.2C36.22 56.2 35.72 53.98 35.72 50.9C35.72 48 36.12 45.62 38.16 45.62Z" fill="white"/>\n    <path d="M53 10L53 37L31 23.498L53 10Z" fill="white"/>\n    <path d="M31 10L31 37L9 23.498L31 10Z" fill="white"/>\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-enter-fullscreen" viewBox="0 0 24 24">\n    <path fill="currentColor" d="m4,4l6,0l0,2l-4,0l0,4l-2,0l0,-6z" />\n    <path fill="currentColor" d="m20,4l-6,0l0,2l4,0l0,4l2,0l0,-6z" />\n    <path fill="currentColor" d="m10,20l-6,0l0,-6l2,0l0,4l4,0l0,2z" />\n    <path fill="currentColor" d="m20,20l-6,0l0,-2l4,0l0,-4l2,0l0,6z" />\n    <path stroke-opacity="0.15" stroke="black" d="m4,4l6,0l0,2l-4,0l0,4l-2,0l0,-6z" />\n    <path stroke-opacity="0.15" stroke="black" d="m20,4l-6,0l0,2l4,0l0,4l2,0l0,-6z" />\n    <path stroke-opacity="0.15" stroke="black" d="m10,20l-6,0l0,-6l2,0l0,4l4,0l0,2z" />\n    <path stroke-opacity="0.15" stroke="black" d="m20,20l-6,0l0,-2l4,0l0,-4l2,0l0,6z" />\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-exit-fullscreen" viewBox="0 0 24 24">\n    <path fill="currentColor" d="m10,10l-6,0l0,-2l4,0l0,-4l2,0l0,6z" />\n    <path fill="currentColor" d="m14,10l6,0l0,-2l-4,0l0,-4l-2,0l0,6z" />\n    <path fill="currentColor" d="m4,14l6,0l0,6l-2,0l0,-4l-4,0l0,-2z" />\n    <path fill="currentColor" d="m14,14l6,0l0,2l-4,0l0,4l-2,0l0,-6z" />\n    <path stroke-opacity="0.15" stroke="black" d="m10,10l-6,0l0,-2l4,0l0,-4l2,0l0,6z" />\n    <path stroke-opacity="0.15" stroke="black" d="m14,10l6,0l0,-2l-4,0l0,-4l-2,0l0,6z" />\n    <path stroke-opacity="0.15" stroke="black" d="m4,14l6,0l0,6l-2,0l0,-4l-4,0l0,-2z" />\n    <path stroke-opacity="0.15" stroke="black" d="m14,14l6,0l0,2l-4,0l0,4l-2,0l0,-6z" />\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-forward" viewBox="0 0 72 72">\n    <path d="M23.2519 58H31.1519V56.04H28.5919V43.64H26.4919C26.3919 44.48 26.0519 45 25.4519 45.34C24.8919 45.64 24.1319 45.84 23.0519 45.86V47.72H26.1519V56.04H23.2519V58ZM38.14 43.42C34.08 43.42 33.1 47 33.1 50.88C33.1 55.12 34.18 58.3 38.16 58.3C42.12 58.3 43.22 55.12 43.22 50.88C43.22 47 42.24 43.42 38.14 43.42ZM38.16 45.62C40.18 45.62 40.6 48 40.6 50.88C40.6 53.98 40.1 56.2 38.16 56.2C36.22 56.2 35.72 53.98 35.72 50.9C35.72 48 36.12 45.62 38.16 45.62Z" fill="white"/>\n    <path d="M13 37V10L35 23.502L13 37Z" fill="white"/>\n    <path d="M35 37V10L57 23.502L35 37Z" fill="white"/>\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-muted" viewBox="0 0 24 24">\n    <path fill-rule="evenodd" clip-rule="evenodd" d="M15 21L16 23H18.2417L7.25 1H5L7.90476 6.80952L6 8H1V16H6L14 21H15ZM8.73495 8.46989L13 17V18.1957L7 14.4457V9.55423L8.73495 8.46989ZM3 10V14H5V10H3Z" fill="currentColor" />\n    <path d="M11.3386 4.66339L12.1683 6.32406L13 5.80423V7.98874L15 11.9917V3H14L11.3386 4.66339Z" fill="currentColor" />\n    <path d="M17.9634 17.9231L17.0026 16C19.2106 15.9986 21 14.2083 21 12C21 9.79086 19.2091 8 17 8V6C20.3137 6 23 8.68629 23 12C23 14.9858 20.8191 17.4621 17.9634 17.9231Z" fill="currentColor" />\n    <path d="M19 12C19 10.8954 18.1046 10 17 10V14C18.1046 14 19 13.1046 19 12Z" fill="currentColor" />\n    <path fill-rule="evenodd" clip-rule="evenodd" d="M15 21L16 23H18.2417L7.25 1H5L7.90476 6.80952L6 8H1V16H6L14 21H15ZM8.73495 8.46989L13 17V18.1957L7 14.4457V9.55423L8.73495 8.46989ZM3 10V14H5V10H3Z" stroke="black" stroke-opacity="0.15" />\n    <path d="M11.3386 4.66339L12.1683 6.32406L13 5.80423V7.98874L15 11.9917V3H14L11.3386 4.66339Z" stroke="black" stroke-opacity="0.15" />\n    <path d="M17.9634 17.9231L17.0026 16C19.2106 15.9986 21 14.2083 21 12C21 9.79086 19.2091 8 17 8V6C20.3137 6 23 8.68629 23 12C23 14.9858 20.8191 17.4621 17.9634 17.9231Z" stroke="black" stroke-opacity="0.15" />\n    <path d="M19 12C19 10.8954 18.1046 10 17 10V14C18.1046 14 19 13.1046 19 12Z" stroke="black" stroke-opacity="0.15" />\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-pause" viewBox="0 0 72 72">\n    <path d="M42.0469 16.042H54V57.9482H42.0469V16.042ZM18 57.9482V16.042H29.9531V57.9482H18Z" />\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-replay" viewBox="0 0 72 72">\n    <path d="M19.9587 31.6466C22.5091 25.0906 29.0569 19.8821 36.4712 19.8822C45.9757 19.8823 54.1177 27.9446 54.1178 37.5288C54.1179 47.1225 46.0033 55.1756 36.4712 55.1754C31.8366 55.1754 27.2731 53.2868 23.9932 50.0069L19.8338 54.1662C24.2174 58.5498 30.2773 61.0576 36.4712 61.0576C49.238 61.0578 60.0001 50.3851 60 37.5288C59.9999 24.6779 49.2063 14.0001 36.4712 14C27.6621 13.9999 19.9161 19.3001 15.8864 26.5302V14L9.99999 19.8822L9.99999 37.533L27.6508 37.5288L33.533 31.6466H19.9587Z" />\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-play" viewBox="0 0 72 72">\n    <path d="M24.2842 54.7435V17.2559L55.5238 36.0025L24.2842 54.7435Z" />\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-settings" viewBox="0 0 24 24">\n    <path stroke-opacity="0.15" stroke="black" fill="currentColor" d="m16.1918,6.39334c-0.9162,-0.68607 -2.0061,-1.15284 -3.1918,-1.32245l0,-2.07089l-2,0l0,2.07089c-1.18575,0.16961 -2.27564,0.63638 -3.19181,1.32245l-1.46429,-1.46429l-1.41421,1.41421l1.4642,1.4642c-0.68637,0.91632 -1.15335,2.00648 -1.323,3.19254l-2.07089,0l0,2l2.07089,0c0.16965,1.1861 0.63661,2.2762 1.32297,3.1925l-1.46432,1.4643l1.41421,1.4142l1.46441,-1.4644c0.91618,0.6861 2.00608,1.1529 3.19184,1.3225l0,2.0709l2,0l0,-2.0709c1.1858,-0.1696 2.2758,-0.6364 3.192,-1.3226l1.4645,1.4645l1.4142,-1.4142l-1.4645,-1.4644c0.6863,-0.9163 1.1533,-2.0064 1.3229,-3.1924l2.0709,0l0,-2l-2.0709,0c-0.1696,-1.18606 -0.6366,-2.27622 -1.323,-3.19254l1.4644,-1.46443l-1.4142,-1.41421l-1.4645,1.46452zm-4.1918,10.60666c2.7614,0 5,-2.2386 5,-5c0,-2.76142 -2.2386,-5 -5,-5c-2.76142,0 -5,2.23858 -5,5c0,2.7614 2.23858,5 5,5z" clip-rule="evenodd" fill-rule="evenodd" />\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-volume" viewBox="0 0 24 24">\n    <path fill="currentColor" d="m15,21l0,-18l-1,0l-8,5l-5,0l0,8l5,0l8,5l1,0zm-8,-6.5543l0,-4.89147l6,-3.75l0,12.39147l-6,-3.75zm-4,-4.4457l0,4l2,0l0,-4l-2,0z" clip-rule="evenodd" fill-rule="evenodd" />\n    <path fill="currentColor" d="m17,8c2.2091,0 4,1.79086 4,4c0,2.2091 -1.7909,4 -4,4l0,2c3.3137,0 6,-2.6863 6,-6c0,-3.31371 -2.6863,-6 -6,-6l0,2z" />\n    <path fill="currentColor" d="m19,12c0,-1.10457 -0.8954,-2 -2,-2l0,4c1.1046,0 2,-0.8954 2,-2z" />\n    <path stroke-opacity="0.15" stroke="black" d="m15,21l0,-18l-1,0l-8,5l-5,0l0,8l5,0l8,5l1,0zm-8,-6.5543l0,-4.89147l6,-3.75l0,12.39147l-6,-3.75zm-4,-4.4457l0,4l2,0l0,-4l-2,0z" clip-rule="evenodd" fill-rule="evenodd" />\n    <path stroke-opacity="0.15" stroke="black" d="m17,8c2.2091,0 4,1.79086 4,4c0,2.2091 -1.7909,4 -4,4l0,2c3.3137,0 6,-2.6863 6,-6c0,-3.31371 -2.6863,-6 -6,-6l0,2z" />\n    <path stroke-opacity="0.15" stroke="black" d="m19,12c0,-1.10457 -0.8954,-2 -2,-2l0,4c1.1046,0 2,-0.8954 2,-2z" />\n  </symbol>\n', "\n    ").concat('\n  <symbol id="video-player__icon-lock" viewBox="0 0 21 26">\n    <path d="M9.1875 15.6V20.8H11.8125V15.6H9.1875Z" fill="white"/>\n    <path fill-rule="evenodd" clip-rule="evenodd" d="M3.9375 6.5V10.4H0V26H21V10.4H17.0625V6.5C17.0625 2.91015 14.1244 0 10.5 0C6.87563 0 3.9375 2.91015 3.9375 6.5ZM10.5 2.6C8.32538 2.6 6.5625 4.34609 6.5625 6.5V10.4H14.4375V6.5C14.4375 4.34609 12.6746 2.6 10.5 2.6ZM2.625 13V23.4H18.375V13H2.625Z" fill="white"/>\n  </symbol>\n', "\n  </svg>\n"),
                wo = (0, T.A)((function e(t, i) {
                    (0, b.A)(this, e), (0, L.A)(this, "iconsClassName", "video-player__icons"), (0, L.A)(this, "iconsElement", null), i.length > 0 && (this.iconsElement = this.createIconSpriteElement(), t.appendChild(this.iconsElement))
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.iconsElement) || void 0 === e || e.remove()
                    }
                }, {
                    key: "createIconSpriteElement",
                    value: function() {
                        var e = document.createElement("div");
                        return e.classList.add(this.iconsClassName), e.innerHTML = Ao, e
                    }
                }]),
                _o = (0, T.A)((function e(t, i) {
                    (0, b.A)(this, e), (0, L.A)(this, "className", "video-player__navigation-indicator"), (0, L.A)(this, "showClassName", "".concat(this.className, "--show"));
                    var r = "http://www.w3.org/2000/svg",
                        n = document.createElement("div"),
                        s = document.createElementNS(r, "svg"),
                        a = document.createElementNS(r, "use"),
                        o = "#".concat("video-player__icon", "-").concat(t),
                        l = "".concat(this.className, "--").concat(t);
                    n.classList.add(this.className, l), "href" in a && a.setAttributeNS("http://www.w3.org/1999/xlink", "href", o), a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", o), s.appendChild(a), n.appendChild(s), this.element = n, i.appendChild(n)
                }), [{
                    key: "show",
                    value: function() {
                        this.element.classList.add(this.showClassName)
                    }
                }, {
                    key: "hide",
                    value: function() {
                        this.element.classList.remove(this.showClassName)
                    }
                }]),
                ko = function(e) {
                    return e.Backward = "backward", e.Forward = "forward", e
                }({}),
                So = (0, T.A)((function e(t, i, r) {
                    var n, s, a = this;
                    (0, b.A)(this, e), (0, L.A)(this, "navigationIndicatorsClassName", "video-player__navigation-indicators"), (0, L.A)(this, "hideIndicatorTimeoutMs", 1e3), (0, L.A)(this, "navigationIndicatorsElement", null), (0, L.A)(this, "backwardNavigationIndicator", null), (0, L.A)(this, "forwardNavigationIndicator", null), (0, L.A)(this, "plyrContainer", null), (0, L.A)(this, "toggleNavigationIndicatorListener", (function(e) {
                        var t = e.key;
                        if (a.player.seeking) switch (t) {
                            case "ArrowLeft":
                                a.handleBackwardNavigationIndicator();
                                break;
                            case "ArrowRight":
                                a.handleForwardNavigationIndicator()
                        }
                    })), this.player = t;
                    var o, l = i.includes(V.NavigationIndicators),
                        c = Boolean((null === (n = r.keyboard) || void 0 === n ? void 0 : n.focused) || (null === (s = r.keyboard) || void 0 === s ? void 0 : s.global));
                    l && c && (this.plyrContainer = t.elements.container, this.navigationIndicatorsElement = this.createNavigationIndicatorsElement(), null === (o = this.plyrContainer) || void 0 === o || o.appendChild(this.navigationIndicatorsElement), this.subscribeEvents())
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        this.unsubscribeEvents(), null === (e = this.navigationIndicatorsElement) || void 0 === e || e.remove()
                    }
                }, {
                    key: "createNavigationIndicatorsElement",
                    value: function() {
                        var e = document.createElement("div");
                        return e.classList.add(this.navigationIndicatorsClassName), this.createNavigationIndicators(e), e
                    }
                }, {
                    key: "createNavigationIndicators",
                    value: function(e) {
                        this.backwardNavigationIndicator = new _o(ko.Backward, e), this.forwardNavigationIndicator = new _o(ko.Forward, e)
                    }
                }, {
                    key: "subscribeEvents",
                    value: function() {
                        var e;
                        null === (e = this.plyrContainer) || void 0 === e || e.addEventListener("keydown", this.toggleNavigationIndicatorListener)
                    }
                }, {
                    key: "unsubscribeEvents",
                    value: function() {
                        var e;
                        null === (e = this.plyrContainer) || void 0 === e || e.removeEventListener("keydown", this.toggleNavigationIndicatorListener)
                    }
                }, {
                    key: "handleBackwardNavigationIndicator",
                    value: function() {
                        var e, t, i = this;
                        window.clearTimeout(this.hideIndicatorTimer), null === (e = this.forwardNavigationIndicator) || void 0 === e || e.hide(), null === (t = this.backwardNavigationIndicator) || void 0 === t || t.show(), this.hideIndicatorTimer = window.setTimeout((function() {
                            var e;
                            return null === (e = i.backwardNavigationIndicator) || void 0 === e ? void 0 : e.hide()
                        }), this.hideIndicatorTimeoutMs)
                    }
                }, {
                    key: "handleForwardNavigationIndicator",
                    value: function() {
                        var e, t, i = this;
                        window.clearTimeout(this.hideIndicatorTimer), null === (e = this.backwardNavigationIndicator) || void 0 === e || e.hide(), null === (t = this.forwardNavigationIndicator) || void 0 === t || t.show(), this.hideIndicatorTimer = window.setTimeout((function() {
                            var e;
                            return null === (e = i.forwardNavigationIndicator) || void 0 === e ? void 0 : e.hide()
                        }), this.hideIndicatorTimeoutMs)
                    }
                }]),
                Lo = (0, T.A)((function e(t, i) {
                    (0, b.A)(this, e), this.onHeightUpdated = i;
                    var r = t.elements.controls;
                    r && (this.controlsObserver = this.observeControls(r), this.updateHeight(r))
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.controlsObserver) || void 0 === e || e.disconnect()
                    }
                }, {
                    key: "observeControls",
                    value: function(e) {
                        var t = this,
                            i = new ResizeObserver((function() {
                                return t.updateHeight(e)
                            }));
                        return i.observe(e), i
                    }
                }, {
                    key: "updateHeight",
                    value: function(e) {
                        var t = Array.from(e.querySelectorAll(".plyr__controls__item")).filter((function(e) {
                                var t = window.getComputedStyle(e);
                                return "none" !== t.display && "hidden" !== t.visibility
                            })).map((function(t) {
                                return e.clientHeight - t.offsetTop
                            })),
                            i = Math.max.apply(Math, (0, F.A)(t));
                        this.onHeightUpdated(i)
                    }
                }]),
                Ro = (0, T.A)((function e(t) {
                    (0, b.A)(this, e), this.player = t
                }), [{
                    key: "destroy",
                    value: function() {
                        this.updateStyles({
                            transform: "",
                            bottom: "",
                            skipTransition: !0
                        })
                    }
                }, {
                    key: "updateHeight",
                    value: function(e) {
                        this.updateStyles({
                            transform: "translateY(-".concat(e, "px)"),
                            bottom: "-".concat(e, "px"),
                            skipTransition: !0
                        })
                    }
                }, {
                    key: "updateStyles",
                    value: function(e) {
                        var t = this.player.elements.controls;
                        if (t) {
                            var i = t.style.transition;
                            e.skipTransition && (t.style.transition = "none"), t.style.transform = e.transform, t.style.bottom = e.bottom, e.skipTransition && (t.offsetHeight, t.style.transition = i)
                        }
                    }
                }]),
                Do = function() {
                    function e(t, i) {
                        (0, b.A)(this, e);
                        var r = i.length > 0,
                            n = t.elements.controls;
                        r && t.elements.container && n && (this.blockerElement = this.createBlockerElement(), t.elements.container.appendChild(this.blockerElement))
                    }
                    return (0, T.A)(e, [{
                        key: "destroy",
                        value: function() {
                            var e;
                            null === (e = this.blockerElement) || void 0 === e || e.remove()
                        }
                    }, {
                        key: "updateHeight",
                        value: function(e) {
                            this.blockerElement && (this.blockerElement.style.height = "".concat(e, "px"))
                        }
                    }, {
                        key: "createBlockerElement",
                        value: function() {
                            var t = document.createElement("div");
                            return t.classList.add(e.blockerClassName), t
                        }
                    }])
                }();
            (0, L.A)(Do, "blockerClassName", "video-player__controls-blocker");
            var Co = (0, T.A)((function e(t) {
                var i, r = this;
                (0, b.A)(this, e), (0, L.A)(this, "observers", []);
                var n = t.elements.settings.popup;
                if (n) {
                    var s = null === (i = t.elements.settings.buttons.speed) || void 0 === i ? void 0 : i.querySelector(".plyr__menu__value"),
                        a = [].concat((0, F.A)(Array.from(n.querySelectorAll(e.SpeedLabelsSelector))), (0, F.A)(s ? [s] : []));
                    a.forEach((function(e) {
                        return r.formatElement(e)
                    })), this.observers = a.map((function(e) {
                        return r.observeLabel(e)
                    }))
                }
            }), [{
                key: "destroy",
                value: function() {
                    this.observers.forEach((function(e) {
                        return e.disconnect()
                    })), this.observers = []
                }
            }, {
                key: "formatElement",
                value: function(e) {
                    var t = this.format(e.textContent);
                    t !== e.textContent && (e.textContent = t)
                }
            }, {
                key: "format",
                value: function(e) {
                    return e && "×" === e.slice(-1) ? "".concat(parseFloat(e), "x") : e
                }
            }, {
                key: "observeLabel",
                value: function(e) {
                    var t = this,
                        i = new MutationObserver((function() {
                            return t.formatElement(e)
                        }));
                    return i.observe(e, {
                        characterData: !1,
                        attributes: !1,
                        childList: !0,
                        subtree: !1
                    }), i
                }
            }]);
            (0, L.A)(Co, "SpeedLabelsSelector", "button[data-plyr=speed] > span");
            var Io = (0, T.A)((function e(t, i, r) {
                    var n, s, a = this;
                    (0, b.A)(this, e), (0, L.A)(this, "hideVolumeTimeoutMs", 1e3), (0, L.A)(this, "showVolumeSliderClassName", "video-player__volume--menu-open"), (0, L.A)(this, "setFocusOnContainer", (function() {
                        var e;
                        return null === (e = a.player.elements.container) || void 0 === e ? void 0 : e.focus()
                    })), this.player = t;
                    var o, l = r.includes(V.Volume),
                        c = Boolean((null === (n = i.keyboard) || void 0 === n ? void 0 : n.focused) || (null === (s = i.keyboard) || void 0 === s ? void 0 : s.global));
                    l && c && (this.player.on("volumechange", (function() {
                        return a.showVolumeOnChange()
                    })), null === (o = this.player.elements.inputs.volume) || void 0 === o || o.addEventListener("click", this.setFocusOnContainer))
                }), [{
                    key: "destroy",
                    value: function() {
                        var e;
                        null === (e = this.player.elements.inputs.volume) || void 0 === e || e.removeEventListener("click", this.setFocusOnContainer), this.clearHideTimeout()
                    }
                }, {
                    key: "clearHideTimeout",
                    value: function() {
                        void 0 !== this.hideTimeout && window.clearTimeout(this.hideTimeout), this.hideTimeout = void 0
                    }
                }, {
                    key: "showVolumeOnChange",
                    value: function() {
                        var e = this;
                        this.isMuted() || (this.isSliderVisible() && void 0 !== this.hideTimeout || !this.isSliderVisible()) && (this.clearHideTimeout(), this.hideTimeout = window.setTimeout((function() {
                            return e.hideVolumeSlider()
                        }), this.hideVolumeTimeoutMs), this.showVolumeSlider())
                    }
                }, {
                    key: "isMuted",
                    value: function() {
                        return this.player.muted
                    }
                }, {
                    key: "isSliderVisible",
                    value: function() {
                        var e, t = this.player.elements.inputs.volume;
                        return Boolean(t && "visible" === window.getComputedStyle(t).visibility || (null === (e = this.player.elements.container) || void 0 === e ? void 0 : e.classList.contains(this.showVolumeSliderClassName)))
                    }
                }, {
                    key: "showVolumeSlider",
                    value: function() {
                        var e, t;
                        this.isSliderVisible() || (this.player.toggleControls(!1), null === (e = this.player.elements.buttons.mute) || void 0 === e || e.focus(), null === (t = this.player.elements.container) || void 0 === t || t.classList.add(this.showVolumeSliderClassName))
                    }
                }, {
                    key: "hideVolumeSlider",
                    value: function() {
                        var e;
                        this.clearHideTimeout(), this.isSliderVisible() && (this.setFocusOnContainer(), null === (e = this.player.elements.container) || void 0 === e || e.classList.remove(this.showVolumeSliderClassName))
                    }
                }]),
                Po = (0, T.A)((function e(t, i, r, n, s) {
                    var a = this;
                    (0, b.A)(this, e), (0, L.A)(this, "unsubscribeFocusOnPlyrContainer", (function() {
                        var e = a.getPlayButtons();
                        null == e || e.forEach((function(e) {
                            return e.removeEventListener("click", a.focusOnPlyrContainerListener)
                        }))
                    })), (0, L.A)(this, "focusOnPlyrContainerListener", (function() {
                        var e;
                        return null === (e = a.player.elements.container) || void 0 === e ? void 0 : e.focus()
                    })), this.player = t, this.plyrOptions = i, this.videoPlayerControls = r, this.videoPlayerElement = n, this.isExternalProvider = s, this.icons = new wo(n, r), this.plyrLoadingIndicator = new to(t, s, r), this.volumeSliderToggler = new Io(t, i, r), this.speedLabelsFormatter = new Co(t), this.controlsInteractionBlocker = new Do(t, r), this.controlsHideOffsetSetter = new Ro(t), this.controlsHeightObserver = new Lo(t, (function(e) {
                        var t, i;
                        null === (t = a.controlsInteractionBlocker) || void 0 === t || t.updateHeight(e), null === (i = a.controlsHideOffsetSetter) || void 0 === i || i.updateHeight(e)
                    })), this.clickToPlay = new Eo(t, i), this.vimeoPlayButton = new Va(t, n), t.once("ready", (function() {
                        a.movePlayButtonAsTheFirstUIElement(), a.togglePlayButtonIcon(), a.navigationIndicators = new So(t, r, i)
                    }))
                }), [{
                    key: "destroy",
                    value: function() {
                        var e, t, i, r, n, s, a, o, l;
                        null === (e = this.clickToPlay) || void 0 === e || e.destroy(), null === (t = this.controlsInteractionBlocker) || void 0 === t || t.destroy(), null === (i = this.controlsHideOffsetSetter) || void 0 === i || i.destroy(), null === (r = this.controlsHeightObserver) || void 0 === r || r.destroy(), null === (n = this.icons) || void 0 === n || n.destroy(), null === (s = this.plyrLoadingIndicator) || void 0 === s || s.destroy(), null === (a = this.volumeSliderToggler) || void 0 === a || a.destroy(), null === (o = this.speedLabelsFormatter) || void 0 === o || o.destroy(), null === (l = this.navigationIndicators) || void 0 === l || l.destroy(), this.vimeoPlayButton.destroy(), this.unsubscribeFocusOnPlyrContainer()
                    }
                }, {
                    key: "movePlayButtonAsTheFirstUIElement",
                    value: function() {
                        var e = this.getPlayButtons(),
                            t = null == e ? void 0 : e.find((function(e) {
                                return e.classList.contains("plyr__control--overlaid")
                            })),
                            i = this.player.elements.container,
                            r = this.player.elements.controls;
                        t && (null == i || i.insertBefore(t, r))
                    }
                }, {
                    key: "togglePlayButtonIcon",
                    value: function() {
                        var e = this,
                            t = this.getPlayButtons();
                        if (this.player && t) {
                            var i = function(e) {
                                return t.forEach((function(t) {
                                    return function(e, t) {
                                        var i = e.querySelector("use");
                                        i && i.setAttribute("href", "#video-player__icon-".concat(t))
                                    }(t, e)
                                }))
                            };
                            this.player.on("play", (function() {
                                return i("pause")
                            })), this.player.on("pause", (function() {
                                return i("play")
                            })), this.player.on("seeking", (function() {
                                return e.player.playing ? i("pause") : i("play")
                            })), this.player.on("ended", (function() {
                                return i("replay")
                            })), this.subscribeFocusOnPlyrContainer(t)
                        }
                    }
                }, {
                    key: "getPlayButtons",
                    value: function() {
                        var e, t = null === (e = this.player) || void 0 === e ? void 0 : e.elements.buttons.play;
                        return t ? Array.isArray(t) ? t : [t] : null
                    }
                }, {
                    key: "subscribeFocusOnPlyrContainer",
                    value: function(e) {
                        var t = this;
                        e.forEach((function(e) {
                            return e.addEventListener("click", t.focusOnPlyrContainerListener)
                        }))
                    }
                }]);
            var xo = {
                randomUUID: "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto)
            };
            let Oo;
            const Mo = new Uint8Array(16);

            function No() {
                if (!Oo && (Oo = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Oo)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                return Oo(Mo)
            }
            const Fo = [];
            for (let e = 0; e < 256; ++e) Fo.push((e + 256).toString(16).slice(1));

            function Bo(e, t = 0) {
                return Fo[e[t + 0]] + Fo[e[t + 1]] + Fo[e[t + 2]] + Fo[e[t + 3]] + "-" + Fo[e[t + 4]] + Fo[e[t + 5]] + "-" + Fo[e[t + 6]] + Fo[e[t + 7]] + "-" + Fo[e[t + 8]] + Fo[e[t + 9]] + "-" + Fo[e[t + 10]] + Fo[e[t + 11]] + Fo[e[t + 12]] + Fo[e[t + 13]] + Fo[e[t + 14]] + Fo[e[t + 15]]
            }
            var Uo = function(e, t, i) {
                    if (xo.randomUUID && !t && !e) return xo.randomUUID();
                    const r = (e = e || {}).random || (e.rng || No)();
                    if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
                        i = i || 0;
                        for (let e = 0; e < 16; ++e) t[i + e] = r[e];
                        return t
                    }
                    return Bo(r)
                },
                $o = function() {
                    function e() {
                        (0, b.A)(this, e)
                    }
                    return (0, T.A)(e, null, [{
                        key: "getSessionId",
                        value: function() {
                            if (!e.sessionId) {
                                var t, i = To.getOptions();
                                e.sessionId = null !== (t = null == i ? void 0 : i.sessionId) && void 0 !== t ? t : e.createSessionId()
                            }
                            return e.sessionId
                        }
                    }, {
                        key: "createSessionId",
                        value: function() {
                            var e = Uo();
                            return To.setOption("sessionId", e), e
                        }
                    }])
                }();

            function Ho(e, t) {
                var i = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t && (r = r.filter((function(t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    }))), i.push.apply(i, r)
                }
                return i
            }
            var jo = function() {
                function e(t, i) {
                    var r, n = this;
                    (0, b.A)(this, e), (0, L.A)(this, "thumbnail", null), (0, L.A)(this, "ui", null), (0, L.A)(this, "playbackDriver", null), (0, L.A)(this, "embedAspectRatio", null), (0, L.A)(this, "videoPlayerErrorHandler", null), (0, L.A)(this, "videoProvider", null), (0, L.A)(this, "loadingScreen", null), (0, L.A)(this, "paywall", null), this.videoPlayerElement = t;
                    var s = Date.now(),
                        a = $o.getSessionId(),
                        o = i.environment,
                        l = i.src,
                        c = i.options,
                        d = i.thumbnailSrc,
                        u = i.events;
                    this.videoPlayerElement.videoPlayer = this, this.breakpointsSetter = new mo(this.videoPlayerElement, (function() {
                        var e, t;
                        return null !== (e = null === (t = n.player) || void 0 === t ? void 0 : t.elements.container) && void 0 !== e ? e : null
                    }));
                    var h = this.createVideoElement(t, c),
                        f = null !== (r = null == c ? void 0 : c.controls) && void 0 !== r ? r : e.DefaultControls,
                        m = this.createPlyrOptions(function(e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var i = null != arguments[t] ? arguments[t] : {};
                                t % 2 ? Ho(Object(i), !0).forEach((function(t) {
                                    (0, L.A)(e, t, i[t])
                                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Ho(Object(i)).forEach((function(t) {
                                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                                }))
                            }
                            return e
                        }({
                            controls: f
                        }, c));
                    this.player = new(j())(h, m);
                    try {
                        if (!o) throw new S(p, "You must provide 'environment' in the configuration.");
                        if (!l || 0 === l.trim().length) throw new S(p, "You must provide 'src' in the configuration.");
                        this.videoPlayerErrorHandler = new Ia(this.player, this.isExternalProvider), this.videoProvider = Ga(l, h), this.playbackDriver = function(e, t) {
                            switch (e) {
                                case J.HlsJs:
                                    return new Ua(t);
                                case J.NativeHls:
                                    return new $a(t);
                                case J.Vimeo:
                                case J.YouTube:
                                    return new Ha(e, t)
                            }
                        }(this.videoProvider, {
                            videoElement: h,
                            src: l,
                            thumbnailSrc: d,
                            player: this.player,
                            errorHandler: this.videoPlayerErrorHandler,
                            onUnauthorizedError: null != c && c.paywall ? function() {
                                return n.showPaywall(null == c ? void 0 : c.paywall, u)
                            } : null
                        }), this.createMuxClient(i, s, a), this.embedAspectRatio = new Y(t, this.player, this.isExternalProvider), this.thumbnail = new po(this.player, null == c ? void 0 : c.thumbnailFocalPoint), this.ui = new Po(this.player, m, q[f], t, this.isExternalProvider), this.isLoading = !0, this.player.once("ready", (function() {
                            n.setDefaultSpeed(m)
                        })), this.subscribeEvents(u), this.onReady().then((function() {
                            n.isLoading = !1
                        }))
                    } catch (e) {
                        this.videoPlayerErrorHandler || (this.videoPlayerErrorHandler = new Ia(this.player, this.isExternalProvider)), this.videoPlayerErrorHandler.handleError(e)
                    }
                }
                return (0, T.A)(e, [{
                    key: "speed",
                    set: function(e) {
                        this.player && (this.player.speed = e)
                    }
                }, {
                    key: "thumbnailFocalPoint",
                    set: function(e) {
                        this.thumbnail && this.thumbnail.setFocalPoint(e)
                    }
                }, {
                    key: "isLoading",
                    set: function(e) {
                        var t;
                        e ? null === this.loadingScreen && (this.loadingScreen = this.player ? new io(this.player) : null) : (null === (t = this.loadingScreen) || void 0 === t || t.destroy(), this.loadingScreen = null)
                    }
                }, {
                    key: "currentTime",
                    get: function() {
                        var e;
                        return (null === (e = this.player) || void 0 === e ? void 0 : e.currentTime) || 0
                    },
                    set: function(e) {
                        this.player && (this.player.currentTime = e)
                    }
                }, {
                    key: "duration",
                    get: function() {
                        var e;
                        return (null === (e = this.player) || void 0 === e ? void 0 : e.duration) || 0
                    }
                }, {
                    key: "isMuted",
                    get: function() {
                        var e;
                        return (null === (e = this.player) || void 0 === e ? void 0 : e.muted) || !1
                    }
                }, {
                    key: "volume",
                    get: function() {
                        var e;
                        return (null === (e = this.player) || void 0 === e ? void 0 : e.volume) || 0
                    }
                }, {
                    key: "isPlaying",
                    get: function() {
                        var e;
                        return (null === (e = this.player) || void 0 === e ? void 0 : e.playing) || !1
                    }
                }, {
                    key: "isPaused",
                    get: function() {
                        var e;
                        return (null === (e = this.player) || void 0 === e ? void 0 : e.paused) || !1
                    }
                }, {
                    key: "isEnded",
                    get: function() {
                        var e;
                        return (null === (e = this.player) || void 0 === e ? void 0 : e.ended) || !1
                    }
                }, {
                    key: "isExternalProvider",
                    get: function() {
                        return !!this.videoProvider && Object.values(Q).includes(this.videoProvider)
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        var e, t, i, r, n, s, a, o, l = this;
                        null === (e = this.ui) || void 0 === e || e.destroy(), this.ui = null, null === (t = this.playbackDriver) || void 0 === t || t.destroy(), this.playbackDriver = null, null === (i = this.thumbnail) || void 0 === i || i.destroy(), null === (r = this.paywall) || void 0 === r || r.destroy(), null === (n = this.embedAspectRatio) || void 0 === n || n.destroy(), null === (s = this.videoPlayerErrorHandler) || void 0 === s || s.destroy(), this.isLoading = !1, null === (a = this.player) || void 0 === a || a.destroy((function() {
                            this.remove(), l.player = null
                        })), null === (o = this.breakpointsSetter) || void 0 === o || o.destroy(), this.breakpointsSetter = null, this.videoPlayerElement.videoPlayer = null
                    }
                }, {
                    key: "onReady",
                    value: function() {
                        var e = (0, B.A)($().mark((function e() {
                            var t, i, r;
                            return $().wrap((function(e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        if (i = this.player) {
                                            e.next = 3;
                                            break
                                        }
                                        return e.abrupt("return", Promise.reject());
                                    case 3:
                                        return r = function(e) {
                                            return new Promise((function(t) {
                                                i.once(e, (function() {
                                                    return t()
                                                }))
                                            }))
                                        }, e.next = 6, r("ready");
                                    case 6:
                                        return e.next = 8, null === (t = this.playbackDriver) || void 0 === t ? void 0 : t.onReady();
                                    case 8:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, this)
                        })));
                        return function() {
                            return e.apply(this, arguments)
                        }
                    }()
                }, {
                    key: "createVideoElement",
                    value: function(e, t) {
                        var i = document.createElement("video");
                        return i.setAttribute("playsinline", ""), i.setAttribute("webkit-playsinline", ""), null != t && t.loop && i.setAttribute("loop", ""), null != t && t.muted && i.setAttribute("muted", ""), null != t && t.autoPlay && i.setAttribute("autoplay", ""), e.appendChild(i), i
                    }
                }, {
                    key: "createPlyrOptions",
                    value: function(e) {
                        var t, i, r, n, s, a, o, l, c = null != e && e.controls ? this.mapToPlyrControlNames(q[e.controls]) : [],
                            d = [K],
                            u = {
                                enabled: null === (t = null == e ? void 0 : e.storage) || void 0 === t || t,
                                key: To.StorageKey
                            };
                        return {
                            speed: {
                                selected: this.getSelectedSpeed(u.enabled, null == e ? void 0 : e.speed),
                                options: (0, F.A)(W)
                            },
                            volume: null !== (i = null == e ? void 0 : e.volume) && void 0 !== i ? i : 1,
                            muted: null !== (r = null == e ? void 0 : e.muted) && void 0 !== r && r,
                            clickToPlay: null === (n = null == e ? void 0 : e.clickToPlay) || void 0 === n || n,
                            autoplay: null !== (s = null == e ? void 0 : e.autoPlay) && void 0 !== s && s,
                            loop: {
                                active: null !== (a = null == e ? void 0 : e.loop) && void 0 !== a && a
                            },
                            fullscreen: {
                                enabled: null === (o = null == e ? void 0 : e.fullscreen) || void 0 === o || o,
                                iosNative: !0
                            },
                            controls: c,
                            i18n: Za(null == e ? void 0 : e.language),
                            keyboard: {
                                focused: null === (l = null == e ? void 0 : e.keyboard) || void 0 === l || l
                            },
                            captions: {
                                active: !1,
                                update: !1
                            },
                            storage: u,
                            loadSprite: !1,
                            iconPrefix: "video-player__icon",
                            blankVideo: "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAOEbW9vdgAAAGxtdmhkAAAAANOs4tLTrOLSAAAD6AAAA+gAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAABhpb2RzAAAAABCAgIAHAE/////+/wAAAoh0cmFrAAAAXHRraGQAAAAD06zi0tOs4tIAAAABAAAAAAAAA+gAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAACAAAAAUAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPoAACMoAABAAAAAAIAbWRpYQAAACBtZGhkAAAAANOs4tLTrOLSAAFfkAABX5BVxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAABq21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAWtzdGJsAAAAl3N0c2QAAAAAAAAAAQAAAIdhdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAACAAFABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAAMWF2Y0MBTUAo/+EAGWdNQCjspL881AQEBQAAAwABAAK/IA8YMZYBAAVo74GfIAAAABhzdHRzAAAAAAAAAAEAAAAFAABGUAAAABRzdHNzAAAAAAAAAAEAAAABAAAAOGN0dHMAAAAAAAAABQAAAAEAAIygAAAAAQABX5AAAAABAACMoAAAAAEAAAAAAAAAAQAARlAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAKHN0c3oAAAAAAAAAAAAAAAUAAAMQAAAADAAAAAsAAAALAAAACwAAACRzdGNvAAAAAAAAAAUAAAO0AAAGxAAABtAAAAbbAAAG5gAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC41IDIwMTYwMjExMDAAAAAIZnJlZQAAA0VtZGF0AAAC8AYF///s3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9NTAga2V5aW50X21pbj01IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9MTAgcmM9Y3JmIG1idHJlZT0xIGNyZj0xLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAGGWIhAH/+n/CVf/Y9kSiv//ffLnuYgWj/wAAAAhBmiQYv/7a4AAAAAdBnkJC/xXRAAAABwGeYUX/FdAAAAAHAZ5jRf8V0Q==",
                            settings: d,
                            vimeo: {
                                controls: !0
                            }
                        }
                    }
                }, {
                    key: "createMuxClient",
                    value: function(e, t, i) {
                        var r = e.environment,
                            n = e.src,
                            s = e.options,
                            a = e.context;
                        if (null == s || !s.performanceAnalytics || this.isExternalProvider || !this.playbackDriver) return null;
                        if (!a) throw new S(p, "You must provide 'context' in the configuration.");
                        return new oo(this.player, {
                            environment: r,
                            src: n,
                            videoPlayerContext: a,
                            playerInitTime: t,
                            playbackDriver: this.playbackDriver,
                            sessionId: i
                        })
                    }
                }, {
                    key: "showPaywall",
                    value: function(e, t) {
                        if (this.player && e) {
                            this.createPaywall({
                                onCtaClick: function() {
                                    var i;
                                    null == t || null === (i = t.onPaywallCtaClick) || void 0 === i || i.call(t), null == e || e.onCtaClick()
                                }
                            }), this.isLoading = !1
                        }
                    }
                }, {
                    key: "createPaywall",
                    value: function(e) {
                        this.player && (this.paywall = new ho(this.player, this.videoPlayerElement, e))
                    }
                }, {
                    key: "getSelectedSpeed",
                    value: function(t, i) {
                        if (t) {
                            var r, n = To.getOptions(),
                                s = n && Number(n.speed) && null !== (r = n.speed) && void 0 !== r ? r : null;
                            if (s) return s
                        }
                        return null != i ? i : e.DefaultVideoPlayerSpeed
                    }
                }, {
                    key: "mapToPlyrControlNames",
                    value: function(e) {
                        var t = new Map([
                                [V.Play, [G.PlayLarge]],
                                [V.Time, [G.CurrentTime, G.Duration]]
                            ]),
                            i = Object.values(G);
                        return e.flatMap((function(e) {
                            var r, n;
                            return null !== (r = null !== (n = t.get(e)) && void 0 !== n ? n : i.find((function(t) {
                                return t === e
                            }))) && void 0 !== r ? r : []
                        }))
                    }
                }, {
                    key: "setDefaultSpeed",
                    value: function(e) {
                        var t = this;
                        this.player && this.player.once("canplay", (function() {
                            var i, r = null === (i = e.speed) || void 0 === i ? void 0 : i.selected;
                            t.player && r && (t.player.speed = r)
                        }))
                    }
                }, {
                    key: "subscribeEvents",
                    value: function(e) {
                        if (this.player) {
                            var t = function(e) {
                                return {
                                    onReady: function() {
                                        var t;
                                        return null == e || null === (t = e.onReady) || void 0 === t ? void 0 : t.call(e)
                                    },
                                    onPlay: function(t) {
                                        var i;
                                        return null == e || null === (i = e.onPlay) || void 0 === i ? void 0 : i.call(e, go(t), yo(t))
                                    },
                                    onPlaying: function(t) {
                                        var i;
                                        return null == e || null === (i = e.onPlaying) || void 0 === i ? void 0 : i.call(e, go(t), yo(t))
                                    },
                                    onTimeUpdate: function(t) {
                                        var i;
                                        return null == e || null === (i = e.onTimeUpdate) || void 0 === i ? void 0 : i.call(e, go(t), yo(t))
                                    },
                                    onPause: function(t) {
                                        var i;
                                        return null == e || null === (i = e.onPause) || void 0 === i ? void 0 : i.call(e, go(t), yo(t))
                                    },
                                    onEnded: function(t) {
                                        var i;
                                        return null == e || null === (i = e.onEnd) || void 0 === i ? void 0 : i.call(e, go(t), yo(t))
                                    },
                                    onError: function(t) {
                                        var i, r = t.detail.plyr;
                                        null == e || null === (i = e.onError) || void 0 === i || i.call(e, S.fromPlayerMedia(r.media))
                                    },
                                    onSeeked: function(t) {
                                        var i;
                                        return null == e || null === (i = e.onSeek) || void 0 === i ? void 0 : i.call(e, go(t), yo(t))
                                    },
                                    onRateChange: function(t) {
                                        var i, r = t.detail.plyr;
                                        null == e || null === (i = e.onSpeedChange) || void 0 === i || i.call(e, r.speed)
                                    },
                                    onVolumeChange: function(t) {
                                        var i, r = t.detail.plyr;
                                        null == e || null === (i = e.onVolumeChange) || void 0 === i || i.call(e, r.volume, r.muted)
                                    },
                                    onQualityChange: function(t) {
                                        var i, r = t.detail.plyr;
                                        null == e || null === (i = e.onQualityChange) || void 0 === i || i.call(e, r.quality)
                                    },
                                    onEnterFullscreen: function() {
                                        var t;
                                        return null == e || null === (t = e.onFullscreenEnter) || void 0 === t ? void 0 : t.call(e)
                                    },
                                    onExitFullscreen: function() {
                                        var t;
                                        return null == e || null === (t = e.onFullscreenExit) || void 0 === t ? void 0 : t.call(e)
                                    }
                                }
                            }(e);
                            this.player.on("ready", t.onReady), this.player.on("play", t.onPlay), this.player.on("playing", t.onPlaying), this.player.on("timeupdate", t.onTimeUpdate), this.player.on("pause", t.onPause), this.player.on("ended", t.onEnded), this.player.on("error", t.onError), this.player.on("seeked", t.onSeeked), this.player.on("ratechange", t.onRateChange), this.player.on("volumechange", t.onVolumeChange), this.player.on("qualitychange", t.onQualityChange), this.player.on("enterfullscreen", t.onEnterFullscreen), this.player.on("exitfullscreen", t.onExitFullscreen)
                        }
                    }
                }])
            }();
            (0, L.A)(jo, "DefaultControls", c.Full), (0, L.A)(jo, "DefaultVideoPlayerSpeed", 1)
        },
        72877: function(e) {
            var t = function(e) {
                "use strict";
                var t, i = Object.prototype,
                    r = i.hasOwnProperty,
                    n = Object.defineProperty || function(e, t, i) {
                        e[t] = i.value
                    },
                    s = "function" == typeof Symbol ? Symbol : {},
                    a = s.iterator || "@@iterator",
                    o = s.asyncIterator || "@@asyncIterator",
                    l = s.toStringTag || "@@toStringTag";

                function c(e, t, i) {
                    return Object.defineProperty(e, t, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    c({}, "")
                } catch (e) {
                    c = function(e, t, i) {
                        return e[t] = i
                    }
                }

                function d(e, t, i, r) {
                    var s = t && t.prototype instanceof y ? t : y,
                        a = Object.create(s.prototype),
                        o = new C(r || []);
                    return n(a, "_invoke", {
                        value: S(e, i, o)
                    }), a
                }

                function u(e, t, i) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, i)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                e.wrap = d;
                var h = "suspendedStart",
                    f = "suspendedYield",
                    m = "executing",
                    p = "completed",
                    g = {};

                function y() {}

                function v() {}

                function b() {}
                var T = {};
                c(T, a, (function() {
                    return this
                }));
                var E = Object.getPrototypeOf,
                    A = E && E(E(I([])));
                A && A !== i && r.call(A, a) && (T = A);
                var w = b.prototype = y.prototype = Object.create(T);

                function _(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        c(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function k(e, t) {
                    function i(n, s, a, o) {
                        var l = u(e[n], e, s);
                        if ("throw" !== l.type) {
                            var c = l.arg,
                                d = c.value;
                            return d && "object" == typeof d && r.call(d, "__await") ? t.resolve(d.__await).then((function(e) {
                                i("next", e, a, o)
                            }), (function(e) {
                                i("throw", e, a, o)
                            })) : t.resolve(d).then((function(e) {
                                c.value = e, a(c)
                            }), (function(e) {
                                return i("throw", e, a, o)
                            }))
                        }
                        o(l.arg)
                    }
                    var s;
                    n(this, "_invoke", {
                        value: function(e, r) {
                            function n() {
                                return new t((function(t, n) {
                                    i(e, r, t, n)
                                }))
                            }
                            return s = s ? s.then(n, n) : n()
                        }
                    })
                }

                function S(e, i, r) {
                    var n = h;
                    return function(s, a) {
                        if (n === m) throw new Error("Generator is already running");
                        if (n === p) {
                            if ("throw" === s) throw a;
                            return {
                                value: t,
                                done: !0
                            }
                        }
                        for (r.method = s, r.arg = a;;) {
                            var o = r.delegate;
                            if (o) {
                                var l = L(o, r);
                                if (l) {
                                    if (l === g) continue;
                                    return l
                                }
                            }
                            if ("next" === r.method) r.sent = r._sent = r.arg;
                            else if ("throw" === r.method) {
                                if (n === h) throw n = p, r.arg;
                                r.dispatchException(r.arg)
                            } else "return" === r.method && r.abrupt("return", r.arg);
                            n = m;
                            var c = u(e, i, r);
                            if ("normal" === c.type) {
                                if (n = r.done ? p : f, c.arg === g) continue;
                                return {
                                    value: c.arg,
                                    done: r.done
                                }
                            }
                            "throw" === c.type && (n = p, r.method = "throw", r.arg = c.arg)
                        }
                    }
                }

                function L(e, i) {
                    var r = i.method,
                        n = e.iterator[r];
                    if (n === t) return i.delegate = null, "throw" === r && e.iterator.return && (i.method = "return", i.arg = t, L(e, i), "throw" === i.method) || "return" !== r && (i.method = "throw", i.arg = new TypeError("The iterator does not provide a '" + r + "' method")), g;
                    var s = u(n, e.iterator, i.arg);
                    if ("throw" === s.type) return i.method = "throw", i.arg = s.arg, i.delegate = null, g;
                    var a = s.arg;
                    return a ? a.done ? (i[e.resultName] = a.value, i.next = e.nextLoc, "return" !== i.method && (i.method = "next", i.arg = t), i.delegate = null, g) : a : (i.method = "throw", i.arg = new TypeError("iterator result is not an object"), i.delegate = null, g)
                }

                function R(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function D(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function C(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(R, this), this.reset(!0)
                }

                function I(e) {
                    if (null != e) {
                        var i = e[a];
                        if (i) return i.call(e);
                        if ("function" == typeof e.next) return e;
                        if (!isNaN(e.length)) {
                            var n = -1,
                                s = function i() {
                                    for (; ++n < e.length;)
                                        if (r.call(e, n)) return i.value = e[n], i.done = !1, i;
                                    return i.value = t, i.done = !0, i
                                };
                            return s.next = s
                        }
                    }
                    throw new TypeError(typeof e + " is not iterable")
                }
                return v.prototype = b, n(w, "constructor", {
                    value: b,
                    configurable: !0
                }), n(b, "constructor", {
                    value: v,
                    configurable: !0
                }), v.displayName = c(b, l, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                }, e.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, b) : (e.__proto__ = b, c(e, l, "GeneratorFunction")), e.prototype = Object.create(w), e
                }, e.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, _(k.prototype), c(k.prototype, o, (function() {
                    return this
                })), e.AsyncIterator = k, e.async = function(t, i, r, n, s) {
                    void 0 === s && (s = Promise);
                    var a = new k(d(t, i, r, n), s);
                    return e.isGeneratorFunction(i) ? a : a.next().then((function(e) {
                        return e.done ? e.value : a.next()
                    }))
                }, _(w), c(w, l, "Generator"), c(w, a, (function() {
                    return this
                })), c(w, "toString", (function() {
                    return "[object Generator]"
                })), e.keys = function(e) {
                    var t = Object(e),
                        i = [];
                    for (var r in t) i.push(r);
                    return i.reverse(),
                        function e() {
                            for (; i.length;) {
                                var r = i.pop();
                                if (r in t) return e.value = r, e.done = !1, e
                            }
                            return e.done = !0, e
                        }
                }, e.values = I, C.prototype = {
                    constructor: C,
                    reset: function(e) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(D), !e)
                            for (var i in this) "t" === i.charAt(0) && r.call(this, i) && !isNaN(+i.slice(1)) && (this[i] = t)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(e) {
                        if (this.done) throw e;
                        var i = this;

                        function n(r, n) {
                            return o.type = "throw", o.arg = e, i.next = r, n && (i.method = "next", i.arg = t), !!n
                        }
                        for (var s = this.tryEntries.length - 1; s >= 0; --s) {
                            var a = this.tryEntries[s],
                                o = a.completion;
                            if ("root" === a.tryLoc) return n("end");
                            if (a.tryLoc <= this.prev) {
                                var l = r.call(a, "catchLoc"),
                                    c = r.call(a, "finallyLoc");
                                if (l && c) {
                                    if (this.prev < a.catchLoc) return n(a.catchLoc, !0);
                                    if (this.prev < a.finallyLoc) return n(a.finallyLoc)
                                } else if (l) {
                                    if (this.prev < a.catchLoc) return n(a.catchLoc, !0)
                                } else {
                                    if (!c) throw new Error("try statement without catch or finally");
                                    if (this.prev < a.finallyLoc) return n(a.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var n = this.tryEntries[i];
                            if (n.tryLoc <= this.prev && r.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                                var s = n;
                                break
                            }
                        }
                        s && ("break" === e || "continue" === e) && s.tryLoc <= t && t <= s.finallyLoc && (s = null);
                        var a = s ? s.completion : {};
                        return a.type = e, a.arg = t, s ? (this.method = "next", this.next = s.finallyLoc, g) : this.complete(a)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var i = this.tryEntries[t];
                            if (i.finallyLoc === e) return this.complete(i.completion, i.afterLoc), D(i), g
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var i = this.tryEntries[t];
                            if (i.tryLoc === e) {
                                var r = i.completion;
                                if ("throw" === r.type) {
                                    var n = r.arg;
                                    D(i)
                                }
                                return n
                            }
                        }
                        throw new Error("illegal catch attempt")
                    },
                    delegateYield: function(e, i, r) {
                        return this.delegate = {
                            iterator: I(e),
                            resultName: i,
                            nextLoc: r
                        }, "next" === this.method && (this.arg = t), g
                    }
                }, e
            }(e.exports);
            try {
                regeneratorRuntime = t
            } catch (e) {
                "object" == typeof globalThis ? globalThis.regeneratorRuntime = t : Function("r", "regeneratorRuntime = r")(t)
            }
        },
        42770: function() {
            ! function() {
                if ("undefined" != typeof window) try {
                    var e = new window.CustomEvent("test", {
                        cancelable: !0
                    });
                    if (e.preventDefault(), !0 !== e.defaultPrevented) throw new Error("Could not prevent default")
                } catch (e) {
                    var t = function(e, t) {
                        var i, r;
                        return (t = t || {}).bubbles = !!t.bubbles, t.cancelable = !!t.cancelable, (i = document.createEvent("CustomEvent")).initCustomEvent(e, t.bubbles, t.cancelable, t.detail), r = i.preventDefault, i.preventDefault = function() {
                            r.call(this);
                            try {
                                Object.defineProperty(this, "defaultPrevented", {
                                    get: function() {
                                        return !0
                                    }
                                })
                            } catch (e) {
                                this.defaultPrevented = !0
                            }
                        }, i
                    };
                    t.prototype = window.Event.prototype, window.CustomEvent = t
                }
            }()
        },
        21624: function(e) {
            var t;
            t = function() {
                return function() {
                    var e = {
                            80: function(e, t, i) {
                                e.exports = i(728).default
                            },
                            728: function(e, t, i) {
                                "use strict";
                                i.d(t, {
                                    default: function() {
                                        return Pt
                                    }
                                });
                                var r = i(48),
                                    n = i.n(r),
                                    s = function() {
                                        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                                            var t = 16 * Math.random() | 0;
                                            return ("x" === e ? t : 3 & t | 8).toString(16)
                                        }))
                                    },
                                    a = function() {
                                        return ("000000" + (Math.random() * Math.pow(36, 6) | 0).toString(36)).slice(-6)
                                    },
                                    o = function(e) {
                                        var t, i;
                                        if (e && void 0 !== e.nodeName) return e.muxId || (e.muxId = a()), e.muxId;
                                        try {
                                            i = document.querySelector(e)
                                        } catch (e) {}
                                        return i && !i.muxId && (i.muxId = e), (null === (t = i) || void 0 === t ? void 0 : t.muxId) || e
                                    },
                                    l = function(e) {
                                        var t;
                                        e && void 0 !== e.nodeName ? e = o(t = e) : t = document.querySelector(e);
                                        var i = t && t.nodeName ? t.nodeName.toLowerCase() : "";
                                        return [t, e, i]
                                    },
                                    c = i(640),
                                    d = i.n(c),
                                    u = d().methodFactory;
                                d().methodFactory = function(e, t, i) {
                                    var r = u(e, t, i);
                                    return function() {
                                        for (var e = ["[mux]"], t = 0; t < arguments.length; t++) e.push(arguments[t]);
                                        r.apply(void 0, e)
                                    }
                                }, d().setLevel(d().getLevel());
                                var h = d();

                                function f() {
                                    return "1" === (n().doNotTrack || n().navigator && n().navigator.doNotTrack)
                                }
                                var m = {
                                        now: function() {
                                            var e = n().performance,
                                                t = e && e.timing,
                                                i = t && t.navigationStart,
                                                r = "number" == typeof i && "function" == typeof e.now ? i + e.now() : Date.now();
                                            return Math.round(r)
                                        }
                                    },
                                    p = function(e) {
                                        return g(e)[0]
                                    },
                                    g = function(e) {
                                        if ("string" != typeof e || "" === e) return ["localhost"];
                                        var t, i = (e.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/) || [])[4];
                                        return i && (t = (i.match(/[^\.]+\.[^\.]+$/) || [])[0]), [i, t]
                                    },
                                    y = function() {
                                        var e = n().performance;
                                        return void 0 !== (e && e.timing)
                                    },
                                    v = function() {
                                        var e = n().performance,
                                            t = e && e.timing;
                                        return t && t.domContentLoadedEventEnd
                                    },
                                    b = function() {
                                        var e = n().performance,
                                            t = e && e.timing;
                                        return t && t.navigationStart
                                    };

                                function T(e, t, i) {
                                    i = void 0 === i ? 1 : i, e[t] = e[t] || 0, e[t] += i
                                }
                                var E = ["x-request-id", "cf-ray", "x-amz-cf-id", "x-akamai-request-id"],
                                    A = ["x-cdn", "content-type"].concat(E);

                                function w(e) {
                                    var t = {};
                                    return (e = e || "").trim().split(/[\r\n]+/).forEach((function(e) {
                                        if (e) {
                                            var i = e.split(": "),
                                                r = i.shift();
                                            r && (A.indexOf(r.toLowerCase()) >= 0 || 0 === r.toLowerCase().indexOf("x-litix-")) && (t[r] = i.join(": "))
                                        }
                                    })), t
                                }

                                function _(e) {
                                    if (e) {
                                        var t = E.find((function(t) {
                                            return void 0 !== e[t]
                                        }));
                                        return t ? e[t] : void 0
                                    }
                                }
                                var k = function(e) {
                                    var t = {};
                                    for (var i in e) {
                                        var r = e[i]; - 1 !== r["DATA-ID"].search("io.litix.data.") && (t[r["DATA-ID"].replace("io.litix.data.", "")] = r.VALUE)
                                    }
                                    return t
                                };

                                function S(e, t) {
                                    var i = Object.keys(e);
                                    if (Object.getOwnPropertySymbols) {
                                        var r = Object.getOwnPropertySymbols(e);
                                        t && (r = r.filter((function(t) {
                                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                                        }))), i.push.apply(i, r)
                                    }
                                    return i
                                }

                                function L(e) {
                                    for (var t = 1; t < arguments.length; t++) {
                                        var i = null != arguments[t] ? arguments[t] : {};
                                        t % 2 ? S(Object(i), !0).forEach((function(t) {
                                            R(e, t, i[t])
                                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : S(Object(i)).forEach((function(t) {
                                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                                        }))
                                    }
                                    return e
                                }

                                function R(e, t, i) {
                                    return t in e ? Object.defineProperty(e, t, {
                                        value: i,
                                        enumerable: !0,
                                        configurable: !0,
                                        writable: !0
                                    }) : e[t] = i, e
                                }
                                var D = function(e) {
                                        if (!e) return {};
                                        var t = b(),
                                            i = e.loading,
                                            r = i ? i.start : e.trequest,
                                            n = i ? i.first : e.tfirst,
                                            s = i ? i.end : e.tload;
                                        return {
                                            bytesLoaded: e.total,
                                            requestStart: Math.round(t + r),
                                            responseStart: Math.round(t + n),
                                            responseEnd: Math.round(t + s)
                                        }
                                    },
                                    C = function(e) {
                                        if (e && "function" == typeof e.getAllResponseHeaders) return w(e.getAllResponseHeaders())
                                    };

                                function I(e, t) {
                                    var i = Object.keys(e);
                                    if (Object.getOwnPropertySymbols) {
                                        var r = Object.getOwnPropertySymbols(e);
                                        t && (r = r.filter((function(t) {
                                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                                        }))), i.push.apply(i, r)
                                    }
                                    return i
                                }

                                function P(e) {
                                    for (var t = 1; t < arguments.length; t++) {
                                        var i = null != arguments[t] ? arguments[t] : {};
                                        t % 2 ? I(Object(i), !0).forEach((function(t) {
                                            x(e, t, i[t])
                                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : I(Object(i)).forEach((function(t) {
                                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                                        }))
                                    }
                                    return e
                                }

                                function x(e, t, i) {
                                    return t in e ? Object.defineProperty(e, t, {
                                        value: i,
                                        enumerable: !0,
                                        configurable: !0,
                                        writable: !0
                                    }) : e[t] = i, e
                                }
                                var O = function(e, t) {
                                        if (!e || !e.requestEndDate) return {};
                                        var i, r = p(e.url),
                                            n = e.url,
                                            s = e.bytesLoaded,
                                            a = new Date(e.requestStartDate).getTime(),
                                            o = new Date(e.firstByteDate).getTime(),
                                            l = new Date(e.requestEndDate).getTime(),
                                            c = isNaN(e.duration) ? 0 : e.duration,
                                            d = "function" == typeof t.getMetricsFor ? t.getMetricsFor(e.mediaType).HttpList : t.getDashMetrics().getHttpRequests(e.mediaType);
                                        return d.length > 0 && (i = w(d[d.length - 1]._responseHeaders || "")), {
                                            requestStart: a,
                                            requestResponseStart: o,
                                            requestResponseEnd: l,
                                            requestBytesLoaded: s,
                                            requestResponseHeaders: i,
                                            requestMediaDuration: c,
                                            requestHostname: r,
                                            requestUrl: n,
                                            requestId: i ? _(i) : void 0
                                        }
                                    },
                                    M = function(e) {
                                        var t;
                                        return null === (t = e.match(/.*codecs\*?="(.*)"/)) || void 0 === t ? void 0 : t[1]
                                    };

                                function N(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var F = 0,
                                    B = function() {
                                        function e() {
                                            ! function(e, t) {
                                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                            }(this, e)
                                        }
                                        var t, i;
                                        return t = e, i = [{
                                            key: "on",
                                            value: function(e, t, i) {
                                                return t._eventEmitterGuid = t._eventEmitterGuid || ++F, this._listeners = this._listeners || {}, this._listeners[e] = this._listeners[e] || [], i && (t = t.bind(i)), this._listeners[e].push(t), t
                                            }
                                        }, {
                                            key: "off",
                                            value: function(e, t) {
                                                var i = this._listeners && this._listeners[e];
                                                i && i.forEach((function(e, r) {
                                                    e._eventEmitterGuid === t._eventEmitterGuid && i.splice(r, 1)
                                                }))
                                            }
                                        }, {
                                            key: "one",
                                            value: function(e, t, i) {
                                                var r = this;
                                                t._eventEmitterGuid = t._eventEmitterGuid || ++F;
                                                var n = function n() {
                                                    r.off(e, n), t.apply(i || this, arguments)
                                                };
                                                n._eventEmitterGuid = t._eventEmitterGuid, this.on(e, n)
                                            }
                                        }, {
                                            key: "emit",
                                            value: function(e, t) {
                                                var i = this;
                                                if (this._listeners) {
                                                    t = t || {};
                                                    var r = this._listeners["before*"] || [],
                                                        n = this._listeners[e] || [],
                                                        s = this._listeners["after" + e] || [],
                                                        a = function(t, r) {
                                                            (t = t.slice()).forEach((function(t) {
                                                                t.call(i, {
                                                                    type: e
                                                                }, r)
                                                            }))
                                                        };
                                                    a(r, t), a(n, t), a(s, t)
                                                }
                                            }
                                        }], i && N(t.prototype, i), Object.defineProperty(t, "prototype", {
                                            writable: !1
                                        }), e
                                    }(),
                                    U = B;

                                function $(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var H = function() {
                                    function e(t) {
                                        var i = this;
                                        ! function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                        }(this, e), this.pm = t, this._playbackHeartbeatInterval = null, this._playheadShouldBeProgressing = !1, t.on("playing", (function() {
                                            i._playheadShouldBeProgressing = !0
                                        })), t.on("play", this._startPlaybackHeartbeatInterval.bind(this)), t.on("playing", this._startPlaybackHeartbeatInterval.bind(this)), t.on("adbreakstart", this._startPlaybackHeartbeatInterval.bind(this)), t.on("adplay", this._startPlaybackHeartbeatInterval.bind(this)), t.on("adplaying", this._startPlaybackHeartbeatInterval.bind(this)), t.on("seeking", this._startPlaybackHeartbeatInterval.bind(this)), t.on("devicewake", this._startPlaybackHeartbeatInterval.bind(this)), t.on("viewstart", this._startPlaybackHeartbeatInterval.bind(this)), t.on("rebufferstart", this._startPlaybackHeartbeatInterval.bind(this)), t.on("pause", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("ended", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("viewend", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("error", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("aderror", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("adpause", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("adended", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("adbreakend", this._stopPlaybackHeartbeatInterval.bind(this)), t.on("seeked", (function() {
                                            t.data.player_is_paused ? i._stopPlaybackHeartbeatInterval() : i._startPlaybackHeartbeatInterval()
                                        })), t.on("timeupdate", (function() {
                                            null !== i._playbackHeartbeatInterval && t.emit("playbackheartbeat")
                                        })), t.on("devicesleep", (function(e, r) {
                                            null !== i._playbackHeartbeatInterval && (n().clearInterval(i._playbackHeartbeatInterval), t.emit("playbackheartbeatend", {
                                                viewer_time: r.viewer_time
                                            }), i._playbackHeartbeatInterval = null)
                                        }))
                                    }
                                    var t, i;
                                    return t = e, (i = [{
                                        key: "_startPlaybackHeartbeatInterval",
                                        value: function() {
                                            var e = this;
                                            null === this._playbackHeartbeatInterval && (this.pm.emit("playbackheartbeat"), this._playbackHeartbeatInterval = n().setInterval((function() {
                                                e.pm.emit("playbackheartbeat")
                                            }), this.pm.playbackHeartbeatTime))
                                        }
                                    }, {
                                        key: "_stopPlaybackHeartbeatInterval",
                                        value: function() {
                                            this._playheadShouldBeProgressing = !1, null !== this._playbackHeartbeatInterval && (n().clearInterval(this._playbackHeartbeatInterval), this.pm.emit("playbackheartbeatend"), this._playbackHeartbeatInterval = null)
                                        }
                                    }]) && $(t.prototype, i), Object.defineProperty(t, "prototype", {
                                        writable: !1
                                    }), e
                                }();

                                function j(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var G = function(e, t, i) {
                                    return t && j(e.prototype, t), i && j(e, i), Object.defineProperty(e, "prototype", {
                                        writable: !1
                                    }), e
                                }((function e(t) {
                                    var i = this;
                                    ! function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                    }(this, e), t.on("viewinit", (function() {
                                        i.viewErrored = !1
                                    })), t.on("error", (function(e, r) {
                                        try {
                                            var n = t.errorTranslator({
                                                player_error_code: r.player_error_code,
                                                player_error_message: r.player_error_message,
                                                player_error_context: r.player_error_context
                                            });
                                            n ? (t.data.player_error_code = n.player_error_code || r.player_error_code, t.data.player_error_message = n.player_error_message || r.player_error_message, t.data.player_error_context = n.player_error_context || r.player_error_context, i.viewErrored = !0) : (delete t.data.player_error_code, delete t.data.player_error_message, delete t.data.player_error_context)
                                        } catch (e) {
                                            t.mux.log.warn("Exception in error translator callback.", e), i.viewErrored = !0
                                        }
                                    }))
                                }));

                                function V(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var q = function() {
                                    function e(t) {
                                        ! function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                        }(this, e), this.pm = t, this._watchTimeTrackerLastCheckedTime = null, t.on("playbackheartbeat", this._updateWatchTime.bind(this)), t.on("playbackheartbeatend", this._clearWatchTimeState.bind(this))
                                    }
                                    var t, i;
                                    return t = e, (i = [{
                                        key: "_updateWatchTime",
                                        value: function(e, t) {
                                            var i = t.viewer_time;
                                            null === this._watchTimeTrackerLastCheckedTime && (this._watchTimeTrackerLastCheckedTime = i), T(this.pm.data, "view_watch_time", i - this._watchTimeTrackerLastCheckedTime), this._watchTimeTrackerLastCheckedTime = i
                                        }
                                    }, {
                                        key: "_clearWatchTimeState",
                                        value: function(e, t) {
                                            this._updateWatchTime(e, t), this._watchTimeTrackerLastCheckedTime = null
                                        }
                                    }]) && V(t.prototype, i), Object.defineProperty(t, "prototype", {
                                        writable: !1
                                    }), e
                                }();

                                function K(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var W = function() {
                                    function e(t) {
                                        var i = this;
                                        ! function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                        }(this, e), this.pm = t, this._playbackTimeTrackerLastPlayheadPosition = -1, this._lastTime = m.now(), this._isAdPlaying = !1, this._callbackUpdatePlaybackTime = null;
                                        var r = this._startPlaybackTimeTracking.bind(this);
                                        t.on("playing", r), t.on("adplaying", r), t.on("seeked", r);
                                        var n = this._stopPlaybackTimeTracking.bind(this);
                                        t.on("playbackheartbeatend", n), t.on("seeking", n), t.on("adplaying", (function() {
                                            i._isAdPlaying = !0
                                        })), t.on("adended", (function() {
                                            i._isAdPlaying = !1
                                        })), t.on("adpause", (function() {
                                            i._isAdPlaying = !1
                                        })), t.on("adbreakstart", (function() {
                                            i._isAdPlaying = !1
                                        })), t.on("adbreakend", (function() {
                                            i._isAdPlaying = !1
                                        })), t.on("adplay", (function() {
                                            i._isAdPlaying = !1
                                        })), t.on("viewinit", (function() {
                                            i._playbackTimeTrackerLastPlayheadPosition = -1, i._lastTime = m.now(), i._isAdPlaying = !1, i._callbackUpdatePlaybackTime = null
                                        }))
                                    }
                                    var t, i;
                                    return t = e, (i = [{
                                        key: "_startPlaybackTimeTracking",
                                        value: function() {
                                            null === this._callbackUpdatePlaybackTime && (this._callbackUpdatePlaybackTime = this._updatePlaybackTime.bind(this), this._playbackTimeTrackerLastPlayheadPosition = this.pm.data.player_playhead_time, this.pm.on("playbackheartbeat", this._callbackUpdatePlaybackTime))
                                        }
                                    }, {
                                        key: "_stopPlaybackTimeTracking",
                                        value: function() {
                                            this._callbackUpdatePlaybackTime && (this._updatePlaybackTime(), this.pm.off("playbackheartbeat", this._callbackUpdatePlaybackTime), this._callbackUpdatePlaybackTime = null, this._playbackTimeTrackerLastPlayheadPosition = -1)
                                        }
                                    }, {
                                        key: "_updatePlaybackTime",
                                        value: function() {
                                            var e = this.pm.data.player_playhead_time,
                                                t = m.now(),
                                                i = -1;
                                            this._playbackTimeTrackerLastPlayheadPosition >= 0 && e > this._playbackTimeTrackerLastPlayheadPosition ? i = e - this._playbackTimeTrackerLastPlayheadPosition : this._isAdPlaying && (i = t - this._lastTime), i > 0 && i <= 1e3 && T(this.pm.data, "view_content_playback_time", i), this._playbackTimeTrackerLastPlayheadPosition = e, this._lastTime = t
                                        }
                                    }]) && K(t.prototype, i), Object.defineProperty(t, "prototype", {
                                        writable: !1
                                    }), e
                                }();

                                function Y(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var z = function() {
                                    function e(t) {
                                        ! function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                        }(this, e), this.pm = t;
                                        var i = this._updatePlayheadTime.bind(this);
                                        t.on("playbackheartbeat", i), t.on("playbackheartbeatend", i), t.on("timeupdate", i), t.on("destroy", (function() {
                                            t.off("timeupdate", i)
                                        }))
                                    }
                                    var t, i;
                                    return t = e, (i = [{
                                        key: "_updateMaxPlayheadPosition",
                                        value: function() {
                                            this.pm.data.view_max_playhead_position = void 0 === this.pm.data.view_max_playhead_position ? this.pm.data.player_playhead_time : Math.max(this.pm.data.view_max_playhead_position, this.pm.data.player_playhead_time)
                                        }
                                    }, {
                                        key: "_updatePlayheadTime",
                                        value: function(e, t) {
                                            var i = this,
                                                r = function() {
                                                    i.pm.currentFragmentPDT && i.pm.currentFragmentStart && (i.pm.data.player_program_time = i.pm.currentFragmentPDT + i.pm.data.player_playhead_time - i.pm.currentFragmentStart)
                                                };
                                            if (t && t.player_playhead_time) this.pm.data.player_playhead_time = t.player_playhead_time, r(), this._updateMaxPlayheadPosition();
                                            else if (this.pm.getPlayheadTime) {
                                                var n = this.pm.getPlayheadTime();
                                                void 0 !== n && (this.pm.data.player_playhead_time = n, r(), this._updateMaxPlayheadPosition())
                                            }
                                        }
                                    }]) && Y(t.prototype, i), Object.defineProperty(t, "prototype", {
                                        writable: !1
                                    }), e
                                }();

                                function X(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var Q = 3e5,
                                    J = function(e, t, i) {
                                        return t && X(e.prototype, t), i && X(e, i), Object.defineProperty(e, "prototype", {
                                            writable: !1
                                        }), e
                                    }((function e(t) {
                                        if (function(e, t) {
                                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                            }(this, e), !t.disableRebufferTracking) {
                                            var i, r = function(e, t) {
                                                    n(t), i = void 0
                                                },
                                                n = function(e) {
                                                    if (i) {
                                                        var r = e.viewer_time - i;
                                                        T(t.data, "view_rebuffer_duration", r), i = e.viewer_time, t.data.view_rebuffer_duration > Q && (t.emit("viewend"), t.send("viewend"), t.mux.log.warn("Ending view after rebuffering for longer than ".concat(Q, "ms, future events will be ignored unless a programchange or videochange occurs.")))
                                                    }
                                                    t.data.view_watch_time >= 0 && t.data.view_rebuffer_count > 0 && (t.data.view_rebuffer_frequency = t.data.view_rebuffer_count / t.data.view_watch_time, t.data.view_rebuffer_percentage = t.data.view_rebuffer_duration / t.data.view_watch_time)
                                                };
                                            t.on("playbackheartbeat", (function(e, t) {
                                                return n(t)
                                            })), t.on("rebufferstart", (function(e, n) {
                                                i || (T(t.data, "view_rebuffer_count", 1), i = n.viewer_time, t.one("rebufferend", r))
                                            })), t.on("viewinit", (function() {
                                                i = void 0, t.off("rebufferend", r)
                                            }))
                                        }
                                    }));

                                function Z(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var ee = function() {
                                        function e(t) {
                                            var i = this;
                                            ! function(e, t) {
                                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                            }(this, e), this.pm = t, t.disableRebufferTracking || t.disablePlayheadRebufferTracking || (this._lastCheckedTime = null, this._lastPlayheadTime = null, this._lastPlayheadTimeUpdatedTime = null, t.on("playbackheartbeat", this._checkIfRebuffering.bind(this)), t.on("playbackheartbeatend", this._cleanupRebufferTracker.bind(this)), t.on("seeking", (function() {
                                                i._cleanupRebufferTracker(null, {
                                                    viewer_time: m.now()
                                                })
                                            })))
                                        }
                                        var t, i;
                                        return t = e, i = [{
                                            key: "_checkIfRebuffering",
                                            value: function(e, t) {
                                                if (this.pm.seekingTracker.isSeeking || this.pm.adTracker.isAdBreak || !this.pm.playbackHeartbeat._playheadShouldBeProgressing) this._cleanupRebufferTracker(e, t);
                                                else if (null !== this._lastCheckedTime)
                                                    if (this._lastPlayheadTime === this.pm.data.player_playhead_time) {
                                                        var i = t.viewer_time - this._lastPlayheadTimeUpdatedTime;
                                                        "number" == typeof this.pm.sustainedRebufferThreshold && i >= this.pm.sustainedRebufferThreshold && (this._rebuffering || (this._rebuffering = !0, this.pm.emit("rebufferstart", {
                                                            viewer_time: this._lastPlayheadTimeUpdatedTime
                                                        }))), this._lastCheckedTime = t.viewer_time
                                                    } else this._cleanupRebufferTracker(e, t, !0);
                                                else this._prepareRebufferTrackerState(t.viewer_time)
                                            }
                                        }, {
                                            key: "_clearRebufferTrackerState",
                                            value: function() {
                                                this._lastCheckedTime = null, this._lastPlayheadTime = null, this._lastPlayheadTimeUpdatedTime = null
                                            }
                                        }, {
                                            key: "_prepareRebufferTrackerState",
                                            value: function(e) {
                                                this._lastCheckedTime = e, this._lastPlayheadTime = this.pm.data.player_playhead_time, this._lastPlayheadTimeUpdatedTime = e
                                            }
                                        }, {
                                            key: "_cleanupRebufferTracker",
                                            value: function(e, t) {
                                                var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                                                if (this._rebuffering) this._rebuffering = !1, this.pm.emit("rebufferend", {
                                                    viewer_time: t.viewer_time
                                                });
                                                else {
                                                    if (null === this._lastCheckedTime) return;
                                                    var r = this.pm.data.player_playhead_time - this._lastPlayheadTime,
                                                        n = t.viewer_time - this._lastPlayheadTimeUpdatedTime;
                                                    "number" == typeof this.pm.minimumRebufferDuration && r > 0 && n - r > this.pm.minimumRebufferDuration && (this._lastCheckedTime = null, this.pm.emit("rebufferstart", {
                                                        viewer_time: this._lastPlayheadTimeUpdatedTime
                                                    }), this.pm.emit("rebufferend", {
                                                        viewer_time: this._lastPlayheadTimeUpdatedTime + n - r
                                                    }))
                                                }
                                                i ? this._prepareRebufferTrackerState(t.viewer_time) : this._clearRebufferTrackerState()
                                            }
                                        }], i && Z(t.prototype, i), Object.defineProperty(t, "prototype", {
                                            writable: !1
                                        }), e
                                    }(),
                                    te = ee;

                                function ie(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var re = function() {
                                    function e(t) {
                                        var i = this;
                                        ! function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                        }(this, e), this.pm = t, t.on("viewinit", (function() {
                                            var e = t.data,
                                                r = e.view_id;
                                            if (!e.view_program_changed) {
                                                var n = function(e, n) {
                                                    var s = n.viewer_time;
                                                    "playing" === e.type && void 0 === t.data.view_time_to_first_frame ? i.calculateTimeToFirstFrame(s || m.now(), r) : "adplaying" !== e.type || void 0 !== t.data.view_time_to_first_frame && !i._inPrerollPosition() || i.calculateTimeToFirstFrame(s || m.now(), r)
                                                };
                                                t.one("playing", n), t.one("adplaying", n), t.one("viewend", (function() {
                                                    t.off("playing", n), t.off("adplaying", n)
                                                }))
                                            }
                                        }))
                                    }
                                    var t, i;
                                    return t = e, (i = [{
                                        key: "_inPrerollPosition",
                                        value: function() {
                                            return void 0 === this.pm.data.view_content_playback_time || this.pm.data.view_content_playback_time <= 1e3
                                        }
                                    }, {
                                        key: "calculateTimeToFirstFrame",
                                        value: function(e, t) {
                                            t === this.pm.data.view_id && (this.pm.watchTimeTracker._updateWatchTime(null, {
                                                viewer_time: e
                                            }), this.pm.data.view_time_to_first_frame = this.pm.data.view_watch_time, (this.pm.data.player_autoplay_on || this.pm.data.video_is_autoplay) && this.NAVIGATION_START && (this.pm.data.view_aggregate_startup_time = this.pm.data.view_start + this.pm.data.view_watch_time - this.NAVIGATION_START))
                                        }
                                    }]) && ie(t.prototype, i), Object.defineProperty(t, "prototype", {
                                        writable: !1
                                    }), e
                                }();

                                function ne(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var se = function(e, t, i) {
                                    return t && ne(e.prototype, t), i && ne(e, i), Object.defineProperty(e, "prototype", {
                                        writable: !1
                                    }), e
                                }((function e(t) {
                                    var i = this;
                                    ! function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                    }(this, e), t.on("viewinit", (function() {
                                        i._lastPlayheadPosition = -1
                                    })), ["pause", "rebufferstart", "seeking", "error", "adbreakstart", "hb"].forEach((function(e) {
                                        t.on(e, (function() {
                                            if (i._lastPlayheadPosition >= 0 && t.data.player_playhead_time >= 0 && i._lastPlayerWidth >= 0 && i._lastSourceWidth > 0 && i._lastPlayerHeight >= 0 && i._lastSourceHeight > 0) {
                                                var e = t.data.player_playhead_time - i._lastPlayheadPosition;
                                                if (e < 0) return void(i._lastPlayheadPosition = -1);
                                                var r = Math.min(i._lastPlayerWidth / i._lastSourceWidth, i._lastPlayerHeight / i._lastSourceHeight),
                                                    n = Math.max(0, r - 1),
                                                    s = Math.max(0, 1 - r);
                                                t.data.view_max_upscale_percentage = Math.max(t.data.view_max_upscale_percentage || 0, n), t.data.view_max_downscale_percentage = Math.max(t.data.view_max_downscale_percentage || 0, s), T(t.data, "view_total_content_playback_time", e), T(t.data, "view_total_upscaling", n * e), T(t.data, "view_total_downscaling", s * e)
                                            }
                                            i._lastPlayheadPosition = -1
                                        }))
                                    })), ["playing", "hb"].forEach((function(e) {
                                        t.on(e, (function() {
                                            i._lastPlayheadPosition = t.data.player_playhead_time, i._lastPlayerWidth = t.data.player_width, i._lastPlayerHeight = t.data.player_height, i._lastSourceWidth = t.data.video_source_width, i._lastSourceHeight = t.data.video_source_height
                                        }))
                                    }))
                                }));

                                function ae(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var oe = function(e, t, i) {
                                    return t && ae(e.prototype, t), i && ae(e, i), Object.defineProperty(e, "prototype", {
                                        writable: !1
                                    }), e
                                }((function e(t) {
                                    var i = this;
                                    ! function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                    }(this, e), this.isSeeking = !1;
                                    var r = -1,
                                        n = function() {
                                            var e = m.now(),
                                                n = (t.data.viewer_time || e) - (r || e);
                                            T(t.data, "view_seek_duration", n), t.data.view_max_seek_time = Math.max(t.data.view_max_seek_time || 0, n), i.isSeeking = !1, r = -1
                                        };
                                    t.on("seeking", (function(e, s) {
                                        Object.assign(t.data, s), i.isSeeking && s.viewer_time - r <= 2e3 ? r = s.viewer_time : (i.isSeeking && n(), i.isSeeking = !0, r = s.viewer_time, T(t.data, "view_seek_count", 1), t.send("seeking"))
                                    })), t.on("seeked", (function() {
                                        n()
                                    })), t.on("viewend", (function() {
                                        i.isSeeking && (n(), t.send("seeked")), i.isSeeking = !1, r = -1
                                    }))
                                }));

                                function le(e, t) {
                                    return function(e) {
                                        if (Array.isArray(e)) return e
                                    }(e) || function(e, t) {
                                        var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                        if (null != i) {
                                            var r, n, s = [],
                                                a = !0,
                                                o = !1;
                                            try {
                                                for (i = i.call(e); !(a = (r = i.next()).done) && (s.push(r.value), !t || s.length !== t); a = !0);
                                            } catch (e) {
                                                o = !0, n = e
                                            } finally {
                                                try {
                                                    a || null == i.return || i.return()
                                                } finally {
                                                    if (o) throw n
                                                }
                                            }
                                            return s
                                        }
                                    }(e, t) || function(e, t) {
                                        if (e) {
                                            if ("string" == typeof e) return ce(e, t);
                                            var i = Object.prototype.toString.call(e).slice(8, -1);
                                            return "Object" === i && e.constructor && (i = e.constructor.name), "Map" === i || "Set" === i ? Array.from(e) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? ce(e, t) : void 0
                                        }
                                    }(e, t) || function() {
                                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }()
                                }

                                function ce(e, t) {
                                    (null == t || t > e.length) && (t = e.length);
                                    for (var i = 0, r = new Array(t); i < t; i++) r[i] = e[i];
                                    return r
                                }

                                function de(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var ue = function(e, t) {
                                        e.push(t), e.sort((function(e, t) {
                                            return e.viewer_time - t.viewer_time
                                        }))
                                    },
                                    he = ["adbreakstart", "adrequest", "adresponse", "adplay", "adplaying", "adpause", "adended", "adbreakend", "aderror", "adclicked", "adskipped"],
                                    fe = function() {
                                        function e(t) {
                                            var i = this;
                                            ! function(e, t) {
                                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                            }(this, e), this.pm = t, t.on("viewinit", (function() {
                                                i.isAdBreak = !1, i._currentAdRequestNumber = 0, i._currentAdResponseNumber = 0, i._adRequests = [], i._adResponses = [], i._adHasPlayed = !1, i._wouldBeNewAdPlay = !0, i._prerollPlayTime = void 0
                                            })), he.forEach((function(e) {
                                                return t.on(e, i._updateAdData.bind(i))
                                            }));
                                            var r = function() {
                                                i.isAdBreak = !1
                                            };
                                            t.on("adbreakstart", (function() {
                                                i.isAdBreak = !0
                                            })), t.on("play", r), t.on("playing", r), t.on("viewend", r), t.on("adrequest", (function(e, r) {
                                                r = Object.assign({
                                                    ad_request_id: "generatedAdRequestId" + i._currentAdRequestNumber++
                                                }, r), ue(i._adRequests, r), T(t.data, "view_ad_request_count"), i.inPrerollPosition() && (t.data.view_preroll_requested = !0, i._adHasPlayed || T(t.data, "view_preroll_request_count"))
                                            })), t.on("adresponse", (function(e, r) {
                                                r = Object.assign({
                                                    ad_request_id: "generatedAdRequestId" + i._currentAdResponseNumber++
                                                }, r), ue(i._adResponses, r);
                                                var n = i.findAdRequest(r.ad_request_id);
                                                n && T(t.data, "view_ad_request_time", Math.max(0, r.viewer_time - n.viewer_time))
                                            })), t.on("adplay", (function(e, r) {
                                                i._adHasPlayed = !0, i._wouldBeNewAdPlay && (i._wouldBeNewAdPlay = !1, T(t.data, "view_ad_played_count")), i.inPrerollPosition() && !t.data.view_preroll_played && (t.data.view_preroll_played = !0, i._adRequests.length > 0 && (t.data.view_preroll_request_time = Math.max(0, r.viewer_time - i._adRequests[0].viewer_time)), t.data.view_start && (t.data.view_startup_preroll_request_time = Math.max(0, r.viewer_time - t.data.view_start)), i._prerollPlayTime = r.viewer_time)
                                            })), t.on("adplaying", (function(e, r) {
                                                i.inPrerollPosition() && void 0 === t.data.view_preroll_load_time && void 0 !== i._prerollPlayTime && (t.data.view_preroll_load_time = r.viewer_time - i._prerollPlayTime, t.data.view_startup_preroll_load_time = r.viewer_time - i._prerollPlayTime)
                                            })), t.on("adclicked", (function(e, r) {
                                                i._wouldBeNewAdPlay || T(t.data, "view_ad_clicked_count")
                                            })), t.on("adskipped", (function(e, r) {
                                                i._wouldBeNewAdPlay || T(t.data, "view_ad_skipped_count")
                                            })), t.on("adended", (function() {
                                                i._wouldBeNewAdPlay = !0
                                            })), t.on("aderror", (function() {
                                                i._wouldBeNewAdPlay = !0
                                            }))
                                        }
                                        var t, i;
                                        return t = e, (i = [{
                                            key: "inPrerollPosition",
                                            value: function() {
                                                return void 0 === this.pm.data.view_content_playback_time || this.pm.data.view_content_playback_time <= 1e3
                                            }
                                        }, {
                                            key: "findAdRequest",
                                            value: function(e) {
                                                for (var t = 0; t < this._adRequests.length; t++)
                                                    if (this._adRequests[t].ad_request_id === e) return this._adRequests[t]
                                            }
                                        }, {
                                            key: "_updateAdData",
                                            value: function(e, t) {
                                                if (this.inPrerollPosition()) {
                                                    if (!this.pm.data.view_preroll_ad_tag_hostname && t.ad_tag_url) {
                                                        var i = le(g(t.ad_tag_url), 2),
                                                            r = i[0],
                                                            n = i[1];
                                                        this.pm.data.view_preroll_ad_tag_domain = n, this.pm.data.view_preroll_ad_tag_hostname = r
                                                    }
                                                    if (!this.pm.data.view_preroll_ad_asset_hostname && t.ad_asset_url) {
                                                        var s = le(g(t.ad_asset_url), 2),
                                                            a = s[0],
                                                            o = s[1];
                                                        this.pm.data.view_preroll_ad_asset_domain = o, this.pm.data.view_preroll_ad_asset_hostname = a
                                                    }
                                                }
                                                this.pm.data.ad_asset_url = null == t ? void 0 : t.ad_asset_url, this.pm.data.ad_tag_url = null == t ? void 0 : t.ad_tag_url, this.pm.data.ad_creative_id = null == t ? void 0 : t.ad_creative_id, this.pm.data.ad_id = null == t ? void 0 : t.ad_id, this.pm.data.ad_universal_id = null == t ? void 0 : t.ad_universal_id
                                            }
                                        }]) && de(t.prototype, i), Object.defineProperty(t, "prototype", {
                                            writable: !1
                                        }), e
                                    }();

                                function me(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var pe = function(e, t, i) {
                                    return t && me(e.prototype, t), i && me(e, i), Object.defineProperty(e, "prototype", {
                                        writable: !1
                                    }), e
                                }((function e(t) {
                                    var i, r;
                                    ! function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                    }(this, e);
                                    var s = function() {
                                            t.disableRebufferTracking || i && (T(t.data, "view_waiting_rebuffer_duration", m.now() - i), i = !1, n().clearInterval(r))
                                        },
                                        a = !1,
                                        o = function() {
                                            a = !1, s()
                                        };
                                    t.on("waiting", (function() {
                                        a && (t.disableRebufferTracking || (T(t.data, "view_waiting_rebuffer_count", 1), i = m.now(), r = n().setInterval((function() {
                                            if (i) {
                                                var e = m.now();
                                                T(t.data, "view_waiting_rebuffer_duration", e - i), i = e
                                            }
                                        }), 250)))
                                    })), t.on("playing", (function() {
                                        s(), a = !0
                                    })), t.on("pause", o), t.on("seeking", o)
                                }));

                                function ge(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var ye = function(e, t, i) {
                                        return t && ge(e.prototype, t), i && ge(e, i), Object.defineProperty(e, "prototype", {
                                            writable: !1
                                        }), e
                                    }((function e(t) {
                                        var i = this;
                                        ! function(e, t) {
                                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                        }(this, e);
                                        var r = function() {
                                                i.lastWallClockTime = m.now(), t.on("before*", n)
                                            },
                                            n = function(e) {
                                                var r = m.now(),
                                                    n = i.lastWallClockTime;
                                                i.lastWallClockTime = r, r - n > 3e4 && (t.emit("devicesleep", {
                                                    viewer_time: n
                                                }), Object.assign(t.data, {
                                                    viewer_time: n
                                                }), t.send("devicesleep"), t.emit("devicewake", {
                                                    viewer_time: r
                                                }), Object.assign(t.data, {
                                                    viewer_time: r
                                                }), t.send("devicewake"))
                                            };
                                        t.one("playbackheartbeat", r), t.on("playbackheartbeatend", (function() {
                                            t.off("before*", n), t.one("playbackheartbeat", r)
                                        }))
                                    })),
                                    ve = i(375),
                                    be = i(655),
                                    Te = i.n(be),
                                    Ee = "muxData",
                                    Ae = function() {
                                        var e;
                                        try {
                                            e = ve.parse(Te().get(Ee) || "")
                                        } catch (t) {
                                            e = {}
                                        }
                                        return e
                                    },
                                    we = function(e) {
                                        try {
                                            Te().set(Ee, ve.stringify(e), {
                                                expires: 365
                                            })
                                        } catch (e) {}
                                    },
                                    _e = function() {
                                        var e = Ae();
                                        return e.mux_viewer_id = e.mux_viewer_id || s(), e.msn = e.msn || Math.random(), we(e), {
                                            mux_viewer_id: e.mux_viewer_id,
                                            mux_sample_number: e.msn
                                        }
                                    },
                                    ke = function() {
                                        var e;
                                        switch (Se()) {
                                            case "cellular":
                                                e = "cellular";
                                                break;
                                            case "ethernet":
                                                e = "wired";
                                                break;
                                            case "wifi":
                                                e = "wifi";
                                                break;
                                            case void 0:
                                                break;
                                            default:
                                                e = "other"
                                        }
                                        return e
                                    },
                                    Se = function() {
                                        var e = n().navigator,
                                            t = e && (e.connection || e.mozConnection || e.webkitConnection);
                                        return t && t.type
                                    };
                                ke.getConnectionFromAPI = Se;
                                var Le = ke,
                                    Re = Ce({
                                        a: "env",
                                        b: "beacon",
                                        c: "custom",
                                        d: "ad",
                                        e: "event",
                                        f: "experiment",
                                        i: "internal",
                                        m: "mux",
                                        n: "response",
                                        p: "player",
                                        q: "request",
                                        r: "retry",
                                        s: "session",
                                        t: "timestamp",
                                        u: "viewer",
                                        v: "video",
                                        w: "page",
                                        x: "view",
                                        y: "sub"
                                    }),
                                    De = Ce({
                                        ad: "ad",
                                        ag: "aggregate",
                                        ap: "api",
                                        al: "application",
                                        ar: "architecture",
                                        as: "asset",
                                        au: "autoplay",
                                        av: "average",
                                        bi: "bitrate",
                                        br: "break",
                                        bw: "browser",
                                        by: "bytes",
                                        ca: "cached",
                                        cb: "cancel",
                                        cc: "codec",
                                        cd: "code",
                                        cg: "category",
                                        ch: "changed",
                                        ck: "clicked",
                                        cl: "canceled",
                                        cn: "config",
                                        co: "count",
                                        ce: "counter",
                                        cp: "complete",
                                        cr: "creative",
                                        ct: "content",
                                        cu: "current",
                                        cx: "connection",
                                        cz: "context",
                                        dg: "downscaling",
                                        dm: "domain",
                                        dn: "cdn",
                                        do: "downscale",
                                        dr: "drm",
                                        dp: "dropped",
                                        du: "duration",
                                        dv: "device",
                                        ec: "encoding",
                                        ed: "edge",
                                        en: "end",
                                        eg: "engine",
                                        em: "embed",
                                        er: "error",
                                        es: "errorcode",
                                        et: "errortext",
                                        ee: "event",
                                        ev: "events",
                                        ex: "expires",
                                        ep: "experiments",
                                        fa: "failed",
                                        fi: "first",
                                        fm: "family",
                                        ft: "format",
                                        fp: "fps",
                                        fq: "frequency",
                                        fr: "frame",
                                        fs: "fullscreen",
                                        ha: "has",
                                        hb: "holdback",
                                        he: "headers",
                                        ho: "host",
                                        hn: "hostname",
                                        ht: "height",
                                        id: "id",
                                        ii: "init",
                                        in: "instance",
                                        ip: "ip",
                                        is: "is",
                                        ke: "key",
                                        la: "language",
                                        lb: "labeled",
                                        le: "level",
                                        li: "live",
                                        ld: "loaded",
                                        lo: "load",
                                        ls: "lists",
                                        lt: "latency",
                                        ma: "max",
                                        md: "media",
                                        me: "message",
                                        mf: "manifest",
                                        mi: "mime",
                                        ml: "midroll",
                                        mm: "min",
                                        mn: "manufacturer",
                                        mo: "model",
                                        mx: "mux",
                                        ne: "newest",
                                        nm: "name",
                                        no: "number",
                                        on: "on",
                                        os: "os",
                                        pa: "paused",
                                        pb: "playback",
                                        pd: "producer",
                                        pe: "percentage",
                                        pf: "played",
                                        pg: "program",
                                        ph: "playhead",
                                        pi: "plugin",
                                        pl: "preroll",
                                        pn: "playing",
                                        po: "poster",
                                        pr: "preload",
                                        ps: "position",
                                        pt: "part",
                                        py: "property",
                                        ra: "rate",
                                        rd: "requested",
                                        re: "rebuffer",
                                        rf: "rendition",
                                        rm: "remote",
                                        ro: "ratio",
                                        rp: "response",
                                        rq: "request",
                                        rs: "requests",
                                        sa: "sample",
                                        sd: "skipped",
                                        se: "session",
                                        sk: "seek",
                                        sm: "stream",
                                        so: "source",
                                        sq: "sequence",
                                        sr: "series",
                                        st: "start",
                                        su: "startup",
                                        sv: "server",
                                        sw: "software",
                                        ta: "tag",
                                        tc: "tech",
                                        te: "text",
                                        tg: "target",
                                        th: "throughput",
                                        ti: "time",
                                        tl: "total",
                                        to: "to",
                                        tt: "title",
                                        ty: "type",
                                        ug: "upscaling",
                                        un: "universal",
                                        up: "upscale",
                                        ur: "url",
                                        us: "user",
                                        va: "variant",
                                        vd: "viewed",
                                        vi: "video",
                                        ve: "version",
                                        vw: "view",
                                        vr: "viewer",
                                        wd: "width",
                                        wa: "watch",
                                        wt: "waiting"
                                    });

                                function Ce(e) {
                                    var t = {};
                                    for (var i in e) e.hasOwnProperty(i) && (t[e[i]] = i);
                                    return t
                                }

                                function Ie(e) {
                                    var t = {},
                                        i = {};
                                    return Object.keys(e).forEach((function(r) {
                                        var n = !1;
                                        if (e.hasOwnProperty(r) && void 0 !== e[r]) {
                                            var s = r.split("_"),
                                                a = s[0],
                                                o = Re[a];
                                            o || (h.info("Data key word `" + s[0] + "` not expected in " + r), o = a + "_"), s.splice(1).forEach((function(e) {
                                                "url" === e && (n = !0), De[e] ? o += De[e] : Number(e) && Math.floor(Number(e)) === Number(e) ? o += e : (h.info("Data key word `" + e + "` not expected in " + r), o += "_" + e + "_")
                                            })), n ? i[o] = e[r] : t[o] = e[r]
                                        }
                                    })), Object.assign(t, i)
                                }
                                var Pe = {
                                        maxBeaconSize: 300,
                                        maxQueueLength: 3600,
                                        baseTimeBetweenBeacons: 1e4,
                                        maxPayloadKBSize: 500
                                    },
                                    xe = ["hb", "requestcompleted", "requestfailed", "requestcanceled"],
                                    Oe = function(e) {
                                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                        this._beaconUrl = e || "https://img.litix.io", this._eventQueue = [], this._postInFlight = !1, this._failureCount = 0, this._sendTimeout = !1, this._options = Object.assign({}, Pe, t)
                                    };
                                Oe.prototype.queueEvent = function(e, t) {
                                    var i = Object.assign({}, t);
                                    return (this._eventQueue.length <= this._options.maxQueueLength || "eventrateexceeded" === e) && (this._eventQueue.push(i), this._sendTimeout || this._startBeaconSending(), this._eventQueue.length <= this._options.maxQueueLength)
                                }, Oe.prototype.flushEvents = function() {
                                    arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && 1 === this._eventQueue.length ? this._eventQueue.pop() : (this._eventQueue.length && this._sendBeaconQueue(), this._startBeaconSending())
                                }, Oe.prototype.destroy = function() {
                                    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                    this.destroyed = !0, e ? this._clearBeaconQueue() : this.flushEvents(), n().clearTimeout(this._sendTimeout)
                                }, Oe.prototype._clearBeaconQueue = function() {
                                    var e = this._eventQueue.length > this._options.maxBeaconSize ? this._eventQueue.length - this._options.maxBeaconSize : 0,
                                        t = this._eventQueue.slice(e);
                                    e > 0 && Object.assign(t[t.length - 1], Ie({
                                        mux_view_message: "event queue truncated"
                                    }));
                                    var i = this._createPayload(t);
                                    Ne(this._beaconUrl, i, !0, (function() {}))
                                }, Oe.prototype._sendBeaconQueue = function() {
                                    var e = this;
                                    if (!this._postInFlight) {
                                        var t = this._eventQueue.slice(0, this._options.maxBeaconSize);
                                        this._eventQueue = this._eventQueue.slice(this._options.maxBeaconSize), this._postInFlight = !0;
                                        var i = this._createPayload(t),
                                            r = m.now();
                                        Ne(this._beaconUrl, i, !1, (function(i, n) {
                                            n ? (e._eventQueue = t.concat(e._eventQueue), e._failureCount += 1, h.info("Error sending beacon: " + n)) : e._failureCount = 0, e._roundTripTime = m.now() - r, e._postInFlight = !1
                                        }))
                                    }
                                }, Oe.prototype._getNextBeaconTime = function() {
                                    if (!this._failureCount) return this._options.baseTimeBetweenBeacons;
                                    var e = Math.pow(2, this._failureCount - 1);
                                    return (1 + (e *= Math.random())) * this._options.baseTimeBetweenBeacons
                                }, Oe.prototype._startBeaconSending = function() {
                                    var e = this;
                                    n().clearTimeout(this._sendTimeout), this.destroyed || (this._sendTimeout = n().setTimeout((function() {
                                        e._eventQueue.length && e._sendBeaconQueue(), e._startBeaconSending()
                                    }), this._getNextBeaconTime()))
                                }, Oe.prototype._createPayload = function(e) {
                                    var t, i, r, n = this,
                                        s = {
                                            transmission_timestamp: Math.round(m.now())
                                        };
                                    this._roundTripTime && (s.rtt_ms = Math.round(this._roundTripTime));
                                    var a = function() {
                                            t = JSON.stringify({
                                                metadata: s,
                                                events: i || e
                                            }), r = t.length / 1024
                                        },
                                        o = function() {
                                            return r <= n._options.maxPayloadKBSize
                                        };
                                    return a(), o() || (h.info("Payload size is too big (" + r + " kb). Removing unnecessary events."), i = e.filter((function(e) {
                                        return -1 === xe.indexOf(e.e)
                                    })), a()), o() || (h.info("Payload size still too big (" + r + " kb). Cropping fields.."), i.forEach((function(e) {
                                        for (var t in e) {
                                            var i = e[t];
                                            "string" == typeof i && i.length > 51200 && (e[t] = i.substring(0, 51200))
                                        }
                                    })), a()), t
                                };
                                var Me = function(e) {
                                        return e.length <= 57344
                                    },
                                    Ne = function(e, t, i, r) {
                                        if (i && navigator && navigator.sendBeacon && navigator.sendBeacon(e, t)) r();
                                        else if (n().fetch) n().fetch(e, {
                                            method: "POST",
                                            body: t,
                                            headers: {
                                                "Content-Type": "text/plain"
                                            },
                                            keepalive: Me(t)
                                        }).then((function(e) {
                                            return r(null, e.ok ? null : "Error")
                                        })).catch((function(e) {
                                            return r(null, e)
                                        }));
                                        else {
                                            if (n().XMLHttpRequest) {
                                                var s = new(n().XMLHttpRequest);
                                                return s.onreadystatechange = function() {
                                                    if (4 === s.readyState) return r(null, 200 !== s.status ? "error" : void 0)
                                                }, s.open("POST", e), s.setRequestHeader("Content-Type", "text/plain"), void s.send(t)
                                            }
                                            r()
                                        }
                                    },
                                    Fe = Oe;

                                function Be(e, t) {
                                    (null == t || t > e.length) && (t = e.length);
                                    for (var i = 0, r = new Array(t); i < t; i++) r[i] = e[i];
                                    return r
                                }

                                function Ue(e, t) {
                                    var i = Object.keys(e);
                                    if (Object.getOwnPropertySymbols) {
                                        var r = Object.getOwnPropertySymbols(e);
                                        t && (r = r.filter((function(t) {
                                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                                        }))), i.push.apply(i, r)
                                    }
                                    return i
                                }

                                function $e(e) {
                                    for (var t = 1; t < arguments.length; t++) {
                                        var i = null != arguments[t] ? arguments[t] : {};
                                        t % 2 ? Ue(Object(i), !0).forEach((function(t) {
                                            Ge(e, t, i[t])
                                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Ue(Object(i)).forEach((function(t) {
                                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                                        }))
                                    }
                                    return e
                                }

                                function He(e) {
                                    return He = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                        return typeof e
                                    } : function(e) {
                                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                                    }, He(e)
                                }

                                function je(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }

                                function Ge(e, t, i) {
                                    return t in e ? Object.defineProperty(e, t, {
                                        value: i,
                                        enumerable: !0,
                                        configurable: !0,
                                        writable: !0
                                    }) : e[t] = i, e
                                }
                                var Ve = ["env_key", "view_id", "view_sequence_number", "player_sequence_number", "beacon_domain", "player_playhead_time", "viewer_time", "mux_api_version", "event", "video_id", "player_instance_id"],
                                    qe = ["adplay", "adplaying", "adpause", "adfirstquartile", "admidpoint", "adthirdquartile", "adended", "adresponse", "adrequest"],
                                    Ke = ["ad_id", "ad_creative_id", "ad_universal_id"],
                                    We = ["viewstart", "error", "ended", "viewend"],
                                    Ye = function() {
                                        function e(t, i) {
                                            var r, s, a, o, l, c, d, u, h, f, m, p, g, y, v, b = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                                            (function(e, t) {
                                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                            })(this, e), Ge(this, "previousBeaconData", null), Ge(this, "lastEventTime", 0), Ge(this, "rateLimited", !1), this.mux = t, this.envKey = i, this.options = b, this.eventQueue = new Fe(function(e, t) {
                                                var i = t.beaconCollectionDomain,
                                                    r = t.beaconDomain;
                                                if (i) return "https://" + i;
                                                var n = r || "litix.io";
                                                return (e = e || "inferred").match(/^[a-z0-9]+$/) ? "https://" + e + "." + n : "https://img.litix.io/a.gif"
                                            }(this.envKey, this.options)), this.sampleRate = null !== (r = this.options.sampleRate) && void 0 !== r ? r : 1, this.disableCookies = null !== (s = this.options.disableCookies) && void 0 !== s && s, this.respectDoNotTrack = null !== (a = this.options.respectDoNotTrack) && void 0 !== a && a, this.previousBeaconData = null, this.lastEventTime = 0, this.rateLimited = !1, this.pageLevelData = {
                                                mux_api_version: this.mux.API_VERSION,
                                                mux_embed: this.mux.NAME,
                                                mux_embed_version: this.mux.VERSION,
                                                viewer_application_name: null === (o = this.options.platform) || void 0 === o ? void 0 : o.name,
                                                viewer_application_version: null === (l = this.options.platform) || void 0 === l ? void 0 : l.version,
                                                viewer_application_engine: null === (c = this.options.platform) || void 0 === c ? void 0 : c.layout,
                                                viewer_device_name: null === (d = this.options.platform) || void 0 === d ? void 0 : d.product,
                                                viewer_device_category: "",
                                                viewer_device_manufacturer: null === (u = this.options.platform) || void 0 === u ? void 0 : u.manufacturer,
                                                viewer_os_family: null === (h = this.options.platform) || void 0 === h || null === (f = h.os) || void 0 === f ? void 0 : f.family,
                                                viewer_os_architecture: null === (m = this.options.platform) || void 0 === m || null === (p = m.os) || void 0 === p ? void 0 : p.architecture,
                                                viewer_os_version: null === (g = this.options.platform) || void 0 === g || null === (y = g.os) || void 0 === y ? void 0 : y.version,
                                                viewer_connection_type: Le(),
                                                page_url: null === n() || void 0 === n() || null === (v = n().location) || void 0 === v ? void 0 : v.href
                                            }, this.viewerData = this.disableCookies ? {} : _e()
                                        }
                                        var t, i;
                                        return t = e, (i = [{
                                            key: "send",
                                            value: function(e, t) {
                                                var i;
                                                if (e && null != t && t.view_id) {
                                                    if (this.respectDoNotTrack && f()) return h.info("Not sending `" + e + "` because Do Not Track is enabled");
                                                    if (!t || "object" !== He(t)) return h.error("A data object was expected in send() but was not provided");
                                                    var r, n, a = this.disableCookies ? {} : (r = Ae(), n = m.now(), r.session_start && (r.sst = r.session_start, delete r.session_start), r.session_id && (r.sid = r.session_id, delete r.session_id), r.session_expires && (r.sex = r.session_expires, delete r.session_expires), (!r.sex || r.sex < n) && (r.sid = s(), r.sst = n), r.sex = n + 15e5, we(r), {
                                                            session_id: r.sid,
                                                            session_start: r.sst,
                                                            session_expires: r.sex
                                                        }),
                                                        o = $e($e($e($e($e({}, this.pageLevelData), t), a), this.viewerData), {}, {
                                                            event: e,
                                                            env_key: this.envKey
                                                        });
                                                    o.user_id && (o.viewer_user_id = o.user_id, delete o.user_id);
                                                    var l = (null !== (i = o.mux_sample_number) && void 0 !== i ? i : 0) >= this.sampleRate,
                                                        c = Ie(this._deduplicateBeaconData(e, o));
                                                    if (this.lastEventTime = this.mux.utils.now(), l) return h.info("Not sending event due to sample rate restriction", e, o, c);
                                                    if (this.envKey || h.info("Missing environment key (envKey) - beacons will be dropped if the video source is not a valid mux video URL", e, o, c), !this.rateLimited)
                                                        if (h.info("Sending event", e, o, c), this.rateLimited = !this.eventQueue.queueEvent(e, c), this.mux.WINDOW_UNLOADING && "viewend" === e) this.eventQueue.destroy(!0);
                                                        else if (this.mux.WINDOW_HIDDEN && "hb" === e ? this.eventQueue.flushEvents(!0) : We.indexOf(e) >= 0 && this.eventQueue.flushEvents(), this.rateLimited) return o.event = "eventrateexceeded", c = Ie(o), this.eventQueue.queueEvent(o.event, c), h.error("Beaconing disabled due to rate limit.")
                                                }
                                            }
                                        }, {
                                            key: "destroy",
                                            value: function() {
                                                this.eventQueue.destroy(!1)
                                            }
                                        }, {
                                            key: "_deduplicateBeaconData",
                                            value: function(e, t) {
                                                var i = this,
                                                    r = {},
                                                    n = t.view_id;
                                                if ("-1" === n || "viewstart" === e || "viewend" === e || !this.previousBeaconData || this.mux.utils.now() - this.lastEventTime >= 6e5) r = $e({}, t), n && (this.previousBeaconData = r), n && "viewend" === e && (this.previousBeaconData = null);
                                                else {
                                                    var s = 0 === e.indexOf("request");
                                                    Object.entries(t).forEach((function(t) {
                                                        var n = function(e, t) {
                                                                return function(e) {
                                                                    if (Array.isArray(e)) return e
                                                                }(e) || function(e, t) {
                                                                    var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                                                    if (null != i) {
                                                                        var r, n, s = [],
                                                                            a = !0,
                                                                            o = !1;
                                                                        try {
                                                                            for (i = i.call(e); !(a = (r = i.next()).done) && (s.push(r.value), !t || s.length !== t); a = !0);
                                                                        } catch (e) {
                                                                            o = !0, n = e
                                                                        } finally {
                                                                            try {
                                                                                a || null == i.return || i.return()
                                                                            } finally {
                                                                                if (o) throw n
                                                                            }
                                                                        }
                                                                        return s
                                                                    }
                                                                }(e, t) || function(e, t) {
                                                                    if (e) {
                                                                        if ("string" == typeof e) return Be(e, t);
                                                                        var i = Object.prototype.toString.call(e).slice(8, -1);
                                                                        return "Object" === i && e.constructor && (i = e.constructor.name), "Map" === i || "Set" === i ? Array.from(e) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Be(e, t) : void 0
                                                                    }
                                                                }(e, t) || function() {
                                                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                                                }()
                                                            }(t, 2),
                                                            a = n[0],
                                                            o = n[1];
                                                        i.previousBeaconData && (o !== i.previousBeaconData[a] || Ve.indexOf(a) > -1 || i.objectHasChanged(s, a, o, i.previousBeaconData[a]) || i.eventRequiresKey(e, a)) && (r[a] = o, i.previousBeaconData[a] = o)
                                                    }))
                                                }
                                                return r
                                            }
                                        }, {
                                            key: "objectHasChanged",
                                            value: function(e, t, i, r) {
                                                return !(!e || 0 !== t.indexOf("request_") || "request_response_headers" !== t && "object" === He(i) && "object" === He(r) && Object.keys(i || {}).length === Object.keys(r || {}).length)
                                            }
                                        }, {
                                            key: "eventRequiresKey",
                                            value: function(e, t) {
                                                return "renditionchange" === e && 0 === t.indexOf("video_source_") || !(!Ke.includes(t) || !qe.includes(e))
                                            }
                                        }]) && je(t.prototype, i), Object.defineProperty(t, "prototype", {
                                            writable: !1
                                        }), e
                                    }();

                                function ze(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var Xe = function(e, t, i) {
                                    return t && ze(e.prototype, t), i && ze(e, i), Object.defineProperty(e, "prototype", {
                                        writable: !1
                                    }), e
                                }((function e(t) {
                                    ! function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                    }(this, e);
                                    var i = 0,
                                        r = 0,
                                        n = 0,
                                        s = 0,
                                        a = 0,
                                        o = 0,
                                        l = 0;
                                    t.on("requestcompleted", (function(e, o) {
                                        var l, c, d = o.request_start,
                                            u = o.request_response_start,
                                            h = o.request_response_end,
                                            f = o.request_bytes_loaded;
                                        if (s++, u ? (l = u - (null != d ? d : 0), c = (null != h ? h : 0) - u) : c = (null != h ? h : 0) - (null != d ? d : 0), c > 0 && f && f > 0) {
                                            var m = f / c * 8e3;
                                            a++, r += f, n += c, t.data.view_min_request_throughput = Math.min(t.data.view_min_request_throughput || 1 / 0, m), t.data.view_average_request_throughput = r / n * 8e3, t.data.view_request_count = s, l > 0 && (i += l, t.data.view_max_request_latency = Math.max(t.data.view_max_request_latency || 0, l), t.data.view_average_request_latency = i / a)
                                        }
                                    })), t.on("requestfailed", (function(e, i) {
                                        s++, o++, t.data.view_request_count = s, t.data.view_request_failed_count = o
                                    })), t.on("requestcanceled", (function(e, i) {
                                        s++, l++, t.data.view_request_count = s, t.data.view_request_canceled_count = l
                                    }))
                                }));

                                function Qe(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                var Je = function(e, t, i) {
                                    return t && Qe(e.prototype, t), i && Qe(e, i), Object.defineProperty(e, "prototype", {
                                        writable: !1
                                    }), e
                                }((function e(t) {
                                    var i = this;
                                    ! function(e, t) {
                                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                    }(this, e), t.on("before*", (function(e, r) {
                                        var n = r.viewer_time,
                                            s = m.now(),
                                            a = i._lastEventTime;
                                        if (i._lastEventTime = s, a && s - a > 36e5) {
                                            var o = Object.keys(t.data).reduce((function(e, i) {
                                                return 0 === i.indexOf("video_") ? Object.assign(e, function(e, t, i) {
                                                    return t in e ? Object.defineProperty(e, t, {
                                                        value: i,
                                                        enumerable: !0,
                                                        configurable: !0,
                                                        writable: !0
                                                    }) : e[t] = i, e
                                                }({}, i, t.data[i])) : e
                                            }), {});
                                            t.mux.log.info("Received event after at least an hour inactivity, creating a new view"), t.emit("viewinit", Object.assign({
                                                viewer_time: n
                                            }, o)), t.playbackHeartbeat._playheadShouldBeProgressing && "play" !== e.type && "adbreakstart" !== e.type && (t.emit("play", {
                                                viewer_time: n
                                            }), "playing" !== e.type && t.emit("playing", {
                                                viewer_time: n
                                            }))
                                        }
                                    }))
                                }));

                                function Ze(e) {
                                    return Ze = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                        return typeof e
                                    } : function(e) {
                                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                                    }, Ze(e)
                                }

                                function et(e, t) {
                                    (null == t || t > e.length) && (t = e.length);
                                    for (var i = 0, r = new Array(t); i < t; i++) r[i] = e[i];
                                    return r
                                }

                                function tt(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }

                                function it(e, t) {
                                    return it = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                                        return e.__proto__ = t, e
                                    }, it(e, t)
                                }

                                function rt(e) {
                                    var t = function() {
                                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                                        if (Reflect.construct.sham) return !1;
                                        if ("function" == typeof Proxy) return !0;
                                        try {
                                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                                        } catch (e) {
                                            return !1
                                        }
                                    }();
                                    return function() {
                                        var i, r = st(e);
                                        if (t) {
                                            var n = st(this).constructor;
                                            i = Reflect.construct(r, arguments, n)
                                        } else i = r.apply(this, arguments);
                                        return function(e, t) {
                                            if (t && ("object" === Ze(t) || "function" == typeof t)) return t;
                                            if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                                            return nt(e)
                                        }(this, i)
                                    }
                                }

                                function nt(e) {
                                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                    return e
                                }

                                function st(e) {
                                    return st = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                                        return e.__proto__ || Object.getPrototypeOf(e)
                                    }, st(e)
                                }
                                var at = ["viewstart", "ended", "loadstart", "pause", "play", "playing", "ratechange", "waiting", "adplay", "adpause", "adended", "aderror", "adplaying", "adrequest", "adresponse", "adbreakstart", "adbreakend", "adfirstquartile", "admidpoint", "adthirdquartile", "rebufferstart", "rebufferend", "seeked", "error", "hb", "requestcompleted", "requestfailed", "requestcanceled", "renditionchange"],
                                    ot = function(e) {
                                        ! function(e, t) {
                                            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                                            e.prototype = Object.create(t && t.prototype, {
                                                constructor: {
                                                    value: e,
                                                    writable: !0,
                                                    configurable: !0
                                                }
                                            }), Object.defineProperty(e, "prototype", {
                                                writable: !1
                                            }), t && it(e, t)
                                        }(n, e);
                                        var t, i, r = rt(n);

                                        function n(e, t, i) {
                                            var a, o;
                                            ! function(e, t) {
                                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                                            }(this, n), (o = r.call(this)).DOM_CONTENT_LOADED_EVENT_END = v(), o.NAVIGATION_START = b(), o.mux = e, o.id = t, null !== (a = i) && void 0 !== a && a.beaconDomain && o.mux.log.warn("The `beaconDomain` setting has been deprecated in favor of `beaconCollectionDomain`. Please change your integration to use `beaconCollectionDomain` instead of `beaconDomain`."), (i = Object.assign({
                                                debug: !1,
                                                minimumRebufferDuration: 250,
                                                sustainedRebufferThreshold: 1e3,
                                                playbackHeartbeatTime: 25,
                                                beaconDomain: "litix.io",
                                                sampleRate: 1,
                                                disableCookies: !1,
                                                respectDoNotTrack: !1,
                                                disableRebufferTracking: !1,
                                                disablePlayheadRebufferTracking: !1,
                                                errorTranslator: function(e) {
                                                    return e
                                                }
                                            }, i)).data = i.data || {}, i.data.property_key && (i.data.env_key = i.data.property_key, delete i.data.property_key), h.setLevel(i.debug ? "debug" : "warn"), o.getPlayheadTime = i.getPlayheadTime, o.getStateData = i.getStateData || function() {
                                                return {}
                                            }, o.getAdData = i.getAdData || function() {}, o.minimumRebufferDuration = i.minimumRebufferDuration, o.sustainedRebufferThreshold = i.sustainedRebufferThreshold, o.playbackHeartbeatTime = i.playbackHeartbeatTime, o.disableRebufferTracking = i.disableRebufferTracking, o.disableRebufferTracking && o.mux.log.warn("Disabling rebuffer tracking. This should only be used in specific circumstances as a last resort when your player is known to unreliably track rebuffering."), o.disablePlayheadRebufferTracking = i.disablePlayheadRebufferTracking, o.errorTranslator = i.errorTranslator, o.playbackEventDispatcher = new Ye(e, i.data.env_key, i), o.data = {
                                                player_instance_id: s(),
                                                mux_sample_rate: i.sampleRate,
                                                beacon_domain: i.beaconCollectionDomain || i.beaconDomain
                                            }, o.data.view_sequence_number = 1, o.data.player_sequence_number = 1, o.oldEmit = o.emit, o.emit = function(e, t) {
                                                t = Object.assign({
                                                    viewer_time: this.mux.utils.now()
                                                }, t), this.oldEmit(e, t)
                                            };
                                            var l = function() {
                                                void 0 === this.data.view_start && (this.data.view_start = this.mux.utils.now(), this.emit("viewstart"))
                                            }.bind(nt(o));
                                            o.on("viewinit", (function(e, t) {
                                                this._resetVideoData(), this._resetViewData(), this._resetErrorData(), this._updateStateData(), Object.assign(this.data, t), this._initializeViewData(), this.one("play", l), this.one("adbreakstart", l)
                                            }));
                                            var c = function(e) {
                                                this.emit("viewend"), this.send("viewend"), this.emit("viewinit", e)
                                            }.bind(nt(o));
                                            if (o.on("videochange", (function(e, t) {
                                                    c(t)
                                                })), o.on("programchange", (function(e, t) {
                                                    this.data.player_is_paused && this.mux.log.warn("The `programchange` event is intended to be used when the content changes mid playback without the video source changing, however the video is not currently playing. If the video source is changing please use the videochange event otherwise you will lose startup time information."), c(Object.assign(t, {
                                                        view_program_changed: !0
                                                    })), l(), this.emit("play"), this.emit("playing")
                                                })), o.on("fragmentchange", (function(e, t) {
                                                    this.currentFragmentPDT = t.currentFragmentPDT, this.currentFragmentStart = t.currentFragmentStart
                                                })), o.on("destroy", o.destroy), "undefined" != typeof window && "function" == typeof window.addEventListener && "function" == typeof window.removeEventListener) {
                                                var d = function() {
                                                    var e = void 0 !== o.data.view_start;
                                                    o.mux.WINDOW_HIDDEN = "hidden" === document.visibilityState, e && o.mux.WINDOW_HIDDEN && (o.data.player_is_paused || o.emit("hb"))
                                                };
                                                window.addEventListener("visibilitychange", d, !1);
                                                var u = function(e) {
                                                    e.persisted || o.destroy()
                                                };
                                                window.addEventListener("pagehide", u, !1), o.on("destroy", (function() {
                                                    window.removeEventListener("visibilitychange", d), window.removeEventListener("pagehide", u)
                                                }))
                                            }
                                            return o.on("playerready", (function(e, t) {
                                                Object.assign(this.data, t)
                                            })), at.forEach((function(e) {
                                                o.on(e, (function(t, i) {
                                                    0 !== e.indexOf("ad") && this._updateStateData(), Object.assign(this.data, i), this._sanitizeData()
                                                })), o.on("after" + e, (function() {
                                                    ("error" !== e || this.errorTracker.viewErrored) && this.send(e)
                                                }))
                                            })), o.on("viewend", (function(e, t) {
                                                Object.assign(o.data, t)
                                            })), o.one("playerready", (function(e) {
                                                var t = this.mux.utils.now();
                                                this.data.player_init_time && (this.data.player_startup_time = t - this.data.player_init_time), !this.mux.PLAYER_TRACKED && this.NAVIGATION_START && (this.mux.PLAYER_TRACKED = !0, (this.data.player_init_time || this.DOM_CONTENT_LOADED_EVENT_END) && (this.data.page_load_time = Math.min(this.data.player_init_time || 1 / 0, this.DOM_CONTENT_LOADED_EVENT_END || 1 / 0) - this.NAVIGATION_START)), this.send("playerready"), delete this.data.player_startup_time, delete this.data.page_load_time
                                            })), o.longResumeTracker = new Je(nt(o)), o.errorTracker = new G(nt(o)), new ye(nt(o)), o.seekingTracker = new oe(nt(o)), o.playheadTime = new z(nt(o)), o.playbackHeartbeat = new H(nt(o)), new se(nt(o)), o.watchTimeTracker = new q(nt(o)), new W(nt(o)), o.adTracker = new fe(nt(o)), new te(nt(o)), new J(nt(o)), new re(nt(o)), new pe(nt(o)), new Xe(nt(o)), i.hlsjs && o.addHLSJS(i), i.dashjs && o.addDashJS(i), o.emit("viewinit", i.data), o
                                        }
                                        return t = n, i = [{
                                            key: "destroy",
                                            value: function() {
                                                this._destroyed || (this._destroyed = !0, void 0 !== this.data.view_start && (this.emit("viewend"), this.send("viewend")), this.playbackEventDispatcher.destroy(), this.removeHLSJS(), this.removeDashJS(), window.clearTimeout(this._heartBeatTimeout))
                                            }
                                        }, {
                                            key: "send",
                                            value: function(e) {
                                                if (this.data.view_id) {
                                                    var t = Object.assign({}, this.data);
                                                    if (void 0 === t.video_source_is_live && (t.player_source_duration === 1 / 0 || t.video_source_duration === 1 / 0 ? t.video_source_is_live = !0 : (t.player_source_duration > 0 || t.video_source_duration > 0) && (t.video_source_is_live = !1)), t.video_source_is_live || ["player_program_time", "player_manifest_newest_program_time", "player_live_edge_program_time", "player_program_time", "video_holdback", "video_part_holdback", "video_target_duration", "video_part_target_duration"].forEach((function(e) {
                                                            t[e] = void 0
                                                        })), t.video_source_url = t.video_source_url || t.player_source_url, t.video_source_url) {
                                                        var i = function(e, t) {
                                                                return function(e) {
                                                                    if (Array.isArray(e)) return e
                                                                }(e) || function(e, t) {
                                                                    var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                                                    if (null != i) {
                                                                        var r, n, s = [],
                                                                            a = !0,
                                                                            o = !1;
                                                                        try {
                                                                            for (i = i.call(e); !(a = (r = i.next()).done) && (s.push(r.value), !t || s.length !== t); a = !0);
                                                                        } catch (e) {
                                                                            o = !0, n = e
                                                                        } finally {
                                                                            try {
                                                                                a || null == i.return || i.return()
                                                                            } finally {
                                                                                if (o) throw n
                                                                            }
                                                                        }
                                                                        return s
                                                                    }
                                                                }(e, t) || function(e, t) {
                                                                    if (e) {
                                                                        if ("string" == typeof e) return et(e, t);
                                                                        var i = Object.prototype.toString.call(e).slice(8, -1);
                                                                        return "Object" === i && e.constructor && (i = e.constructor.name), "Map" === i || "Set" === i ? Array.from(e) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? et(e, t) : void 0
                                                                    }
                                                                }(e, t) || function() {
                                                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                                                }()
                                                            }(g(t.video_source_url), 2),
                                                            r = i[0],
                                                            n = i[1];
                                                        t.video_source_domain = n, t.video_source_hostname = r
                                                    }
                                                    delete t.ad_request_id, this.playbackEventDispatcher.send(e, t), this.data.view_sequence_number++, this.data.player_sequence_number++, this._restartHeartBeat(), "viewend" === e && delete this.data.view_id
                                                }
                                            }
                                        }, {
                                            key: "_updateStateData",
                                            value: function() {
                                                Object.assign(this.data, this.getStateData()), this.playheadTime._updatePlayheadTime(), this._sanitizeData()
                                            }
                                        }, {
                                            key: "_sanitizeData",
                                            value: function() {
                                                var e = this;
                                                ["player_width", "player_height", "video_source_width", "video_source_height", "player_playhead_time", "video_source_bitrate"].forEach((function(t) {
                                                    var i = parseInt(e.data[t], 10);
                                                    e.data[t] = isNaN(i) ? void 0 : i
                                                })), ["player_source_url", "video_source_url"].forEach((function(t) {
                                                    if (e.data[t]) {
                                                        var i = e.data[t].toLowerCase();
                                                        0 !== i.indexOf("data:") && 0 !== i.indexOf("blob:") || (e.data[t] = "MSE style URL")
                                                    }
                                                }))
                                            }
                                        }, {
                                            key: "_resetVideoData",
                                            value: function(e, t) {
                                                var i = this;
                                                Object.keys(this.data).forEach((function(e) {
                                                    0 === e.indexOf("video_") && delete i.data[e]
                                                }))
                                            }
                                        }, {
                                            key: "_resetViewData",
                                            value: function() {
                                                var e = this;
                                                Object.keys(this.data).forEach((function(t) {
                                                    0 === t.indexOf("view_") && delete e.data[t]
                                                })), this.data.view_sequence_number = 1
                                            }
                                        }, {
                                            key: "_resetErrorData",
                                            value: function(e, t) {
                                                delete this.data.player_error_code, delete this.data.player_error_message
                                            }
                                        }, {
                                            key: "_initializeViewData",
                                            value: function() {
                                                var e = this,
                                                    t = this.data.view_id = s(),
                                                    i = function() {
                                                        t === e.data.view_id && T(e.data, "player_view_count", 1)
                                                    };
                                                this.data.player_is_paused ? this.one("play", i) : i()
                                            }
                                        }, {
                                            key: "_restartHeartBeat",
                                            value: function() {
                                                var e = this;
                                                window.clearTimeout(this._heartBeatTimeout), this.errorTracker.viewErrored || (this._heartBeatTimeout = window.setTimeout((function() {
                                                    e.data.player_is_paused || e.emit("hb")
                                                }), 1e4))
                                            }
                                        }, {
                                            key: "addHLSJS",
                                            value: function(e) {
                                                e.hlsjs ? this.hlsjs ? this.mux.log.warn("An instance of HLS.js is already being monitored for this player.") : (this.hlsjs = e.hlsjs, function(e, t, i) {
                                                    var r = arguments.length > 4 ? arguments[4] : void 0,
                                                        n = e.log,
                                                        s = e.utils.secondsToMs,
                                                        a = function(e) {
                                                            var t, i = parseInt(r.version);
                                                            return 1 === i && null !== e.programDateTime && (t = e.programDateTime), 0 === i && null !== e.pdt && (t = e.pdt), t
                                                        };
                                                    if (y()) {
                                                        var o = function(i, r) {
                                                                return e.emit(t, i, r)
                                                            },
                                                            l = function(e, t) {
                                                                var i = t.levels,
                                                                    r = t.audioTracks,
                                                                    n = t.url,
                                                                    s = t.stats,
                                                                    a = t.networkDetails,
                                                                    l = t.sessionData,
                                                                    c = {},
                                                                    d = {};
                                                                i.forEach((function(e, t) {
                                                                    c[t] = {
                                                                        width: e.width,
                                                                        height: e.height,
                                                                        bitrate: e.bitrate,
                                                                        attrs: e.attrs
                                                                    }
                                                                })), r.forEach((function(e, t) {
                                                                    d[t] = {
                                                                        name: e.name,
                                                                        language: e.lang,
                                                                        bitrate: e.bitrate
                                                                    }
                                                                }));
                                                                var u = D(s),
                                                                    h = u.bytesLoaded,
                                                                    f = u.requestStart,
                                                                    m = u.responseStart,
                                                                    g = u.responseEnd;
                                                                o("requestcompleted", L(L({}, k(l)), {}, {
                                                                    request_event_type: e,
                                                                    request_bytes_loaded: h,
                                                                    request_start: f,
                                                                    request_response_start: m,
                                                                    request_response_end: g,
                                                                    request_type: "manifest",
                                                                    request_hostname: p(n),
                                                                    request_response_headers: C(a),
                                                                    request_rendition_lists: {
                                                                        media: c,
                                                                        audio: d,
                                                                        video: {}
                                                                    }
                                                                }))
                                                            };
                                                        i.on(r.Events.MANIFEST_LOADED, l);
                                                        var c = function(e, t) {
                                                            var i = t.details,
                                                                r = t.level,
                                                                n = t.networkDetails,
                                                                l = t.stats,
                                                                c = D(l),
                                                                d = c.bytesLoaded,
                                                                u = c.requestStart,
                                                                h = c.responseStart,
                                                                f = c.responseEnd,
                                                                m = i.fragments[i.fragments.length - 1],
                                                                g = a(m) + s(m.duration);
                                                            o("requestcompleted", {
                                                                request_event_type: e,
                                                                request_bytes_loaded: d,
                                                                request_start: u,
                                                                request_response_start: h,
                                                                request_response_end: f,
                                                                request_current_level: r,
                                                                request_type: "manifest",
                                                                request_hostname: p(i.url),
                                                                request_response_headers: C(n),
                                                                video_holdback: i.holdBack && s(i.holdBack),
                                                                video_part_holdback: i.partHoldBack && s(i.partHoldBack),
                                                                video_part_target_duration: i.partTarget && s(i.partTarget),
                                                                video_target_duration: i.targetduration && s(i.targetduration),
                                                                video_source_is_live: i.live,
                                                                player_manifest_newest_program_time: isNaN(g) ? void 0 : g
                                                            })
                                                        };
                                                        i.on(r.Events.LEVEL_LOADED, c);
                                                        var d = function(e, t) {
                                                            var i = t.details,
                                                                r = t.networkDetails,
                                                                n = t.stats,
                                                                s = D(n),
                                                                a = s.bytesLoaded,
                                                                l = s.requestStart,
                                                                c = s.responseStart,
                                                                d = s.responseEnd;
                                                            o("requestcompleted", {
                                                                request_event_type: e,
                                                                request_bytes_loaded: a,
                                                                request_start: l,
                                                                request_response_start: c,
                                                                request_response_end: d,
                                                                request_type: "manifest",
                                                                request_hostname: p(i.url),
                                                                request_response_headers: C(r)
                                                            })
                                                        };
                                                        i.on(r.Events.AUDIO_TRACK_LOADED, d);
                                                        var u = function(e, t) {
                                                            var r = t.stats,
                                                                n = t.networkDetails,
                                                                s = t.frag;
                                                            r = r || s.stats;
                                                            var a = D(r),
                                                                l = a.bytesLoaded,
                                                                c = a.requestStart,
                                                                d = a.responseStart,
                                                                u = a.responseEnd,
                                                                h = n ? C(n) : void 0,
                                                                f = {
                                                                    request_event_type: e,
                                                                    request_bytes_loaded: l,
                                                                    request_start: c,
                                                                    request_response_start: d,
                                                                    request_response_end: u,
                                                                    request_hostname: n ? p(n.responseURL) : void 0,
                                                                    request_id: h ? _(h) : void 0,
                                                                    request_response_headers: h,
                                                                    request_media_duration: s.duration,
                                                                    request_url: null == n ? void 0 : n.responseURL
                                                                };
                                                            "main" === s.type ? (f.request_type = "media", f.request_current_level = s.level, f.request_video_width = (i.levels[s.level] || {}).width, f.request_video_height = (i.levels[s.level] || {}).height, f.request_labeled_bitrate = (i.levels[s.level] || {}).bitrate) : f.request_type = s.type, o("requestcompleted", f)
                                                        };
                                                        i.on(r.Events.FRAG_LOADED, u);
                                                        var h = function(e, t) {
                                                            var i = t.frag,
                                                                r = i.start,
                                                                n = {
                                                                    currentFragmentPDT: a(i),
                                                                    currentFragmentStart: s(r)
                                                                };
                                                            o("fragmentchange", n)
                                                        };
                                                        i.on(r.Events.FRAG_CHANGED, h);
                                                        var f = function(e, t) {
                                                            var i = t.type,
                                                                n = t.details,
                                                                s = t.response,
                                                                a = t.fatal,
                                                                l = t.frag,
                                                                c = t.networkDetails,
                                                                d = (null == l ? void 0 : l.url) || t.url || "",
                                                                u = c ? C(c) : void 0;
                                                            if (n !== r.ErrorDetails.MANIFEST_LOAD_ERROR && n !== r.ErrorDetails.MANIFEST_LOAD_TIMEOUT && n !== r.ErrorDetails.FRAG_LOAD_ERROR && n !== r.ErrorDetails.FRAG_LOAD_TIMEOUT && n !== r.ErrorDetails.LEVEL_LOAD_ERROR && n !== r.ErrorDetails.LEVEL_LOAD_TIMEOUT && n !== r.ErrorDetails.AUDIO_TRACK_LOAD_ERROR && n !== r.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT && n !== r.ErrorDetails.SUBTITLE_LOAD_ERROR && n !== r.ErrorDetails.SUBTITLE_LOAD_TIMEOUT && n !== r.ErrorDetails.KEY_LOAD_ERROR && n !== r.ErrorDetails.KEY_LOAD_TIMEOUT || o("requestfailed", {
                                                                    request_error: n,
                                                                    request_url: d,
                                                                    request_hostname: p(d),
                                                                    request_id: u ? _(u) : void 0,
                                                                    request_type: n === r.ErrorDetails.FRAG_LOAD_ERROR || n === r.ErrorDetails.FRAG_LOAD_TIMEOUT ? "media" : n === r.ErrorDetails.AUDIO_TRACK_LOAD_ERROR || n === r.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT ? "audio" : n === r.ErrorDetails.SUBTITLE_LOAD_ERROR || n === r.ErrorDetails.SUBTITLE_LOAD_TIMEOUT ? "subtitle" : n === r.ErrorDetails.KEY_LOAD_ERROR || n === r.ErrorDetails.KEY_LOAD_TIMEOUT ? "encryption" : "manifest",
                                                                    request_error_code: null == s ? void 0 : s.code,
                                                                    request_error_text: null == s ? void 0 : s.text
                                                                }), a) {
                                                                var h, f = "".concat(d ? "url: ".concat(d, "\n") : "") + "".concat(s && (s.code || s.text) ? "response: ".concat(s.code, ", ").concat(s.text, "\n") : "") + "".concat(t.reason ? "failure reason: ".concat(t.reason, "\n") : "") + "".concat(t.level ? "level: ".concat(t.level, "\n") : "") + "".concat(t.parent ? "parent stream controller: ".concat(t.parent, "\n") : "") + "".concat(t.buffer ? "buffer length: ".concat(t.buffer, "\n") : "") + "".concat(t.error ? "error: ".concat(t.error, "\n") : "") + "".concat(t.event ? "event: ".concat(t.event, "\n") : "") + "".concat(t.err ? "error message: ".concat(null === (h = t.err) || void 0 === h ? void 0 : h.message, "\n") : "");
                                                                o("error", {
                                                                    player_error_code: i,
                                                                    player_error_message: n,
                                                                    player_error_context: f
                                                                })
                                                            }
                                                        };
                                                        i.on(r.Events.ERROR, f);
                                                        var m = function(e, t) {
                                                            var i = t.frag,
                                                                r = i && i._url || "";
                                                            o("requestcanceled", {
                                                                request_event_type: e,
                                                                request_url: r,
                                                                request_type: "media",
                                                                request_hostname: p(r)
                                                            })
                                                        };
                                                        i.on(r.Events.FRAG_LOAD_EMERGENCY_ABORTED, m);
                                                        var g = function(e, t) {
                                                            var r = t.level,
                                                                s = i.levels[r];
                                                            if (s && s.attrs && s.attrs.BANDWIDTH) {
                                                                var a, l = s.attrs.BANDWIDTH,
                                                                    c = parseFloat(s.attrs["FRAME-RATE"]);
                                                                isNaN(c) || (a = c), l ? o("renditionchange", {
                                                                    video_source_fps: a,
                                                                    video_source_bitrate: l,
                                                                    video_source_width: s.width,
                                                                    video_source_height: s.height,
                                                                    video_source_rendition_name: s.name,
                                                                    video_source_codec: null == s ? void 0 : s.videoCodec
                                                                }) : n.warn("missing BANDWIDTH from HLS manifest parsed by HLS.js")
                                                            }
                                                        };
                                                        i.on(r.Events.LEVEL_SWITCHED, g), i._stopMuxMonitor = function() {
                                                            i.off(r.Events.MANIFEST_LOADED, l), i.off(r.Events.LEVEL_LOADED, c), i.off(r.Events.AUDIO_TRACK_LOADED, d), i.off(r.Events.FRAG_LOADED, u), i.off(r.Events.FRAG_CHANGED, h), i.off(r.Events.ERROR, f), i.off(r.Events.FRAG_LOAD_EMERGENCY_ABORTED, m), i.off(r.Events.LEVEL_SWITCHED, g), i.off(r.Events.DESTROYING, i._stopMuxMonitor), delete i._stopMuxMonitor
                                                        }, i.on(r.Events.DESTROYING, i._stopMuxMonitor)
                                                    } else n.warn("performance timing not supported. Not tracking HLS.js.")
                                                }(this.mux, this.id, e.hlsjs, {}, e.Hls || window.Hls)) : this.mux.log.warn("You must pass a valid hlsjs instance in order to track it.")
                                            }
                                        }, {
                                            key: "removeHLSJS",
                                            value: function() {
                                                var e;
                                                this.hlsjs && ((e = this.hlsjs) && "function" == typeof e._stopMuxMonitor && e._stopMuxMonitor(), this.hlsjs = void 0)
                                            }
                                        }, {
                                            key: "addDashJS",
                                            value: function(e) {
                                                e.dashjs ? this.dashjs ? this.mux.log.warn("An instance of Dash.js is already being monitored for this player.") : (this.dashjs = e.dashjs, function(e, t, i) {
                                                    var r = e.log;
                                                    if (i && i.on) {
                                                        var n = function(e) {
                                                                try {
                                                                    var t, i;
                                                                    return null === (t = e.getVersion) || void 0 === t || null === (i = t.call(e)) || void 0 === i ? void 0 : i.split(".").map((function(e) {
                                                                        return parseInt(e)
                                                                    }))[0]
                                                                } catch (e) {
                                                                    return !1
                                                                }
                                                            }(i),
                                                            s = function(i, r) {
                                                                return e.emit(t, i, r)
                                                            },
                                                            a = function(e) {
                                                                var t = e.type,
                                                                    i = (e.data || {}).url;
                                                                s("requestcompleted", {
                                                                    request_event_type: t,
                                                                    request_start: 0,
                                                                    request_response_start: 0,
                                                                    request_response_end: 0,
                                                                    request_bytes_loaded: -1,
                                                                    request_type: "manifest",
                                                                    request_hostname: p(i),
                                                                    request_url: i
                                                                })
                                                            };
                                                        i.on("manifestLoaded", a);
                                                        var o = {},
                                                            l = function(e) {
                                                                if ("function" != typeof e.getRequests) return null;
                                                                var t = e.getRequests({
                                                                    state: "executed"
                                                                });
                                                                return 0 === t.length ? null : t[t.length - 1]
                                                            },
                                                            c = function(e) {
                                                                var t = e.type,
                                                                    r = e.chunk,
                                                                    n = e.request,
                                                                    a = (r || {}).mediaInfo || {},
                                                                    l = a.type,
                                                                    c = a.bitrateList,
                                                                    d = {};
                                                                (c = c || []).forEach((function(e, t) {
                                                                    d[t] = {}, d[t].width = e.width, d[t].height = e.height, d[t].bitrate = e.bandwidth, d[t].attrs = {}
                                                                })), "video" === l ? o.video = d : "audio" === l ? o.audio = d : o.media = d;
                                                                var u = O(n, i),
                                                                    h = u.requestStart,
                                                                    f = u.requestResponseStart,
                                                                    m = u.requestResponseEnd,
                                                                    p = u.requestResponseHeaders,
                                                                    g = u.requestMediaDuration,
                                                                    y = u.requestHostname,
                                                                    v = u.requestUrl,
                                                                    b = u.requestId;
                                                                s("requestcompleted", {
                                                                    request_event_type: t,
                                                                    request_start: h,
                                                                    request_response_start: f,
                                                                    request_response_end: m,
                                                                    request_bytes_loaded: -1,
                                                                    request_type: l + "_init",
                                                                    request_response_headers: p,
                                                                    request_hostname: y,
                                                                    request_id: b,
                                                                    request_url: v,
                                                                    request_media_duration: g,
                                                                    request_rendition_lists: o
                                                                })
                                                            };
                                                        n >= 4 ? i.on("initFragmentLoaded", c) : i.on("initFragmentLoaded", (function(e) {
                                                            var t = e.type,
                                                                i = e.fragmentModel,
                                                                r = e.chunk,
                                                                n = l(i);
                                                            c({
                                                                type: t,
                                                                request: n,
                                                                chunk: r
                                                            })
                                                        }));
                                                        var d = function(e) {
                                                            var t = e.type,
                                                                r = e.chunk,
                                                                n = e.request,
                                                                a = r || {},
                                                                o = a.mediaInfo,
                                                                l = a.start,
                                                                c = (o || {}).type,
                                                                d = O(n, i),
                                                                u = d.requestStart,
                                                                h = d.requestResponseStart,
                                                                f = d.requestResponseEnd,
                                                                m = d.requestBytesLoaded,
                                                                p = d.requestResponseHeaders,
                                                                g = d.requestMediaDuration,
                                                                y = d.requestHostname,
                                                                v = d.requestUrl,
                                                                b = d.requestId,
                                                                T = function(e, t) {
                                                                    var i = t.getQualityFor(e),
                                                                        r = t.getCurrentTrackFor(e).bitrateList;
                                                                    return r ? {
                                                                        currentLevel: i,
                                                                        renditionWidth: r[i].width || null,
                                                                        renditionHeight: r[i].height || null,
                                                                        renditionBitrate: r[i].bandwidth
                                                                    } : {}
                                                                }(c, i),
                                                                E = T.currentLevel,
                                                                A = T.renditionWidth,
                                                                w = T.renditionHeight,
                                                                _ = T.renditionBitrate;
                                                            s("requestcompleted", {
                                                                request_event_type: t,
                                                                request_start: u,
                                                                request_response_start: h,
                                                                request_response_end: f,
                                                                request_bytes_loaded: m,
                                                                request_type: c,
                                                                request_response_headers: p,
                                                                request_hostname: y,
                                                                request_id: b,
                                                                request_url: v,
                                                                request_media_start_time: l,
                                                                request_media_duration: g,
                                                                request_current_level: E,
                                                                request_labeled_bitrate: _,
                                                                request_video_width: A,
                                                                request_video_height: w
                                                            })
                                                        };
                                                        n >= 4 ? i.on("mediaFragmentLoaded", d) : i.on("mediaFragmentLoaded", (function(e) {
                                                            var t = e.type,
                                                                i = e.fragmentModel,
                                                                r = e.chunk,
                                                                n = l(i);
                                                            d({
                                                                type: t,
                                                                request: n,
                                                                chunk: r
                                                            })
                                                        }));
                                                        var u = {
                                                                video: void 0,
                                                                audio: void 0,
                                                                totalBitrate: void 0
                                                            },
                                                            h = function(e, t, n) {
                                                                if ("number" == typeof e.newQuality) {
                                                                    var a = e.mediaType;
                                                                    if ("audio" === a || "video" === a) {
                                                                        var o = i.getBitrateInfoListFor(a).find((function(t) {
                                                                            return t.qualityIndex === e.newQuality
                                                                        }));
                                                                        if (o && "number" == typeof o.bitrate) {
                                                                            u[a] = P(P({}, o), {}, {
                                                                                codec: i.getCurrentTrackFor(a).codec
                                                                            });
                                                                            var l = function() {
                                                                                if (u.video && "number" == typeof u.video.bitrate) {
                                                                                    if (u.video.width && u.video.height) {
                                                                                        var e = u.video.bitrate;
                                                                                        return u.audio && "number" == typeof u.audio.bitrate && (e += u.audio.bitrate), e !== u.totalBitrate ? (u.totalBitrate = e, {
                                                                                            video_source_bitrate: e,
                                                                                            video_source_height: u.video.height,
                                                                                            video_source_width: u.video.width,
                                                                                            video_source_codec: M(u.video.codec)
                                                                                        }) : void 0
                                                                                    }
                                                                                    r.warn("have bitrate info for video but missing width/height")
                                                                                }
                                                                            }();
                                                                            l && s("renditionchange", l)
                                                                        } else r.warn("missing bitrate info for ".concat(a))
                                                                    }
                                                                } else r.warn("missing evt.newQuality in qualityChangeRendered event", e)
                                                            };
                                                        i.on("qualityChangeRendered", h);
                                                        var f = function(e) {
                                                            var t = e.request,
                                                                i = e.mediaType;
                                                            s("requestcanceled", {
                                                                request_event_type: (t = t || {}).type + "_" + t.action,
                                                                request_url: t.url,
                                                                request_type: i,
                                                                request_hostname: p(t.url)
                                                            })
                                                        };
                                                        i.on("fragmentLoadingAbandoned", f);
                                                        var m = function(e) {
                                                            var t, i, r = e.error,
                                                                n = (null == r || null === (t = r.data) || void 0 === t ? void 0 : t.request) || {},
                                                                a = (null == r || null === (i = r.data) || void 0 === i ? void 0 : i.response) || {};
                                                            27 === (null == r ? void 0 : r.code) && s("requestfailed", {
                                                                request_error: n.type + "_" + n.action,
                                                                request_url: n.url,
                                                                request_hostname: p(n.url),
                                                                request_type: n.mediaType,
                                                                request_error_code: a.status,
                                                                request_error_text: a.statusText
                                                            });
                                                            var o = "".concat(null != n && n.url ? "url: ".concat(n.url, "\n") : "") + "".concat(null != a && a.status || null != a && a.statusText ? "response: ".concat(null == a ? void 0 : a.status, ", ").concat(null == a ? void 0 : a.statusText, "\n") : "");
                                                            s("error", {
                                                                player_error_code: null == r ? void 0 : r.code,
                                                                player_error_message: null == r ? void 0 : r.message,
                                                                player_error_context: o
                                                            })
                                                        };
                                                        i.on("error", m), i._stopMuxMonitor = function() {
                                                            i.off("manifestLoaded", a), i.off("initFragmentLoaded", c), i.off("mediaFragmentLoaded", d), i.off("qualityChangeRendered", h), i.off("error", m), i.off("fragmentLoadingAbandoned", f), delete i._stopMuxMonitor
                                                        }
                                                    } else r.warn("Invalid dash.js player reference. Monitoring blocked.")
                                                }(this.mux, this.id, e.dashjs)) : this.mux.log.warn("You must pass a valid dashjs instance in order to track it.")
                                            }
                                        }, {
                                            key: "removeDashJS",
                                            value: function() {
                                                var e;
                                                this.dashjs && ((e = this.dashjs) && "function" == typeof e._stopMuxMonitor && e._stopMuxMonitor(), this.dashjs = void 0)
                                            }
                                        }], i && tt(t.prototype, i), Object.defineProperty(t, "prototype", {
                                            writable: !1
                                        }), n
                                    }(U),
                                    lt = ot,
                                    ct = i(153),
                                    dt = i.n(ct);

                                function ut(e) {
                                    return ut = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                        return typeof e
                                    } : function(e) {
                                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                                    }, ut(e)
                                }

                                function ht(e, t) {
                                    return function(e) {
                                        if (Array.isArray(e)) return e
                                    }(e) || function(e, t) {
                                        var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                        if (null != i) {
                                            var r, n, s = [],
                                                a = !0,
                                                o = !1;
                                            try {
                                                for (i = i.call(e); !(a = (r = i.next()).done) && (s.push(r.value), !t || s.length !== t); a = !0);
                                            } catch (e) {
                                                o = !0, n = e
                                            } finally {
                                                try {
                                                    a || null == i.return || i.return()
                                                } finally {
                                                    if (o) throw n
                                                }
                                            }
                                            return s
                                        }
                                    }(e, t) || function(e, t) {
                                        if (e) {
                                            if ("string" == typeof e) return ft(e, t);
                                            var i = Object.prototype.toString.call(e).slice(8, -1);
                                            return "Object" === i && e.constructor && (i = e.constructor.name), "Map" === i || "Set" === i ? Array.from(e) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? ft(e, t) : void 0
                                        }
                                    }(e, t) || function() {
                                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }()
                                }

                                function ft(e, t) {
                                    (null == t || t > e.length) && (t = e.length);
                                    for (var i = 0, r = new Array(t); i < t; i++) r[i] = e[i];
                                    return r
                                }
                                var mt, pt = ["loadstart", "pause", "play", "playing", "seeking", "seeked", "timeupdate", "ratechange", "stalled", "waiting", "error", "ended"],
                                    gt = {
                                        1: "MEDIA_ERR_ABORTED",
                                        2: "MEDIA_ERR_NETWORK",
                                        3: "MEDIA_ERR_DECODE",
                                        4: "MEDIA_ERR_SRC_NOT_SUPPORTED"
                                    };
                                n() && n().WeakMap && (mt = new WeakMap);
                                var yt = function(e) {
                                    return this.buffer = "", this.manifest = {
                                        segments: [],
                                        serverControl: {},
                                        sessionData: {}
                                    }, this.currentUri = {}, this.process(e), this.manifest
                                };
                                yt.prototype.process = function(e) {
                                    var t;
                                    for (this.buffer += e, t = this.buffer.indexOf("\n"); t > -1; t = this.buffer.indexOf("\n")) this.processLine(this.buffer.substring(0, t)), this.buffer = this.buffer.substring(t + 1)
                                }, yt.prototype.processLine = function(e) {
                                    var t = e.indexOf(":"),
                                        i = _t(e, t),
                                        r = i[0],
                                        n = 2 === i.length ? Tt(i[1]) : void 0;
                                    if ("#" !== r[0]) this.currentUri.uri = r, this.manifest.segments.push(this.currentUri), this.manifest.targetDuration && !("duration" in this.currentUri) && (this.currentUri.duration = this.manifest.targetDuration), this.currentUri = {};
                                    else switch (r) {
                                        case "#EXT-X-TARGETDURATION":
                                            if (!isFinite(n) || n < 0) return;
                                            this.manifest.targetDuration = n, this.setHoldBack();
                                            break;
                                        case "#EXT-X-PART-INF":
                                            vt(this.manifest, i), this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget), this.setHoldBack();
                                            break;
                                        case "#EXT-X-SERVER-CONTROL":
                                            vt(this.manifest, i), this.setHoldBack();
                                            break;
                                        case "#EXTINF":
                                            0 === n ? this.currentUri.duration = .01 : n > 0 && (this.currentUri.duration = n);
                                            break;
                                        case "#EXT-X-PROGRAM-DATE-TIME":
                                            var s = n,
                                                a = new Date(s);
                                            this.manifest.dateTimeString || (this.manifest.dateTimeString = s, this.manifest.dateTimeObject = a), this.currentUri.dateTimeString = s, this.currentUri.dateTimeObject = a;
                                            break;
                                        case "#EXT-X-VERSION":
                                            vt(this.manifest, i);
                                            break;
                                        case "#EXT-X-SESSION-DATA":
                                            var o = kt(i[1]),
                                                l = k(o);
                                            Object.assign(this.manifest.sessionData, l)
                                    }
                                }, yt.prototype.setHoldBack = function() {
                                    var e = this.manifest,
                                        t = e.serverControl,
                                        i = e.targetDuration,
                                        r = e.partTargetDuration;
                                    if (t) {
                                        var n = "holdBack",
                                            s = "partHoldBack",
                                            a = i && 3 * i,
                                            o = r && 2 * r;
                                        i && !t.hasOwnProperty(n) && (t[n] = a), a && t[n] < a && (t[n] = a), r && !t.hasOwnProperty(s) && (t[s] = 3 * r), r && t[s] < o && (t[s] = o)
                                    }
                                };
                                var vt = function(e, t) {
                                        var i, r = bt(t[0].replace("#EXT-X-", ""));
                                        wt(t[1]) ? (i = {}, i = Object.assign(At(t[1]), i)) : i = Tt(t[1]), e[r] = i
                                    },
                                    bt = function(e) {
                                        return e.toLowerCase().replace(/-(\w)/g, (function(e) {
                                            return e[1].toUpperCase()
                                        }))
                                    },
                                    Tt = function(e) {
                                        if ("yes" === e.toLowerCase() || "no" === e.toLowerCase()) return "yes" === e.toLowerCase();
                                        var t = -1 !== e.indexOf(":") ? e : parseFloat(e);
                                        return isNaN(t) ? e : t
                                    },
                                    Et = function(e) {
                                        var t = {},
                                            i = e.split("=");
                                        return i.length > 1 && (t[bt(i[0])] = Tt(i[1])), t
                                    },
                                    At = function(e) {
                                        for (var t = e.split(","), i = {}, r = 0; t.length > r; r++) {
                                            var n = t[r],
                                                s = Et(n);
                                            i = Object.assign(s, i)
                                        }
                                        return i
                                    },
                                    wt = function(e) {
                                        return e.indexOf("=") > -1
                                    },
                                    _t = function(e, t) {
                                        return -1 === t ? [e] : [e.substring(0, t), e.substring(t + 1)]
                                    },
                                    kt = function(e) {
                                        var t = {};
                                        if (e) {
                                            var i = e.search(",");
                                            return [e.slice(0, i), e.slice(i + 1)].forEach((function(e, i) {
                                                for (var r = e.replace(/['"]+/g, "").split("="), n = 0; n < r.length; n++) "DATA-ID" === r[n] && (t["DATA-ID"] = r[1 - n]), "VALUE" === r[n] && (t.VALUE = r[1 - n])
                                            })), {
                                                data: t
                                            }
                                        }
                                    },
                                    St = yt,
                                    Lt = {
                                        safeCall: function(e, t, i, r) {
                                            var n = r;
                                            if (e && "function" == typeof e[t]) try {
                                                n = e[t].apply(e, i)
                                            } catch (e) {
                                                h.info("safeCall error", e)
                                            }
                                            return n
                                        },
                                        safeIncrement: T,
                                        getComputedStyle: function(e, t) {
                                            var i;
                                            if (e && t && n() && "function" == typeof n().getComputedStyle) return mt && mt.has(e) && (i = mt.get(e)), i || (i = n().getComputedStyle(e, null), mt && mt.set(e, i)), i.getPropertyValue(t)
                                        },
                                        secondsToMs: function(e) {
                                            return Math.floor(1e3 * e)
                                        },
                                        assign: Object.assign,
                                        headersStringToObject: w,
                                        cdnHeadersToRequestId: _,
                                        extractHostnameAndDomain: g,
                                        extractHostname: p,
                                        manifestParser: St,
                                        generateShortID: a,
                                        generateUUID: s,
                                        now: m.now
                                    };

                                function Rt(e, t) {
                                    (null == t || t > e.length) && (t = e.length);
                                    for (var i = 0, r = new Array(t); i < t; i++) r[i] = e[i];
                                    return r
                                }
                                var Dt = {},
                                    Ct = function e(t) {
                                        var i = arguments;
                                        "string" == typeof t ? e.hasOwnProperty(t) ? n().setTimeout((function() {
                                            i = Array.prototype.splice.call(i, 1), e[t].apply(null, i)
                                        }), 0) : h.warn("`" + t + "` is an unknown task") : "function" == typeof t ? n().setTimeout((function() {
                                            t(e)
                                        }), 0) : h.warn("`" + t + "` is invalid.")
                                    },
                                    It = {
                                        loaded: m.now(),
                                        NAME: "mux-embed",
                                        VERSION: "4.30.0",
                                        API_VERSION: "2.1",
                                        PLAYER_TRACKED: !1,
                                        monitor: function(e, t) {
                                            return function(e, t, i) {
                                                var r = ht(l(t), 3),
                                                    n = r[0],
                                                    s = r[1],
                                                    a = r[2],
                                                    o = e.log,
                                                    c = e.utils.getComputedStyle,
                                                    d = e.utils.secondsToMs;
                                                if (!n) return o.error("No element was found with the `" + s + "` query selector.");
                                                if ("video" !== a && "audio" !== a) return o.error("The element of `" + s + "` was not a media element.");
                                                n.mux && (n.mux.destroy(), delete n.mux, o.warn("Already monitoring this video element, replacing existing event listeners")), (i = Object.assign({
                                                    automaticErrorTracking: !0
                                                }, i)).data = Object.assign({
                                                    player_software: "HTML5 Video Element",
                                                    player_mux_plugin_name: "VideoElementMonitor",
                                                    player_mux_plugin_version: e.VERSION
                                                }, i.data), i.getPlayheadTime = function() {
                                                    return d(n.currentTime)
                                                }, i.getStateData = function() {
                                                    var e, t, r = this.hlsjs && this.hlsjs.url,
                                                        s = this.dashjs && ut("function" === this.dashjs.getSource) && this.dashjs.getSource(),
                                                        a = {
                                                            player_is_paused: n.paused,
                                                            player_playhead_time: d(n.currentTime),
                                                            player_width: parseInt(c(n, "width")),
                                                            player_height: parseInt(c(n, "height")),
                                                            player_autoplay_on: n.autoplay,
                                                            player_preload_on: n.preload,
                                                            player_language_code: n.lang,
                                                            player_is_fullscreen: dt() && !!(dt().fullscreenElement || dt().webkitFullscreenElement || dt().mozFullScreenElement || dt().msFullscreenElement),
                                                            video_poster_url: n.poster,
                                                            video_source_url: r || s || n.currentSrc,
                                                            video_source_duration: d(n.duration),
                                                            video_source_height: n.videoHeight,
                                                            video_source_width: n.videoWidth,
                                                            view_dropped_frame_count: null === (e = n) || void 0 === e || null === (t = e.getVideoPlaybackQuality) || void 0 === t ? void 0 : t.call(e).droppedVideoFrames
                                                        },
                                                        o = i.getPlayheadTime();
                                                    if (n.getStartDate && o > 0) {
                                                        var l = n.getStartDate();
                                                        if (l && "function" == typeof l.getTime && l.getTime()) {
                                                            var u = l.getTime();
                                                            if (a.player_program_time = u + o, n.seekable.length > 0) {
                                                                var h = u + n.seekable.end(n.seekable.length - 1);
                                                                a.player_live_edge_program_time = h
                                                            }
                                                        }
                                                    }
                                                    return a
                                                }, n.mux = n.mux || {}, n.mux.deleted = !1, n.mux.emit = function(t, i) {
                                                    e.emit(s, t, i)
                                                };
                                                var u = function() {
                                                    o.error("The monitor for this video element has already been destroyed.")
                                                };
                                                n.mux.destroy = function() {
                                                    Object.keys(n.mux.listeners).forEach((function(e) {
                                                        n.removeEventListener(e, n.mux.listeners[e], !1)
                                                    })), delete n.mux.listeners, n.mux.destroy = u, n.mux.swapElement = u, n.mux.emit = u, n.mux.addHLSJS = u, n.mux.addDashJS = u, n.mux.removeHLSJS = u, n.mux.removeDashJS = u, n.mux.deleted = !0, e.emit(s, "destroy")
                                                }, n.mux.swapElement = function(t) {
                                                    var i = ht(l(t), 3),
                                                        r = i[0],
                                                        s = i[1],
                                                        a = i[2];
                                                    return r ? "video" !== a && "audio" !== a ? e.log.error("The element of `" + s + "` was not a media element.") : (r.muxId = n.muxId, delete n.muxId, r.mux = r.mux || {}, r.mux.listeners = Object.assign({}, n.mux.listeners), delete n.mux.listeners, Object.keys(r.mux.listeners).forEach((function(e) {
                                                        n.removeEventListener(e, r.mux.listeners[e], !1), r.addEventListener(e, r.mux.listeners[e], !1)
                                                    })), r.mux.swapElement = n.mux.swapElement, r.mux.destroy = n.mux.destroy, delete n.mux, void(n = r)) : e.log.error("No element was found with the `" + s + "` query selector.")
                                                }, n.mux.addHLSJS = function(t) {
                                                    e.addHLSJS(s, t)
                                                }, n.mux.addDashJS = function(t) {
                                                    e.addDashJS(s, t)
                                                }, n.mux.removeHLSJS = function() {
                                                    e.removeHLSJS(s)
                                                }, n.mux.removeDashJS = function() {
                                                    e.removeDashJS(s)
                                                }, e.init(s, i), e.emit(s, "playerready"), n.paused || (e.emit(s, "play"), n.readyState > 2 && e.emit(s, "playing")), n.mux.listeners = {}, pt.forEach((function(t) {
                                                    ("error" !== t || i.automaticErrorTracking) && (n.mux.listeners[t] = function() {
                                                        var i = {};
                                                        if ("error" === t) {
                                                            if (!n.error) return;
                                                            if (1 === n.error.code) return;
                                                            i.player_error_code = n.error.code, i.player_error_message = gt[n.error.code] || n.error.message
                                                        }
                                                        e.emit(s, t, i)
                                                    }, n.addEventListener(t, n.mux.listeners[t], !1))
                                                }))
                                            }(Ct, e, t)
                                        },
                                        destroyMonitor: function(e) {
                                            var t = function(e, t) {
                                                return function(e) {
                                                    if (Array.isArray(e)) return e
                                                }(e) || function(e, t) {
                                                    var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                                    if (null != i) {
                                                        var r, n, s = [],
                                                            a = !0,
                                                            o = !1;
                                                        try {
                                                            for (i = i.call(e); !(a = (r = i.next()).done) && (s.push(r.value), !t || s.length !== t); a = !0);
                                                        } catch (e) {
                                                            o = !0, n = e
                                                        } finally {
                                                            try {
                                                                a || null == i.return || i.return()
                                                            } finally {
                                                                if (o) throw n
                                                            }
                                                        }
                                                        return s
                                                    }
                                                }(e, t) || function(e, t) {
                                                    if (e) {
                                                        if ("string" == typeof e) return Rt(e, t);
                                                        var i = Object.prototype.toString.call(e).slice(8, -1);
                                                        return "Object" === i && e.constructor && (i = e.constructor.name), "Map" === i || "Set" === i ? Array.from(e) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Rt(e, t) : void 0
                                                    }
                                                }(e, t) || function() {
                                                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                                }()
                                            }(l(e), 1)[0];
                                            t && t.mux && "function" == typeof t.mux.destroy ? t.mux.destroy() : h.error("A video element monitor for `" + e + "` has not been initialized via `mux.monitor`.")
                                        },
                                        addHLSJS: function(e, t) {
                                            var i = o(e);
                                            Dt[i] ? Dt[i].addHLSJS(t) : h.error("A monitor for `" + i + "` has not been initialized.")
                                        },
                                        addDashJS: function(e, t) {
                                            var i = o(e);
                                            Dt[i] ? Dt[i].addDashJS(t) : h.error("A monitor for `" + i + "` has not been initialized.")
                                        },
                                        removeHLSJS: function(e) {
                                            var t = o(e);
                                            Dt[t] ? Dt[t].removeHLSJS() : h.error("A monitor for `" + t + "` has not been initialized.")
                                        },
                                        removeDashJS: function(e) {
                                            var t = o(e);
                                            Dt[t] ? Dt[t].removeDashJS() : h.error("A monitor for `" + t + "` has not been initialized.")
                                        },
                                        init: function(e, t) {
                                            f() && t && t.respectDoNotTrack && h.info("The browser's Do Not Track flag is enabled - Mux beaconing is disabled.");
                                            var i = o(e);
                                            Dt[i] = new lt(Ct, i, t)
                                        },
                                        emit: function(e, t, i) {
                                            var r = o(e);
                                            Dt[r] ? (Dt[r].emit(t, i), "destroy" === t && delete Dt[r]) : h.error("A monitor for `" + r + "` has not been initialized.")
                                        },
                                        checkDoNotTrack: f,
                                        log: h,
                                        utils: Lt,
                                        events: {
                                            PLAYER_READY: "playerready",
                                            VIEW_INIT: "viewinit",
                                            VIDEO_CHANGE: "videochange",
                                            PLAY: "play",
                                            PAUSE: "pause",
                                            PLAYING: "playing",
                                            TIME_UPDATE: "timeupdate",
                                            SEEKING: "seeking",
                                            SEEKED: "seeked",
                                            REBUFFER_START: "rebufferstart",
                                            REBUFFER_END: "rebufferend",
                                            ERROR: "error",
                                            ENDED: "ended",
                                            RENDITION_CHANGE: "renditionchange",
                                            ORIENTATION_CHANGE: "orientationchange",
                                            AD_REQUEST: "adrequest",
                                            AD_RESPONSE: "adresponse",
                                            AD_BREAK_START: "adbreakstart",
                                            AD_PLAY: "adplay",
                                            AD_PLAYING: "adplaying",
                                            AD_PAUSE: "adpause",
                                            AD_FIRST_QUARTILE: "adfirstquartile",
                                            AD_MID_POINT: "admidpoint",
                                            AD_THIRD_QUARTILE: "adthirdquartile",
                                            AD_ENDED: "adended",
                                            AD_BREAK_END: "adbreakend",
                                            AD_ERROR: "aderror",
                                            REQUEST_COMPLETED: "requestcompleted",
                                            REQUEST_FAILED: "requestfailed",
                                            REQUEST_CANCELLED: "requestcanceled"
                                        },
                                        WINDOW_HIDDEN: !1,
                                        WINDOW_UNLOADING: !1
                                    };
                                Object.assign(Ct, It), void 0 !== n() && "function" == typeof n().addEventListener && n().addEventListener("pagehide", (function(e) {
                                    e.persisted || (Ct.WINDOW_UNLOADING = !0)
                                }), !1);
                                var Pt = Ct
                            },
                            655: function(e, t, i) {
                                var r, n;

                                function s(e) {
                                    return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                        return typeof e
                                    } : function(e) {
                                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                                    }, s(e)
                                }! function(a) {
                                    var o = !1;
                                    if (void 0 === (n = "function" == typeof(r = a) ? r.call(t, i, t, e) : r) || (e.exports = n), o = !0, "object" === s(t) && (e.exports = a(), o = !0), !o) {
                                        var l = window.Cookies,
                                            c = window.Cookies = a();
                                        c.noConflict = function() {
                                            return window.Cookies = l, c
                                        }
                                    }
                                }((function() {
                                    var e = function() {
                                        for (var e = 0, t = {}; e < arguments.length; e++) {
                                            var i = arguments[e];
                                            for (var r in i) t[r] = i[r]
                                        }
                                        return t
                                    };
                                    return function t(i) {
                                        function r(t, n, s) {
                                            var a;
                                            if ("undefined" != typeof document) {
                                                if (arguments.length > 1) {
                                                    if ("number" == typeof(s = e({
                                                            path: "/"
                                                        }, r.defaults, s)).expires) {
                                                        var o = new Date;
                                                        o.setMilliseconds(o.getMilliseconds() + 864e5 * s.expires), s.expires = o
                                                    }
                                                    try {
                                                        a = JSON.stringify(n), /^[\{\[]/.test(a) && (n = a)
                                                    } catch (e) {}
                                                    return n = i.write ? i.write(n, t) : encodeURIComponent(String(n)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), t = (t = (t = encodeURIComponent(String(t))).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)).replace(/[\(\)]/g, escape), document.cookie = [t, "=", n, s.expires ? "; expires=" + s.expires.toUTCString() : "", s.path ? "; path=" + s.path : "", s.domain ? "; domain=" + s.domain : "", s.secure ? "; secure" : ""].join("")
                                                }
                                                t || (a = {});
                                                for (var l = document.cookie ? document.cookie.split("; ") : [], c = /(%[0-9A-Z]{2})+/g, d = 0; d < l.length; d++) {
                                                    var u = l[d].split("="),
                                                        h = u.slice(1).join("=");
                                                    '"' === h.charAt(0) && (h = h.slice(1, -1));
                                                    try {
                                                        var f = u[0].replace(c, decodeURIComponent);
                                                        if (h = i.read ? i.read(h, f) : i(h, f) || h.replace(c, decodeURIComponent), this.json) try {
                                                            h = JSON.parse(h)
                                                        } catch (e) {}
                                                        if (t === f) {
                                                            a = h;
                                                            break
                                                        }
                                                        t || (a[f] = h)
                                                    } catch (e) {}
                                                }
                                                return a
                                            }
                                        }
                                        return r.set = r, r.get = function(e) {
                                            return r.call(r, e)
                                        }, r.getJSON = function() {
                                            return r.apply({
                                                json: !0
                                            }, [].slice.call(arguments))
                                        }, r.defaults = {}, r.remove = function(t, i) {
                                            r(t, "", e(i, {
                                                expires: -1
                                            }))
                                        }, r.withConverter = t, r
                                    }((function() {}))
                                }))
                            },
                            153: function(e, t, i) {
                                var r, n = void 0 !== i.g ? i.g : "undefined" != typeof window ? window : {},
                                    s = i(558);
                                "undefined" != typeof document ? r = document : (r = n["__GLOBAL_DOCUMENT_CACHE@4"]) || (r = n["__GLOBAL_DOCUMENT_CACHE@4"] = s), e.exports = r
                            },
                            48: function(e, t, i) {
                                var r;
                                r = "undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self ? self : {}, e.exports = r
                            },
                            640: function(e, t, i) {
                                var r, n;
                                ! function(s, a) {
                                    "use strict";
                                    r = function() {
                                        var e = function() {},
                                            t = "undefined",
                                            i = typeof window !== t && typeof window.navigator !== t && /Trident\/|MSIE /.test(window.navigator.userAgent),
                                            r = ["trace", "debug", "info", "warn", "error"];

                                        function n(e, t) {
                                            var i = e[t];
                                            if ("function" == typeof i.bind) return i.bind(e);
                                            try {
                                                return Function.prototype.bind.call(i, e)
                                            } catch (t) {
                                                return function() {
                                                    return Function.prototype.apply.apply(i, [e, arguments])
                                                }
                                            }
                                        }

                                        function s() {
                                            console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace()
                                        }

                                        function a(r) {
                                            return "debug" === r && (r = "log"), typeof console !== t && ("trace" === r && i ? s : void 0 !== console[r] ? n(console, r) : void 0 !== console.log ? n(console, "log") : e)
                                        }

                                        function o(t, i) {
                                            for (var n = 0; n < r.length; n++) {
                                                var s = r[n];
                                                this[s] = n < t ? e : this.methodFactory(s, t, i)
                                            }
                                            this.log = this.debug
                                        }

                                        function l(e, i, r) {
                                            return function() {
                                                typeof console !== t && (o.call(this, i, r), this[e].apply(this, arguments))
                                            }
                                        }

                                        function c(e, t, i) {
                                            return a(e) || l.apply(this, arguments)
                                        }

                                        function d(e, i, n) {
                                            var s, a = this;
                                            i = null == i ? "WARN" : i;
                                            var l = "loglevel";

                                            function d(e) {
                                                var i = (r[e] || "silent").toUpperCase();
                                                if (typeof window !== t && l) {
                                                    try {
                                                        return void(window.localStorage[l] = i)
                                                    } catch (e) {}
                                                    try {
                                                        window.document.cookie = encodeURIComponent(l) + "=" + i + ";"
                                                    } catch (e) {}
                                                }
                                            }

                                            function u() {
                                                var e;
                                                if (typeof window !== t && l) {
                                                    try {
                                                        e = window.localStorage[l]
                                                    } catch (e) {}
                                                    if (typeof e === t) try {
                                                        var i = window.document.cookie,
                                                            r = i.indexOf(encodeURIComponent(l) + "="); - 1 !== r && (e = /^([^;]+)/.exec(i.slice(r))[1])
                                                    } catch (e) {}
                                                    return void 0 === a.levels[e] && (e = void 0), e
                                                }
                                            }
                                            "string" == typeof e ? l += ":" + e : "symbol" == typeof e && (l = void 0), a.name = e, a.levels = {
                                                TRACE: 0,
                                                DEBUG: 1,
                                                INFO: 2,
                                                WARN: 3,
                                                ERROR: 4,
                                                SILENT: 5
                                            }, a.methodFactory = n || c, a.getLevel = function() {
                                                return s
                                            }, a.setLevel = function(i, r) {
                                                if ("string" == typeof i && void 0 !== a.levels[i.toUpperCase()] && (i = a.levels[i.toUpperCase()]), !("number" == typeof i && i >= 0 && i <= a.levels.SILENT)) throw "log.setLevel() called with invalid level: " + i;
                                                if (s = i, !1 !== r && d(i), o.call(a, i, e), typeof console === t && i < a.levels.SILENT) return "No console available for logging"
                                            }, a.setDefaultLevel = function(e) {
                                                i = e, u() || a.setLevel(e, !1)
                                            }, a.resetLevel = function() {
                                                a.setLevel(i, !1),
                                                    function() {
                                                        if (typeof window !== t && l) {
                                                            try {
                                                                return void window.localStorage.removeItem(l)
                                                            } catch (e) {}
                                                            try {
                                                                window.document.cookie = encodeURIComponent(l) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC"
                                                            } catch (e) {}
                                                        }
                                                    }()
                                            }, a.enableAll = function(e) {
                                                a.setLevel(a.levels.TRACE, e)
                                            }, a.disableAll = function(e) {
                                                a.setLevel(a.levels.SILENT, e)
                                            };
                                            var h = u();
                                            null == h && (h = i), a.setLevel(h, !1)
                                        }
                                        var u = new d,
                                            h = {};
                                        u.getLogger = function(e) {
                                            if ("symbol" != typeof e && "string" != typeof e || "" === e) throw new TypeError("You must supply a name when creating a logger.");
                                            var t = h[e];
                                            return t || (t = h[e] = new d(e, u.getLevel(), u.methodFactory)), t
                                        };
                                        var f = typeof window !== t ? window.log : void 0;
                                        return u.noConflict = function() {
                                            return typeof window !== t && window.log === u && (window.log = f), u
                                        }, u.getLoggers = function() {
                                            return h
                                        }, u.default = u, u
                                    }, void 0 === (n = r.call(t, i, t, e)) || (e.exports = n)
                                }()
                            },
                            375: function(e, t) {
                                "use strict";
                                var i = Object.prototype.hasOwnProperty;

                                function r(e) {
                                    try {
                                        return decodeURIComponent(e.replace(/\+/g, " "))
                                    } catch (e) {
                                        return null
                                    }
                                }

                                function n(e) {
                                    try {
                                        return encodeURIComponent(e)
                                    } catch (e) {
                                        return null
                                    }
                                }
                                t.stringify = function(e, t) {
                                    t = t || "";
                                    var r, s, a = [];
                                    for (s in "string" != typeof t && (t = "?"), e)
                                        if (i.call(e, s)) {
                                            if ((r = e[s]) || null != r && !isNaN(r) || (r = ""), s = n(s), r = n(r), null === s || null === r) continue;
                                            a.push(s + "=" + r)
                                        }
                                    return a.length ? t + a.join("&") : ""
                                }, t.parse = function(e) {
                                    for (var t, i = /([^=?#&]+)=?([^&]*)/g, n = {}; t = i.exec(e);) {
                                        var s = r(t[1]),
                                            a = r(t[2]);
                                        null === s || null === a || s in n || (n[s] = a)
                                    }
                                    return n
                                }
                            },
                            558: function() {}
                        },
                        t = {};

                    function i(r) {
                        var n = t[r];
                        if (void 0 !== n) return n.exports;
                        var s = t[r] = {
                            exports: {}
                        };
                        return e[r].call(s.exports, s, s.exports, i), s.exports
                    }
                    return i.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default
                        } : function() {
                            return e
                        };
                        return i.d(t, {
                            a: t
                        }), t
                    }, i.d = function(e, t) {
                        for (var r in t) i.o(t, r) && !i.o(e, r) && Object.defineProperty(e, r, {
                            enumerable: !0,
                            get: t[r]
                        })
                    }, i.g = function() {
                        if ("object" == typeof globalThis) return globalThis;
                        try {
                            return this || new Function("return this")()
                        } catch (e) {
                            if ("object" == typeof window) return window
                        }
                    }(), i.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }, i(80)
                }()
            }, e.exports = t()
        },
        34330: function(e, t, i) {
            "object" == typeof navigator && (e.exports = function() {
                "use strict";

                function e(e, t, i) {
                    return (t = function(e) {
                        var t = function(e, t) {
                            if ("object" != typeof e || null === e) return e;
                            var i = e[Symbol.toPrimitive];
                            if (void 0 !== i) {
                                var r = i.call(e, t || "default");
                                if ("object" != typeof r) return r;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }
                            return ("string" === t ? String : Number)(e)
                        }(e, "string");
                        return "symbol" == typeof t ? t : String(t)
                    }(t)) in e ? Object.defineProperty(e, t, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = i, e
                }

                function t(e, t) {
                    for (var i = 0; i < t.length; i++) {
                        var r = t[i];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                    }
                }

                function r(e, t, i) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = i, e
                }

                function n(e, t) {
                    var i = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                        var r = Object.getOwnPropertySymbols(e);
                        t && (r = r.filter((function(t) {
                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                        }))), i.push.apply(i, r)
                    }
                    return i
                }

                function s(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var i = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? n(Object(i), !0).forEach((function(t) {
                            r(e, t, i[t])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : n(Object(i)).forEach((function(t) {
                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
                        }))
                    }
                    return e
                }
                var a = {
                        addCSS: !0,
                        thumbWidth: 15,
                        watch: !0
                    },
                    o = function(e) {
                        return null != e ? e.constructor : null
                    },
                    l = function(e, t) {
                        return !!(e && t && e instanceof t)
                    },
                    c = function(e) {
                        return null == e
                    },
                    d = function(e) {
                        return o(e) === Object
                    },
                    u = function(e) {
                        return o(e) === String
                    },
                    h = function(e) {
                        return Array.isArray(e)
                    },
                    f = function(e) {
                        return l(e, NodeList)
                    },
                    m = {
                        nullOrUndefined: c,
                        object: d,
                        number: function(e) {
                            return o(e) === Number && !Number.isNaN(e)
                        },
                        string: u,
                        boolean: function(e) {
                            return o(e) === Boolean
                        },
                        function: function(e) {
                            return o(e) === Function
                        },
                        array: h,
                        nodeList: f,
                        element: function(e) {
                            return l(e, Element)
                        },
                        event: function(e) {
                            return l(e, Event)
                        },
                        empty: function(e) {
                            return c(e) || (u(e) || h(e) || f(e)) && !e.length || d(e) && !Object.keys(e).length
                        }
                    };

                function p(e, t) {
                    if (1 > t) {
                        var i = function(e) {
                            var t = "".concat(e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
                            return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0
                        }(t);
                        return parseFloat(e.toFixed(i))
                    }
                    return Math.round(e / t) * t
                }
                var g = function() {
                    function e(t, i) {
                        (function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        })(this, e), m.element(t) ? this.element = t : m.string(t) && (this.element = document.querySelector(t)), m.element(this.element) && m.empty(this.element.rangeTouch) && (this.config = s({}, a, {}, i), this.init())
                    }
                    return function(e, i, r) {
                        i && t(e.prototype, i), r && t(e, r)
                    }(e, [{
                        key: "init",
                        value: function() {
                            e.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            e.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null)
                        }
                    }, {
                        key: "listeners",
                        value: function(e) {
                            var t = this,
                                i = e ? "addEventListener" : "removeEventListener";
                            ["touchstart", "touchmove", "touchend"].forEach((function(e) {
                                t.element[i](e, (function(e) {
                                    return t.set(e)
                                }), !1)
                            }))
                        }
                    }, {
                        key: "get",
                        value: function(t) {
                            if (!e.enabled || !m.event(t)) return null;
                            var i, r = t.target,
                                n = t.changedTouches[0],
                                s = parseFloat(r.getAttribute("min")) || 0,
                                a = parseFloat(r.getAttribute("max")) || 100,
                                o = parseFloat(r.getAttribute("step")) || 1,
                                l = r.getBoundingClientRect(),
                                c = 100 / l.width * (this.config.thumbWidth / 2) / 100;
                            return 0 > (i = 100 / l.width * (n.clientX - l.left)) ? i = 0 : 100 < i && (i = 100), 50 > i ? i -= (100 - 2 * i) * c : 50 < i && (i += 2 * (i - 50) * c), s + p(i / 100 * (a - s), o)
                        }
                    }, {
                        key: "set",
                        value: function(t) {
                            e.enabled && m.event(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), function(e, t) {
                                if (e && t) {
                                    var i = new Event(t, {
                                        bubbles: !0
                                    });
                                    e.dispatchEvent(i)
                                }
                            }(t.target, "touchend" === t.type ? "change" : "input"))
                        }
                    }], [{
                        key: "setup",
                        value: function(t) {
                            var i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                                r = null;
                            if (m.empty(t) || m.string(t) ? r = Array.from(document.querySelectorAll(m.string(t) ? t : 'input[type="range"]')) : m.element(t) ? r = [t] : m.nodeList(t) ? r = Array.from(t) : m.array(t) && (r = t.filter(m.element)), m.empty(r)) return null;
                            var n = s({}, a, {}, i);
                            if (m.string(t) && n.watch) {
                                var o = new MutationObserver((function(i) {
                                    Array.from(i).forEach((function(i) {
                                        Array.from(i.addedNodes).forEach((function(i) {
                                            m.element(i) && function(e, t) {
                                                return function() {
                                                    return Array.from(document.querySelectorAll(t)).includes(this)
                                                }.call(e, t)
                                            }(i, t) && new e(i, n)
                                        }))
                                    }))
                                }));
                                o.observe(document.body, {
                                    childList: !0,
                                    subtree: !0
                                })
                            }
                            return r.map((function(t) {
                                return new e(t, i)
                            }))
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return "ontouchstart" in document.documentElement
                        }
                    }]), e
                }();
                const y = e => null != e ? e.constructor : null,
                    v = (e, t) => Boolean(e && t && e instanceof t),
                    b = e => null == e,
                    T = e => y(e) === Object,
                    E = e => y(e) === String,
                    A = e => "function" == typeof e,
                    w = e => Array.isArray(e),
                    _ = e => v(e, NodeList),
                    k = e => b(e) || (E(e) || w(e) || _(e)) && !e.length || T(e) && !Object.keys(e).length;
                var S = {
                    nullOrUndefined: b,
                    object: T,
                    number: e => y(e) === Number && !Number.isNaN(e),
                    string: E,
                    boolean: e => y(e) === Boolean,
                    function: A,
                    array: w,
                    weakMap: e => v(e, WeakMap),
                    nodeList: _,
                    element: e => null !== e && "object" == typeof e && 1 === e.nodeType && "object" == typeof e.style && "object" == typeof e.ownerDocument,
                    textNode: e => y(e) === Text,
                    event: e => v(e, Event),
                    keyboardEvent: e => v(e, KeyboardEvent),
                    cue: e => v(e, window.TextTrackCue) || v(e, window.VTTCue),
                    track: e => v(e, TextTrack) || !b(e) && E(e.kind),
                    promise: e => v(e, Promise) && A(e.then),
                    url: e => {
                        if (v(e, window.URL)) return !0;
                        if (!E(e)) return !1;
                        let t = e;
                        e.startsWith("http://") && e.startsWith("https://") || (t = `http://${e}`);
                        try {
                            return !k(new URL(t).hostname)
                        } catch (e) {
                            return !1
                        }
                    },
                    empty: k
                };
                const L = (() => {
                    const e = document.createElement("span"),
                        t = {
                            WebkitTransition: "webkitTransitionEnd",
                            MozTransition: "transitionend",
                            OTransition: "oTransitionEnd otransitionend",
                            transition: "transitionend"
                        },
                        i = Object.keys(t).find((t => void 0 !== e.style[t]));
                    return !!S.string(i) && t[i]
                })();

                function R(e, t) {
                    setTimeout((() => {
                        try {
                            e.hidden = !0, e.offsetHeight, e.hidden = !1
                        } catch (e) {}
                    }), t)
                }
                var D = {
                    isIE: Boolean(window.document.documentMode),
                    isEdge: /Edge/g.test(navigator.userAgent),
                    isWebKit: "WebkitAppearance" in document.documentElement.style && !/Edge/g.test(navigator.userAgent),
                    isIPhone: /iPhone|iPod/gi.test(navigator.userAgent) && navigator.maxTouchPoints > 1,
                    isIPadOS: "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1,
                    isIos: /iPad|iPhone|iPod/gi.test(navigator.userAgent) && navigator.maxTouchPoints > 1
                };

                function C(e, t) {
                    return t.split(".").reduce(((e, t) => e && e[t]), e)
                }

                function I(e = {}, ...t) {
                    if (!t.length) return e;
                    const i = t.shift();
                    return S.object(i) ? (Object.keys(i).forEach((t => {
                        S.object(i[t]) ? (Object.keys(e).includes(t) || Object.assign(e, {
                            [t]: {}
                        }), I(e[t], i[t])) : Object.assign(e, {
                            [t]: i[t]
                        })
                    })), I(e, ...t)) : e
                }

                function P(e, t) {
                    const i = e.length ? e : [e];
                    Array.from(i).reverse().forEach(((e, i) => {
                        const r = i > 0 ? t.cloneNode(!0) : t,
                            n = e.parentNode,
                            s = e.nextSibling;
                        r.appendChild(e), s ? n.insertBefore(r, s) : n.appendChild(r)
                    }))
                }

                function x(e, t) {
                    S.element(e) && !S.empty(t) && Object.entries(t).filter((([, e]) => !S.nullOrUndefined(e))).forEach((([t, i]) => e.setAttribute(t, i)))
                }

                function O(e, t, i) {
                    const r = document.createElement(e);
                    return S.object(t) && x(r, t), S.string(i) && (r.innerText = i), r
                }

                function M(e, t, i, r) {
                    S.element(t) && t.appendChild(O(e, i, r))
                }

                function N(e) {
                    S.nodeList(e) || S.array(e) ? Array.from(e).forEach(N) : S.element(e) && S.element(e.parentNode) && e.parentNode.removeChild(e)
                }

                function F(e) {
                    if (!S.element(e)) return;
                    let {
                        length: t
                    } = e.childNodes;
                    for (; t > 0;) e.removeChild(e.lastChild), t -= 1
                }

                function B(e, t) {
                    return S.element(t) && S.element(t.parentNode) && S.element(e) ? (t.parentNode.replaceChild(e, t), e) : null
                }

                function U(e, t) {
                    if (!S.string(e) || S.empty(e)) return {};
                    const i = {},
                        r = I({}, t);
                    return e.split(",").forEach((e => {
                        const t = e.trim(),
                            n = t.replace(".", ""),
                            s = t.replace(/[[\]]/g, "").split("="),
                            [a] = s,
                            o = s.length > 1 ? s[1].replace(/["']/g, "") : "";
                        switch (t.charAt(0)) {
                            case ".":
                                S.string(r.class) ? i.class = `${r.class} ${n}` : i.class = n;
                                break;
                            case "#":
                                i.id = t.replace("#", "");
                                break;
                            case "[":
                                i[a] = o
                        }
                    })), I(r, i)
                }

                function $(e, t) {
                    if (!S.element(e)) return;
                    let i = t;
                    S.boolean(i) || (i = !e.hidden), e.hidden = i
                }

                function H(e, t, i) {
                    if (S.nodeList(e)) return Array.from(e).map((e => H(e, t, i)));
                    if (S.element(e)) {
                        let r = "toggle";
                        return void 0 !== i && (r = i ? "add" : "remove"), e.classList[r](t), e.classList.contains(t)
                    }
                    return !1
                }

                function j(e, t) {
                    return S.element(e) && e.classList.contains(t)
                }

                function G(e, t) {
                    const {
                        prototype: i
                    } = Element;
                    return (i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.msMatchesSelector || function() {
                        return Array.from(document.querySelectorAll(t)).includes(this)
                    }).call(e, t)
                }

                function V(e) {
                    return this.elements.container.querySelectorAll(e)
                }

                function q(e) {
                    return this.elements.container.querySelector(e)
                }

                function K(e = null, t = !1) {
                    S.element(e) && e.focus({
                        preventScroll: !0,
                        focusVisible: t
                    })
                }
                const W = {
                        "audio/ogg": "vorbis",
                        "audio/wav": "1",
                        "video/webm": "vp8, vorbis",
                        "video/mp4": "avc1.42E01E, mp4a.40.2",
                        "video/ogg": "theora"
                    },
                    Y = {
                        audio: "canPlayType" in document.createElement("audio"),
                        video: "canPlayType" in document.createElement("video"),
                        check(e, t) {
                            const i = Y[e] || "html5" !== t;
                            return {
                                api: i,
                                ui: i && Y.rangeInput
                            }
                        },
                        pip: !(D.isIPhone || !S.function(O("video").webkitSetPresentationMode) && (!document.pictureInPictureEnabled || O("video").disablePictureInPicture)),
                        airplay: S.function(window.WebKitPlaybackTargetAvailabilityEvent),
                        playsinline: "playsInline" in document.createElement("video"),
                        mime(e) {
                            if (S.empty(e)) return !1;
                            const [t] = e.split("/");
                            let i = e;
                            if (!this.isHTML5 || t !== this.type) return !1;
                            Object.keys(W).includes(i) && (i += `; codecs="${W[e]}"`);
                            try {
                                return Boolean(i && this.media.canPlayType(i).replace(/no/, ""))
                            } catch (e) {
                                return !1
                            }
                        },
                        textTracks: "textTracks" in document.createElement("video"),
                        rangeInput: (() => {
                            const e = document.createElement("input");
                            return e.type = "range", "range" === e.type
                        })(),
                        touch: "ontouchstart" in document.documentElement,
                        transitions: !1 !== L,
                        reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches
                    },
                    z = (() => {
                        let e = !1;
                        try {
                            const t = Object.defineProperty({}, "passive", {
                                get: () => (e = !0, null)
                            });
                            window.addEventListener("test", null, t), window.removeEventListener("test", null, t)
                        } catch (e) {}
                        return e
                    })();

                function X(e, t, i, r = !1, n = !0, s = !1) {
                    if (!e || !("addEventListener" in e) || S.empty(t) || !S.function(i)) return;
                    const a = t.split(" ");
                    let o = s;
                    z && (o = {
                        passive: n,
                        capture: s
                    }), a.forEach((t => {
                        this && this.eventListeners && r && this.eventListeners.push({
                            element: e,
                            type: t,
                            callback: i,
                            options: o
                        }), e[r ? "addEventListener" : "removeEventListener"](t, i, o)
                    }))
                }

                function Q(e, t = "", i, r = !0, n = !1) {
                    X.call(this, e, t, i, !0, r, n)
                }

                function J(e, t = "", i, r = !0, n = !1) {
                    X.call(this, e, t, i, !1, r, n)
                }

                function Z(e, t = "", i, r = !0, n = !1) {
                    const s = (...a) => {
                        J(e, t, s, r, n), i.apply(this, a)
                    };
                    X.call(this, e, t, s, !0, r, n)
                }

                function ee(e, t = "", i = !1, r = {}) {
                    if (!S.element(e) || S.empty(t)) return;
                    const n = new CustomEvent(t, {
                        bubbles: i,
                        detail: { ...r,
                            plyr: this
                        }
                    });
                    e.dispatchEvent(n)
                }

                function te() {
                    this && this.eventListeners && (this.eventListeners.forEach((e => {
                        const {
                            element: t,
                            type: i,
                            callback: r,
                            options: n
                        } = e;
                        t.removeEventListener(i, r, n)
                    })), this.eventListeners = [])
                }

                function ie() {
                    return new Promise((e => this.ready ? setTimeout(e, 0) : Q.call(this, this.elements.container, "ready", e))).then((() => {}))
                }

                function re(e) {
                    S.promise(e) && e.then(null, (() => {}))
                }

                function ne(e) {
                    return S.array(e) ? e.filter(((t, i) => e.indexOf(t) === i)) : e
                }

                function se(e, t) {
                    return S.array(e) && e.length ? e.reduce(((e, i) => Math.abs(i - t) < Math.abs(e - t) ? i : e)) : null
                }

                function ae(e) {
                    return !(!window || !window.CSS) && window.CSS.supports(e)
                }
                const oe = [
                    [1, 1],
                    [4, 3],
                    [3, 4],
                    [5, 4],
                    [4, 5],
                    [3, 2],
                    [2, 3],
                    [16, 10],
                    [10, 16],
                    [16, 9],
                    [9, 16],
                    [21, 9],
                    [9, 21],
                    [32, 9],
                    [9, 32]
                ].reduce(((e, [t, i]) => ({ ...e,
                    [t / i]: [t, i]
                })), {});

                function le(e) {
                    return !!(S.array(e) || S.string(e) && e.includes(":")) && (S.array(e) ? e : e.split(":")).map(Number).every(S.number)
                }

                function ce(e) {
                    if (!S.array(e) || !e.every(S.number)) return null;
                    const [t, i] = e, r = (e, t) => 0 === t ? e : r(t, e % t), n = r(t, i);
                    return [t / n, i / n]
                }

                function de(e) {
                    const t = e => le(e) ? e.split(":").map(Number) : null;
                    let i = t(e);
                    if (null === i && (i = t(this.config.ratio)), null === i && !S.empty(this.embed) && S.array(this.embed.ratio) && ({
                            ratio: i
                        } = this.embed), null === i && this.isHTML5) {
                        const {
                            videoWidth: e,
                            videoHeight: t
                        } = this.media;
                        i = [e, t]
                    }
                    return ce(i)
                }

                function ue(e) {
                    if (!this.isVideo) return {};
                    const {
                        wrapper: t
                    } = this.elements, i = de.call(this, e);
                    if (!S.array(i)) return {};
                    const [r, n] = ce(i), s = 100 / r * n;
                    if (ae(`aspect-ratio: ${r}/${n}`) ? t.style.aspectRatio = `${r}/${n}` : t.style.paddingBottom = `${s}%`, this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {
                        const e = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10),
                            i = (e - s) / (e / 50);
                        this.fullscreen.active ? t.style.paddingBottom = null : this.media.style.transform = `translateY(-${i}%)`
                    } else this.isHTML5 && t.classList.add(this.config.classNames.videoFixedRatio);
                    return {
                        padding: s,
                        ratio: i
                    }
                }

                function he(e, t, i = .05) {
                    const r = e / t,
                        n = se(Object.keys(oe), r);
                    return Math.abs(n - r) <= i ? oe[n] : [e, t]
                }
                const fe = {
                    getSources() {
                        return this.isHTML5 ? Array.from(this.media.querySelectorAll("source")).filter((e => {
                            const t = e.getAttribute("type");
                            return !!S.empty(t) || Y.mime.call(this, t)
                        })) : []
                    },
                    getQualityOptions() {
                        return this.config.quality.forced ? this.config.quality.options : fe.getSources.call(this).map((e => Number(e.getAttribute("size")))).filter(Boolean)
                    },
                    setup() {
                        if (!this.isHTML5) return;
                        const e = this;
                        e.options.speed = e.config.speed.options, S.empty(this.config.ratio) || ue.call(e), Object.defineProperty(e.media, "quality", {
                            get() {
                                const t = fe.getSources.call(e).find((t => t.getAttribute("src") === e.source));
                                return t && Number(t.getAttribute("size"))
                            },
                            set(t) {
                                if (e.quality !== t) {
                                    if (e.config.quality.forced && S.function(e.config.quality.onChange)) e.config.quality.onChange(t);
                                    else {
                                        const i = fe.getSources.call(e).find((e => Number(e.getAttribute("size")) === t));
                                        if (!i) return;
                                        const {
                                            currentTime: r,
                                            paused: n,
                                            preload: s,
                                            readyState: a,
                                            playbackRate: o
                                        } = e.media;
                                        e.media.src = i.getAttribute("src"), ("none" !== s || a) && (e.once("loadedmetadata", (() => {
                                            e.speed = o, e.currentTime = r, n || re(e.play())
                                        })), e.media.load())
                                    }
                                    ee.call(e, e.media, "qualitychange", !1, {
                                        quality: t
                                    })
                                }
                            }
                        })
                    },
                    cancelRequests() {
                        this.isHTML5 && (N(fe.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests"))
                    }
                };

                function me(e, ...t) {
                    return S.empty(e) ? e : e.toString().replace(/{(\d+)}/g, ((e, i) => t[i].toString()))
                }
                const pe = (e = "", t = "", i = "") => e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), i.toString()),
                    ge = (e = "") => e.toString().replace(/\w\S*/g, (e => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase()));

                function ye(e = "") {
                    let t = e.toString();
                    return t = function(e = "") {
                        let t = e.toString();
                        return t = pe(t, "-", " "), t = pe(t, "_", " "), t = ge(t), pe(t, " ", "")
                    }(t), t.charAt(0).toLowerCase() + t.slice(1)
                }

                function ve(e) {
                    const t = document.createElement("div");
                    return t.appendChild(e), t.innerHTML
                }
                const be = {
                        pip: "PIP",
                        airplay: "AirPlay",
                        html5: "HTML5",
                        vimeo: "Vimeo",
                        youtube: "YouTube"
                    },
                    Te = {
                        get(e = "", t = {}) {
                            if (S.empty(e) || S.empty(t)) return "";
                            let i = C(t.i18n, e);
                            if (S.empty(i)) return Object.keys(be).includes(e) ? be[e] : "";
                            const r = {
                                "{seektime}": t.seekTime,
                                "{title}": t.title
                            };
                            return Object.entries(r).forEach((([e, t]) => {
                                i = pe(i, e, t)
                            })), i
                        }
                    };
                class Ee {
                    constructor(t) {
                        e(this, "get", (e => {
                            if (!Ee.supported || !this.enabled) return null;
                            const t = window.localStorage.getItem(this.key);
                            if (S.empty(t)) return null;
                            const i = JSON.parse(t);
                            return S.string(e) && e.length ? i[e] : i
                        })), e(this, "set", (e => {
                            if (!Ee.supported || !this.enabled) return;
                            if (!S.object(e)) return;
                            let t = this.get();
                            S.empty(t) && (t = {}), I(t, e);
                            try {
                                window.localStorage.setItem(this.key, JSON.stringify(t))
                            } catch (e) {}
                        })), this.enabled = t.config.storage.enabled, this.key = t.config.storage.key
                    }
                    static get supported() {
                        try {
                            if (!("localStorage" in window)) return !1;
                            const e = "___test";
                            return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0
                        } catch (e) {
                            return !1
                        }
                    }
                }

                function Ae(e, t = "text") {
                    return new Promise(((i, r) => {
                        try {
                            const r = new XMLHttpRequest;
                            if (!("withCredentials" in r)) return;
                            r.addEventListener("load", (() => {
                                if ("text" === t) try {
                                    i(JSON.parse(r.responseText))
                                } catch (e) {
                                    i(r.responseText)
                                } else i(r.response)
                            })), r.addEventListener("error", (() => {
                                throw new Error(r.status)
                            })), r.open("GET", e, !0), r.responseType = t, r.send()
                        } catch (e) {
                            r(e)
                        }
                    }))
                }

                function we(e, t) {
                    if (!S.string(e)) return;
                    const i = "cache",
                        r = S.string(t);
                    let n = !1;
                    const s = () => null !== document.getElementById(t),
                        a = (e, t) => {
                            e.innerHTML = t, r && s() || document.body.insertAdjacentElement("afterbegin", e)
                        };
                    if (!r || !s()) {
                        const s = Ee.supported,
                            o = document.createElement("div");
                        if (o.setAttribute("hidden", ""), r && o.setAttribute("id", t), s) {
                            const e = window.localStorage.getItem(`${i}-${t}`);
                            if (n = null !== e, n) {
                                const t = JSON.parse(e);
                                a(o, t.content)
                            }
                        }
                        Ae(e).then((e => {
                            if (!S.empty(e)) {
                                if (s) try {
                                    window.localStorage.setItem(`${i}-${t}`, JSON.stringify({
                                        content: e
                                    }))
                                } catch (e) {}
                                a(o, e)
                            }
                        })).catch((() => {}))
                    }
                }
                const _e = e => Math.trunc(e / 60 / 60 % 60, 10),
                    ke = e => Math.trunc(e / 60 % 60, 10),
                    Se = e => Math.trunc(e % 60, 10);

                function Le(e = 0, t = !1, i = !1) {
                    if (!S.number(e)) return Le(void 0, t, i);
                    const r = e => `0${e}`.slice(-2);
                    let n = _e(e);
                    const s = ke(e),
                        a = Se(e);
                    return n = t || n > 0 ? `${n}:` : "", `${i&&e>0?"-":""}${n}${r(s)}:${r(a)}`
                }
                const Re = {
                    getIconUrl() {
                        const e = new URL(this.config.iconUrl, window.location),
                            t = window.location.host ? window.location.host : window.top.location.host,
                            i = e.host !== t || D.isIE && !window.svg4everybody;
                        return {
                            url: this.config.iconUrl,
                            cors: i
                        }
                    },
                    findElements() {
                        try {
                            return this.elements.controls = q.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = {
                                play: V.call(this, this.config.selectors.buttons.play),
                                pause: q.call(this, this.config.selectors.buttons.pause),
                                restart: q.call(this, this.config.selectors.buttons.restart),
                                rewind: q.call(this, this.config.selectors.buttons.rewind),
                                fastForward: q.call(this, this.config.selectors.buttons.fastForward),
                                mute: q.call(this, this.config.selectors.buttons.mute),
                                pip: q.call(this, this.config.selectors.buttons.pip),
                                airplay: q.call(this, this.config.selectors.buttons.airplay),
                                settings: q.call(this, this.config.selectors.buttons.settings),
                                captions: q.call(this, this.config.selectors.buttons.captions),
                                fullscreen: q.call(this, this.config.selectors.buttons.fullscreen)
                            }, this.elements.progress = q.call(this, this.config.selectors.progress), this.elements.inputs = {
                                seek: q.call(this, this.config.selectors.inputs.seek),
                                volume: q.call(this, this.config.selectors.inputs.volume)
                            }, this.elements.display = {
                                buffer: q.call(this, this.config.selectors.display.buffer),
                                currentTime: q.call(this, this.config.selectors.display.currentTime),
                                duration: q.call(this, this.config.selectors.display.duration)
                            }, S.element(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`)), !0
                        } catch (e) {
                            return this.debug.warn("It looks like there is a problem with your custom controls HTML", e), this.toggleNativeControls(!0), !1
                        }
                    },
                    createIcon(e, t) {
                        const i = "http://www.w3.org/2000/svg",
                            r = Re.getIconUrl.call(this),
                            n = `${r.cors?"":r.url}#${this.config.iconPrefix}`,
                            s = document.createElementNS(i, "svg");
                        x(s, I(t, {
                            "aria-hidden": "true",
                            focusable: "false"
                        }));
                        const a = document.createElementNS(i, "use"),
                            o = `${n}-${e}`;
                        return "href" in a && a.setAttributeNS("http://www.w3.org/1999/xlink", "href", o), a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", o), s.appendChild(a), s
                    },
                    createLabel(e, t = {}) {
                        const i = Te.get(e, this.config);
                        return O("span", { ...t,
                            class: [t.class, this.config.classNames.hidden].filter(Boolean).join(" ")
                        }, i)
                    },
                    createBadge(e) {
                        if (S.empty(e)) return null;
                        const t = O("span", {
                            class: this.config.classNames.menu.value
                        });
                        return t.appendChild(O("span", {
                            class: this.config.classNames.menu.badge
                        }, e)), t
                    },
                    createButton(e, t) {
                        const i = I({}, t);
                        let r = ye(e);
                        const n = {
                            element: "button",
                            toggle: !1,
                            label: null,
                            icon: null,
                            labelPressed: null,
                            iconPressed: null
                        };
                        switch (["element", "icon", "label"].forEach((e => {
                            Object.keys(i).includes(e) && (n[e] = i[e], delete i[e])
                        })), "button" !== n.element || Object.keys(i).includes("type") || (i.type = "button"), Object.keys(i).includes("class") ? i.class.split(" ").some((e => e === this.config.classNames.control)) || I(i, {
                            class: `${i.class} ${this.config.classNames.control}`
                        }) : i.class = this.config.classNames.control, e) {
                            case "play":
                                n.toggle = !0, n.label = "play", n.labelPressed = "pause", n.icon = "play", n.iconPressed = "pause";
                                break;
                            case "mute":
                                n.toggle = !0, n.label = "mute", n.labelPressed = "unmute", n.icon = "volume", n.iconPressed = "muted";
                                break;
                            case "captions":
                                n.toggle = !0, n.label = "enableCaptions", n.labelPressed = "disableCaptions", n.icon = "captions-off", n.iconPressed = "captions-on";
                                break;
                            case "fullscreen":
                                n.toggle = !0, n.label = "enterFullscreen", n.labelPressed = "exitFullscreen", n.icon = "enter-fullscreen", n.iconPressed = "exit-fullscreen";
                                break;
                            case "play-large":
                                i.class += ` ${this.config.classNames.control}--overlaid`, r = "play", n.label = "play", n.icon = "play";
                                break;
                            default:
                                S.empty(n.label) && (n.label = r), S.empty(n.icon) && (n.icon = e)
                        }
                        const s = O(n.element);
                        return n.toggle ? (s.appendChild(Re.createIcon.call(this, n.iconPressed, {
                            class: "icon--pressed"
                        })), s.appendChild(Re.createIcon.call(this, n.icon, {
                            class: "icon--not-pressed"
                        })), s.appendChild(Re.createLabel.call(this, n.labelPressed, {
                            class: "label--pressed"
                        })), s.appendChild(Re.createLabel.call(this, n.label, {
                            class: "label--not-pressed"
                        }))) : (s.appendChild(Re.createIcon.call(this, n.icon)), s.appendChild(Re.createLabel.call(this, n.label))), I(i, U(this.config.selectors.buttons[r], i)), x(s, i), "play" === r ? (S.array(this.elements.buttons[r]) || (this.elements.buttons[r] = []), this.elements.buttons[r].push(s)) : this.elements.buttons[r] = s, s
                    },
                    createRange(e, t) {
                        const i = O("input", I(U(this.config.selectors.inputs[e]), {
                            type: "range",
                            min: 0,
                            max: 100,
                            step: .01,
                            value: 0,
                            autocomplete: "off",
                            role: "slider",
                            "aria-label": Te.get(e, this.config),
                            "aria-valuemin": 0,
                            "aria-valuemax": 100,
                            "aria-valuenow": 0
                        }, t));
                        return this.elements.inputs[e] = i, Re.updateRangeFill.call(this, i), g.setup(i), i
                    },
                    createProgress(e, t) {
                        const i = O("progress", I(U(this.config.selectors.display[e]), {
                            min: 0,
                            max: 100,
                            value: 0,
                            role: "progressbar",
                            "aria-hidden": !0
                        }, t));
                        if ("volume" !== e) {
                            i.appendChild(O("span", null, "0"));
                            const t = {
                                    played: "played",
                                    buffer: "buffered"
                                }[e],
                                r = t ? Te.get(t, this.config) : "";
                            i.innerText = `% ${r.toLowerCase()}`
                        }
                        return this.elements.display[e] = i, i
                    },
                    createTime(e, t) {
                        const i = U(this.config.selectors.display[e], t),
                            r = O("div", I(i, {
                                class: `${i.class?i.class:""} ${this.config.classNames.display.time} `.trim(),
                                "aria-label": Te.get(e, this.config),
                                role: "timer"
                            }), "00:00");
                        return this.elements.display[e] = r, r
                    },
                    bindMenuItemShortcuts(e, t) {
                        Q.call(this, e, "keydown keyup", (i => {
                            if (![" ", "ArrowUp", "ArrowDown", "ArrowRight"].includes(i.key)) return;
                            if (i.preventDefault(), i.stopPropagation(), "keydown" === i.type) return;
                            const r = G(e, '[role="menuitemradio"]');
                            if (!r && [" ", "ArrowRight"].includes(i.key)) Re.showMenuPanel.call(this, t, !0);
                            else {
                                let t;
                                " " !== i.key && ("ArrowDown" === i.key || r && "ArrowRight" === i.key ? (t = e.nextElementSibling, S.element(t) || (t = e.parentNode.firstElementChild)) : (t = e.previousElementSibling, S.element(t) || (t = e.parentNode.lastElementChild)), K.call(this, t, !0))
                            }
                        }), !1), Q.call(this, e, "keyup", (e => {
                            "Return" === e.key && Re.focusFirstMenuItem.call(this, null, !0)
                        }))
                    },
                    createMenuItem({
                        value: e,
                        list: t,
                        type: i,
                        title: r,
                        badge: n = null,
                        checked: s = !1
                    }) {
                        const a = U(this.config.selectors.inputs[i]),
                            o = O("button", I(a, {
                                type: "button",
                                role: "menuitemradio",
                                class: `${this.config.classNames.control} ${a.class?a.class:""}`.trim(),
                                "aria-checked": s,
                                value: e
                            })),
                            l = O("span");
                        l.innerHTML = r, S.element(n) && l.appendChild(n), o.appendChild(l), Object.defineProperty(o, "checked", {
                            enumerable: !0,
                            get: () => "true" === o.getAttribute("aria-checked"),
                            set(e) {
                                e && Array.from(o.parentNode.children).filter((e => G(e, '[role="menuitemradio"]'))).forEach((e => e.setAttribute("aria-checked", "false"))), o.setAttribute("aria-checked", e ? "true" : "false")
                            }
                        }), this.listeners.bind(o, "click keyup", (t => {
                            if (!S.keyboardEvent(t) || " " === t.key) {
                                switch (t.preventDefault(), t.stopPropagation(), o.checked = !0, i) {
                                    case "language":
                                        this.currentTrack = Number(e);
                                        break;
                                    case "quality":
                                        this.quality = e;
                                        break;
                                    case "speed":
                                        this.speed = parseFloat(e)
                                }
                                Re.showMenuPanel.call(this, "home", S.keyboardEvent(t))
                            }
                        }), i, !1), Re.bindMenuItemShortcuts.call(this, o, i), t.appendChild(o)
                    },
                    formatTime(e = 0, t = !1) {
                        return S.number(e) ? Le(e, _e(this.duration) > 0, t) : e
                    },
                    updateTimeDisplay(e = null, t = 0, i = !1) {
                        S.element(e) && S.number(t) && (e.innerText = Re.formatTime(t, i))
                    },
                    updateVolume() {
                        this.supported.ui && (S.element(this.elements.inputs.volume) && Re.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), S.element(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume))
                    },
                    setRange(e, t = 0) {
                        S.element(e) && (e.value = t, Re.updateRangeFill.call(this, e))
                    },
                    updateProgress(e) {
                        if (!this.supported.ui || !S.event(e)) return;
                        let t = 0;
                        const i = (e, t) => {
                            const i = S.number(t) ? t : 0,
                                r = S.element(e) ? e : this.elements.display.buffer;
                            if (S.element(r)) {
                                r.value = i;
                                const e = r.getElementsByTagName("span")[0];
                                S.element(e) && (e.childNodes[0].nodeValue = i)
                            }
                        };
                        if (e) switch (e.type) {
                            case "timeupdate":
                            case "seeking":
                            case "seeked":
                                r = this.currentTime, n = this.duration, t = 0 === r || 0 === n || Number.isNaN(r) || Number.isNaN(n) ? 0 : (r / n * 100).toFixed(2), "timeupdate" === e.type && Re.setRange.call(this, this.elements.inputs.seek, t);
                                break;
                            case "playing":
                            case "progress":
                                i(this.elements.display.buffer, 100 * this.buffered)
                        }
                        var r, n
                    },
                    updateRangeFill(e) {
                        const t = S.event(e) ? e.target : e;
                        if (S.element(t) && "range" === t.getAttribute("type")) {
                            if (G(t, this.config.selectors.inputs.seek)) {
                                t.setAttribute("aria-valuenow", this.currentTime);
                                const e = Re.formatTime(this.currentTime),
                                    i = Re.formatTime(this.duration),
                                    r = Te.get("seekLabel", this.config);
                                t.setAttribute("aria-valuetext", r.replace("{currentTime}", e).replace("{duration}", i))
                            } else if (G(t, this.config.selectors.inputs.volume)) {
                                const e = 100 * t.value;
                                t.setAttribute("aria-valuenow", e), t.setAttribute("aria-valuetext", `${e.toFixed(1)}%`)
                            } else t.setAttribute("aria-valuenow", t.value);
                            (D.isWebKit || D.isIPadOS) && t.style.setProperty("--value", t.value / t.max * 100 + "%")
                        }
                    },
                    updateSeekTooltip(e) {
                        var t, i;
                        if (!this.config.tooltips.seek || !S.element(this.elements.inputs.seek) || !S.element(this.elements.display.seekTooltip) || 0 === this.duration) return;
                        const r = this.elements.display.seekTooltip,
                            n = `${this.config.classNames.tooltip}--visible`,
                            s = e => H(r, n, e);
                        if (this.touch) return void s(!1);
                        let a = 0;
                        const o = this.elements.progress.getBoundingClientRect();
                        if (S.event(e)) a = 100 / o.width * (e.pageX - o.left);
                        else {
                            if (!j(r, n)) return;
                            a = parseFloat(r.style.left, 10)
                        }
                        a < 0 ? a = 0 : a > 100 && (a = 100);
                        const l = this.duration / 100 * a;
                        r.innerText = Re.formatTime(l);
                        const c = null === (t = this.config.markers) || void 0 === t || null === (i = t.points) || void 0 === i ? void 0 : i.find((({
                            time: e
                        }) => e === Math.round(l)));
                        c && r.insertAdjacentHTML("afterbegin", `${c.label}<br>`), r.style.left = `${a}%`, S.event(e) && ["mouseenter", "mouseleave"].includes(e.type) && s("mouseenter" === e.type)
                    },
                    timeUpdate(e) {
                        const t = !S.element(this.elements.display.duration) && this.config.invertTime;
                        Re.updateTimeDisplay.call(this, this.elements.display.currentTime, t ? this.duration - this.currentTime : this.currentTime, t), e && "timeupdate" === e.type && this.media.seeking || Re.updateProgress.call(this, e)
                    },
                    durationUpdate() {
                        if (!this.supported.ui || !this.config.invertTime && this.currentTime) return;
                        if (this.duration >= 2 ** 32) return $(this.elements.display.currentTime, !0), void $(this.elements.progress, !0);
                        S.element(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
                        const e = S.element(this.elements.display.duration);
                        !e && this.config.displayDuration && this.paused && Re.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), e && Re.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), this.config.markers.enabled && Re.setMarkers.call(this), Re.updateSeekTooltip.call(this)
                    },
                    toggleMenuButton(e, t) {
                        $(this.elements.settings.buttons[e], !t)
                    },
                    updateSetting(e, t, i) {
                        const r = this.elements.settings.panels[e];
                        let n = null,
                            s = t;
                        if ("captions" === e) n = this.currentTrack;
                        else {
                            if (n = S.empty(i) ? this[e] : i, S.empty(n) && (n = this.config[e].default), !S.empty(this.options[e]) && !this.options[e].includes(n)) return void this.debug.warn(`Unsupported value of '${n}' for ${e}`);
                            if (!this.config[e].options.includes(n)) return void this.debug.warn(`Disabled value of '${n}' for ${e}`)
                        }
                        if (S.element(s) || (s = r && r.querySelector('[role="menu"]')), !S.element(s)) return;
                        this.elements.settings.buttons[e].querySelector(`.${this.config.classNames.menu.value}`).innerHTML = Re.getLabel.call(this, e, n);
                        const a = s && s.querySelector(`[value="${n}"]`);
                        S.element(a) && (a.checked = !0)
                    },
                    getLabel(e, t) {
                        switch (e) {
                            case "speed":
                                return 1 === t ? Te.get("normal", this.config) : `${t}&times;`;
                            case "quality":
                                if (S.number(t)) {
                                    const e = Te.get(`qualityLabel.${t}`, this.config);
                                    return e.length ? e : `${t}p`
                                }
                                return ge(t);
                            case "captions":
                                return Ie.getLabel.call(this);
                            default:
                                return null
                        }
                    },
                    setQualityMenu(e) {
                        if (!S.element(this.elements.settings.panels.quality)) return;
                        const t = "quality",
                            i = this.elements.settings.panels.quality.querySelector('[role="menu"]');
                        S.array(e) && (this.options.quality = ne(e).filter((e => this.config.quality.options.includes(e))));
                        const r = !S.empty(this.options.quality) && this.options.quality.length > 1;
                        if (Re.toggleMenuButton.call(this, t, r), F(i), Re.checkMenu.call(this), !r) return;
                        const n = e => {
                            const t = Te.get(`qualityBadge.${e}`, this.config);
                            return t.length ? Re.createBadge.call(this, t) : null
                        };
                        this.options.quality.sort(((e, t) => {
                            const i = this.config.quality.options;
                            return i.indexOf(e) > i.indexOf(t) ? 1 : -1
                        })).forEach((e => {
                            Re.createMenuItem.call(this, {
                                value: e,
                                list: i,
                                type: t,
                                title: Re.getLabel.call(this, "quality", e),
                                badge: n(e)
                            })
                        })), Re.updateSetting.call(this, t, i)
                    },
                    setCaptionsMenu() {
                        if (!S.element(this.elements.settings.panels.captions)) return;
                        const e = "captions",
                            t = this.elements.settings.panels.captions.querySelector('[role="menu"]'),
                            i = Ie.getTracks.call(this),
                            r = Boolean(i.length);
                        if (Re.toggleMenuButton.call(this, e, r), F(t), Re.checkMenu.call(this), !r) return;
                        const n = i.map(((e, i) => ({
                            value: i,
                            checked: this.captions.toggled && this.currentTrack === i,
                            title: Ie.getLabel.call(this, e),
                            badge: e.language && Re.createBadge.call(this, e.language.toUpperCase()),
                            list: t,
                            type: "language"
                        })));
                        n.unshift({
                            value: -1,
                            checked: !this.captions.toggled,
                            title: Te.get("disabled", this.config),
                            list: t,
                            type: "language"
                        }), n.forEach(Re.createMenuItem.bind(this)), Re.updateSetting.call(this, e, t)
                    },
                    setSpeedMenu() {
                        if (!S.element(this.elements.settings.panels.speed)) return;
                        const e = "speed",
                            t = this.elements.settings.panels.speed.querySelector('[role="menu"]');
                        this.options.speed = this.options.speed.filter((e => e >= this.minimumSpeed && e <= this.maximumSpeed));
                        const i = !S.empty(this.options.speed) && this.options.speed.length > 1;
                        Re.toggleMenuButton.call(this, e, i), F(t), Re.checkMenu.call(this), i && (this.options.speed.forEach((i => {
                            Re.createMenuItem.call(this, {
                                value: i,
                                list: t,
                                type: e,
                                title: Re.getLabel.call(this, "speed", i)
                            })
                        })), Re.updateSetting.call(this, e, t))
                    },
                    checkMenu() {
                        const {
                            buttons: e
                        } = this.elements.settings, t = !S.empty(e) && Object.values(e).some((e => !e.hidden));
                        $(this.elements.settings.menu, !t)
                    },
                    focusFirstMenuItem(e, t = !1) {
                        if (this.elements.settings.popup.hidden) return;
                        let i = e;
                        S.element(i) || (i = Object.values(this.elements.settings.panels).find((e => !e.hidden)));
                        const r = i.querySelector('[role^="menuitem"]');
                        K.call(this, r, t)
                    },
                    toggleMenu(e) {
                        const {
                            popup: t
                        } = this.elements.settings, i = this.elements.buttons.settings;
                        if (!S.element(t) || !S.element(i)) return;
                        const {
                            hidden: r
                        } = t;
                        let n = r;
                        if (S.boolean(e)) n = e;
                        else if (S.keyboardEvent(e) && "Escape" === e.key) n = !1;
                        else if (S.event(e)) {
                            const r = S.function(e.composedPath) ? e.composedPath()[0] : e.target,
                                s = t.contains(r);
                            if (s || !s && e.target !== i && n) return
                        }
                        i.setAttribute("aria-expanded", n), $(t, !n), H(this.elements.container, this.config.classNames.menu.open, n), n && S.keyboardEvent(e) ? Re.focusFirstMenuItem.call(this, null, !0) : n || r || K.call(this, i, S.keyboardEvent(e))
                    },
                    getMenuSize(e) {
                        const t = e.cloneNode(!0);
                        t.style.position = "absolute", t.style.opacity = 0, t.removeAttribute("hidden"), e.parentNode.appendChild(t);
                        const i = t.scrollWidth,
                            r = t.scrollHeight;
                        return N(t), {
                            width: i,
                            height: r
                        }
                    },
                    showMenuPanel(e = "", t = !1) {
                        const i = this.elements.container.querySelector(`#plyr-settings-${this.id}-${e}`);
                        if (!S.element(i)) return;
                        const r = i.parentNode,
                            n = Array.from(r.children).find((e => !e.hidden));
                        if (Y.transitions && !Y.reducedMotion) {
                            r.style.width = `${n.scrollWidth}px`, r.style.height = `${n.scrollHeight}px`;
                            const e = Re.getMenuSize.call(this, i),
                                t = e => {
                                    e.target === r && ["width", "height"].includes(e.propertyName) && (r.style.width = "", r.style.height = "", J.call(this, r, L, t))
                                };
                            Q.call(this, r, L, t), r.style.width = `${e.width}px`, r.style.height = `${e.height}px`
                        }
                        $(n, !0), $(i, !1), Re.focusFirstMenuItem.call(this, i, t)
                    },
                    setDownloadUrl() {
                        const e = this.elements.buttons.download;
                        S.element(e) && e.setAttribute("href", this.download)
                    },
                    create(e) {
                        const {
                            bindMenuItemShortcuts: t,
                            createButton: i,
                            createProgress: r,
                            createRange: n,
                            createTime: s,
                            setQualityMenu: a,
                            setSpeedMenu: o,
                            showMenuPanel: l
                        } = Re;
                        this.elements.controls = null, S.array(this.config.controls) && this.config.controls.includes("play-large") && this.elements.container.appendChild(i.call(this, "play-large"));
                        const c = O("div", U(this.config.selectors.controls.wrapper));
                        this.elements.controls = c;
                        const d = {
                            class: "plyr__controls__item"
                        };
                        return ne(S.array(this.config.controls) ? this.config.controls : []).forEach((a => {
                            if ("restart" === a && c.appendChild(i.call(this, "restart", d)), "rewind" === a && c.appendChild(i.call(this, "rewind", d)), "play" === a && c.appendChild(i.call(this, "play", d)), "fast-forward" === a && c.appendChild(i.call(this, "fast-forward", d)), "progress" === a) {
                                const t = O("div", {
                                        class: `${d.class} plyr__progress__container`
                                    }),
                                    i = O("div", U(this.config.selectors.progress));
                                if (i.appendChild(n.call(this, "seek", {
                                        id: `plyr-seek-${e.id}`
                                    })), i.appendChild(r.call(this, "buffer")), this.config.tooltips.seek) {
                                    const e = O("span", {
                                        class: this.config.classNames.tooltip
                                    }, "00:00");
                                    i.appendChild(e), this.elements.display.seekTooltip = e
                                }
                                this.elements.progress = i, t.appendChild(this.elements.progress), c.appendChild(t)
                            }
                            if ("current-time" === a && c.appendChild(s.call(this, "currentTime", d)), "duration" === a && c.appendChild(s.call(this, "duration", d)), "mute" === a || "volume" === a) {
                                let {
                                    volume: t
                                } = this.elements;
                                if (S.element(t) && c.contains(t) || (t = O("div", I({}, d, {
                                        class: `${d.class} plyr__volume`.trim()
                                    })), this.elements.volume = t, c.appendChild(t)), "mute" === a && t.appendChild(i.call(this, "mute")), "volume" === a && !D.isIos && !D.isIPadOS) {
                                    const i = {
                                        max: 1,
                                        step: .05,
                                        value: this.config.volume
                                    };
                                    t.appendChild(n.call(this, "volume", I(i, {
                                        id: `plyr-volume-${e.id}`
                                    })))
                                }
                            }
                            if ("captions" === a && c.appendChild(i.call(this, "captions", d)), "settings" === a && !S.empty(this.config.settings)) {
                                const r = O("div", I({}, d, {
                                    class: `${d.class} plyr__menu`.trim(),
                                    hidden: ""
                                }));
                                r.appendChild(i.call(this, "settings", {
                                    "aria-haspopup": !0,
                                    "aria-controls": `plyr-settings-${e.id}`,
                                    "aria-expanded": !1
                                }));
                                const n = O("div", {
                                        class: "plyr__menu__container",
                                        id: `plyr-settings-${e.id}`,
                                        hidden: ""
                                    }),
                                    s = O("div"),
                                    a = O("div", {
                                        id: `plyr-settings-${e.id}-home`
                                    }),
                                    o = O("div", {
                                        role: "menu"
                                    });
                                a.appendChild(o), s.appendChild(a), this.elements.settings.panels.home = a, this.config.settings.forEach((i => {
                                    const r = O("button", I(U(this.config.selectors.buttons.settings), {
                                        type: "button",
                                        class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,
                                        role: "menuitem",
                                        "aria-haspopup": !0,
                                        hidden: ""
                                    }));
                                    t.call(this, r, i), Q.call(this, r, "click", (() => {
                                        l.call(this, i, !1)
                                    }));
                                    const n = O("span", null, Te.get(i, this.config)),
                                        a = O("span", {
                                            class: this.config.classNames.menu.value
                                        });
                                    a.innerHTML = e[i], n.appendChild(a), r.appendChild(n), o.appendChild(r);
                                    const c = O("div", {
                                            id: `plyr-settings-${e.id}-${i}`,
                                            hidden: ""
                                        }),
                                        d = O("button", {
                                            type: "button",
                                            class: `${this.config.classNames.control} ${this.config.classNames.control}--back`
                                        });
                                    d.appendChild(O("span", {
                                        "aria-hidden": !0
                                    }, Te.get(i, this.config))), d.appendChild(O("span", {
                                        class: this.config.classNames.hidden
                                    }, Te.get("menuBack", this.config))), Q.call(this, c, "keydown", (e => {
                                        "ArrowLeft" === e.key && (e.preventDefault(), e.stopPropagation(), l.call(this, "home", !0))
                                    }), !1), Q.call(this, d, "click", (() => {
                                        l.call(this, "home", !1)
                                    })), c.appendChild(d), c.appendChild(O("div", {
                                        role: "menu"
                                    })), s.appendChild(c), this.elements.settings.buttons[i] = r, this.elements.settings.panels[i] = c
                                })), n.appendChild(s), r.appendChild(n), c.appendChild(r), this.elements.settings.popup = n, this.elements.settings.menu = r
                            }
                            if ("pip" === a && Y.pip && c.appendChild(i.call(this, "pip", d)), "airplay" === a && Y.airplay && c.appendChild(i.call(this, "airplay", d)), "download" === a) {
                                const e = I({}, d, {
                                    element: "a",
                                    href: this.download,
                                    target: "_blank"
                                });
                                this.isHTML5 && (e.download = "");
                                const {
                                    download: t
                                } = this.config.urls;
                                !S.url(t) && this.isEmbed && I(e, {
                                    icon: `logo-${this.provider}`,
                                    label: this.provider
                                }), c.appendChild(i.call(this, "download", e))
                            }
                            "fullscreen" === a && c.appendChild(i.call(this, "fullscreen", d))
                        })), this.isHTML5 && a.call(this, fe.getQualityOptions.call(this)), o.call(this), c
                    },
                    inject() {
                        if (this.config.loadSprite) {
                            const e = Re.getIconUrl.call(this);
                            e.cors && we(e.url, "sprite-plyr")
                        }
                        this.id = Math.floor(1e4 * Math.random());
                        let e = null;
                        this.elements.controls = null;
                        const t = {
                            id: this.id,
                            seektime: this.config.seekTime,
                            title: this.config.title
                        };
                        let i, r = !0;
                        if (S.function(this.config.controls) && (this.config.controls = this.config.controls.call(this, t)), this.config.controls || (this.config.controls = []), S.element(this.config.controls) || S.string(this.config.controls) ? e = this.config.controls : (e = Re.create.call(this, {
                                id: this.id,
                                seektime: this.config.seekTime,
                                speed: this.speed,
                                quality: this.quality,
                                captions: Ie.getLabel.call(this)
                            }), r = !1), r && S.string(this.config.controls) && (e = (e => {
                                let i = e;
                                return Object.entries(t).forEach((([e, t]) => {
                                    i = pe(i, `{${e}}`, t)
                                })), i
                            })(e)), S.string(this.config.selectors.controls.container) && (i = document.querySelector(this.config.selectors.controls.container)), S.element(i) || (i = this.elements.container), i[S.element(e) ? "insertAdjacentElement" : "insertAdjacentHTML"]("afterbegin", e), S.element(this.elements.controls) || Re.findElements.call(this), !S.empty(this.elements.buttons)) {
                            const e = e => {
                                const t = this.config.classNames.controlPressed;
                                e.setAttribute("aria-pressed", "false"), Object.defineProperty(e, "pressed", {
                                    configurable: !0,
                                    enumerable: !0,
                                    get: () => j(e, t),
                                    set(i = !1) {
                                        H(e, t, i), e.setAttribute("aria-pressed", i ? "true" : "false")
                                    }
                                })
                            };
                            Object.values(this.elements.buttons).filter(Boolean).forEach((t => {
                                S.array(t) || S.nodeList(t) ? Array.from(t).filter(Boolean).forEach(e) : e(t)
                            }))
                        }
                        if (D.isEdge && R(i), this.config.tooltips.controls) {
                            const {
                                classNames: e,
                                selectors: t
                            } = this.config, i = `${t.controls.wrapper} ${t.labels} .${e.hidden}`, r = V.call(this, i);
                            Array.from(r).forEach((e => {
                                H(e, this.config.classNames.hidden, !1), H(e, this.config.classNames.tooltip, !0)
                            }))
                        }
                    },
                    setMediaMetadata() {
                        try {
                            "mediaSession" in navigator && (navigator.mediaSession.metadata = new window.MediaMetadata({
                                title: this.config.mediaMetadata.title,
                                artist: this.config.mediaMetadata.artist,
                                album: this.config.mediaMetadata.album,
                                artwork: this.config.mediaMetadata.artwork
                            }))
                        } catch (e) {}
                    },
                    setMarkers() {
                        var e, t;
                        if (!this.duration || this.elements.markers) return;
                        const i = null === (e = this.config.markers) || void 0 === e || null === (t = e.points) || void 0 === t ? void 0 : t.filter((({
                            time: e
                        }) => e > 0 && e < this.duration));
                        if (null == i || !i.length) return;
                        const r = document.createDocumentFragment(),
                            n = document.createDocumentFragment();
                        let s = null;
                        const a = `${this.config.classNames.tooltip}--visible`,
                            o = e => H(s, a, e);
                        i.forEach((e => {
                            const t = O("span", {
                                    class: this.config.classNames.marker
                                }, ""),
                                i = e.time / this.duration * 100 + "%";
                            s && (t.addEventListener("mouseenter", (() => {
                                e.label || (s.style.left = i, s.innerHTML = e.label, o(!0))
                            })), t.addEventListener("mouseleave", (() => {
                                o(!1)
                            }))), t.addEventListener("click", (() => {
                                this.currentTime = e.time
                            })), t.style.left = i, n.appendChild(t)
                        })), r.appendChild(n), this.config.tooltips.seek || (s = O("span", {
                            class: this.config.classNames.tooltip
                        }, ""), r.appendChild(s)), this.elements.markers = {
                            points: n,
                            tip: s
                        }, this.elements.progress.appendChild(r)
                    }
                };

                function De(e, t = !0) {
                    let i = e;
                    if (t) {
                        const e = document.createElement("a");
                        e.href = i, i = e.href
                    }
                    try {
                        return new URL(i)
                    } catch (e) {
                        return null
                    }
                }

                function Ce(e) {
                    const t = new URLSearchParams;
                    return S.object(e) && Object.entries(e).forEach((([e, i]) => {
                        t.set(e, i)
                    })), t
                }
                const Ie = {
                        setup() {
                            if (!this.supported.ui) return;
                            if (!this.isVideo || this.isYouTube || this.isHTML5 && !Y.textTracks) return void(S.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Re.setCaptionsMenu.call(this));
                            var e, t;
                            if (S.element(this.elements.captions) || (this.elements.captions = O("div", U(this.config.selectors.captions)), this.elements.captions.setAttribute("dir", "auto"), e = this.elements.captions, t = this.elements.wrapper, S.element(e) && S.element(t) && t.parentNode.insertBefore(e, t.nextSibling)), D.isIE && window.URL) {
                                const e = this.media.querySelectorAll("track");
                                Array.from(e).forEach((e => {
                                    const t = e.getAttribute("src"),
                                        i = De(t);
                                    null !== i && i.hostname !== window.location.href.hostname && ["http:", "https:"].includes(i.protocol) && Ae(t, "blob").then((t => {
                                        e.setAttribute("src", window.URL.createObjectURL(t))
                                    })).catch((() => {
                                        N(e)
                                    }))
                                }))
                            }
                            const i = ne((navigator.languages || [navigator.language || navigator.userLanguage || "en"]).map((e => e.split("-")[0])));
                            let r = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase();
                            "auto" === r && ([r] = i);
                            let n = this.storage.get("captions");
                            if (S.boolean(n) || ({
                                    active: n
                                } = this.config.captions), Object.assign(this.captions, {
                                    toggled: !1,
                                    active: n,
                                    language: r,
                                    languages: i
                                }), this.isHTML5) {
                                const e = this.config.captions.update ? "addtrack removetrack" : "removetrack";
                                Q.call(this, this.media.textTracks, e, Ie.update.bind(this))
                            }
                            setTimeout(Ie.update.bind(this), 0)
                        },
                        update() {
                            const e = Ie.getTracks.call(this, !0),
                                {
                                    active: t,
                                    language: i,
                                    meta: r,
                                    currentTrackNode: n
                                } = this.captions,
                                s = Boolean(e.find((e => e.language === i)));
                            this.isHTML5 && this.isVideo && e.filter((e => !r.get(e))).forEach((e => {
                                this.debug.log("Track added", e), r.set(e, {
                                    default: "showing" === e.mode
                                }), "showing" === e.mode && (e.mode = "hidden"), Q.call(this, e, "cuechange", (() => Ie.updateCues.call(this)))
                            })), (s && this.language !== i || !e.includes(n)) && (Ie.setLanguage.call(this, i), Ie.toggle.call(this, t && s)), this.elements && H(this.elements.container, this.config.classNames.captions.enabled, !S.empty(e)), S.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Re.setCaptionsMenu.call(this)
                        },
                        toggle(e, t = !0) {
                            if (!this.supported.ui) return;
                            const {
                                toggled: i
                            } = this.captions, r = this.config.classNames.captions.active, n = S.nullOrUndefined(e) ? !i : e;
                            if (n !== i) {
                                if (t || (this.captions.active = n, this.storage.set({
                                        captions: n
                                    })), !this.language && n && !t) {
                                    const e = Ie.getTracks.call(this),
                                        t = Ie.findTrack.call(this, [this.captions.language, ...this.captions.languages], !0);
                                    return this.captions.language = t.language, void Ie.set.call(this, e.indexOf(t))
                                }
                                this.elements.buttons.captions && (this.elements.buttons.captions.pressed = n), H(this.elements.container, r, n), this.captions.toggled = n, Re.updateSetting.call(this, "captions"), ee.call(this, this.media, n ? "captionsenabled" : "captionsdisabled")
                            }
                            setTimeout((() => {
                                n && this.captions.toggled && (this.captions.currentTrackNode.mode = "hidden")
                            }))
                        },
                        set(e, t = !0) {
                            const i = Ie.getTracks.call(this);
                            if (-1 !== e)
                                if (S.number(e))
                                    if (e in i) {
                                        if (this.captions.currentTrack !== e) {
                                            this.captions.currentTrack = e;
                                            const r = i[e],
                                                {
                                                    language: n
                                                } = r || {};
                                            this.captions.currentTrackNode = r, Re.updateSetting.call(this, "captions"), t || (this.captions.language = n, this.storage.set({
                                                language: n
                                            })), this.isVimeo && this.embed.enableTextTrack(n), ee.call(this, this.media, "languagechange")
                                        }
                                        Ie.toggle.call(this, !0, t), this.isHTML5 && this.isVideo && Ie.updateCues.call(this)
                                    } else this.debug.warn("Track not found", e);
                            else this.debug.warn("Invalid caption argument", e);
                            else Ie.toggle.call(this, !1, t)
                        },
                        setLanguage(e, t = !0) {
                            if (!S.string(e)) return void this.debug.warn("Invalid language argument", e);
                            const i = e.toLowerCase();
                            this.captions.language = i;
                            const r = Ie.getTracks.call(this),
                                n = Ie.findTrack.call(this, [i]);
                            Ie.set.call(this, r.indexOf(n), t)
                        },
                        getTracks(e = !1) {
                            return Array.from((this.media || {}).textTracks || []).filter((t => !this.isHTML5 || e || this.captions.meta.has(t))).filter((e => ["captions", "subtitles"].includes(e.kind)))
                        },
                        findTrack(e, t = !1) {
                            const i = Ie.getTracks.call(this),
                                r = e => Number((this.captions.meta.get(e) || {}).default),
                                n = Array.from(i).sort(((e, t) => r(t) - r(e)));
                            let s;
                            return e.every((e => (s = n.find((t => t.language === e)), !s))), s || (t ? n[0] : void 0)
                        },
                        getCurrentTrack() {
                            return Ie.getTracks.call(this)[this.currentTrack]
                        },
                        getLabel(e) {
                            let t = e;
                            return !S.track(t) && Y.textTracks && this.captions.toggled && (t = Ie.getCurrentTrack.call(this)), S.track(t) ? S.empty(t.label) ? S.empty(t.language) ? Te.get("enabled", this.config) : e.language.toUpperCase() : t.label : Te.get("disabled", this.config)
                        },
                        updateCues(e) {
                            if (!this.supported.ui) return;
                            if (!S.element(this.elements.captions)) return void this.debug.warn("No captions element to render to");
                            if (!S.nullOrUndefined(e) && !Array.isArray(e)) return void this.debug.warn("updateCues: Invalid input", e);
                            let t = e;
                            if (!t) {
                                const e = Ie.getCurrentTrack.call(this);
                                t = Array.from((e || {}).activeCues || []).map((e => e.getCueAsHTML())).map(ve)
                            }
                            const i = t.map((e => e.trim())).join("\n");
                            if (i !== this.elements.captions.innerHTML) {
                                F(this.elements.captions);
                                const e = O("span", U(this.config.selectors.caption));
                                e.innerHTML = i, this.elements.captions.appendChild(e), ee.call(this, this.media, "cuechange")
                            }
                        }
                    },
                    Pe = {
                        enabled: !0,
                        title: "",
                        debug: !1,
                        autoplay: !1,
                        autopause: !0,
                        playsinline: !0,
                        seekTime: 10,
                        volume: 1,
                        muted: !1,
                        duration: null,
                        displayDuration: !0,
                        invertTime: !0,
                        toggleInvert: !0,
                        ratio: null,
                        clickToPlay: !0,
                        hideControls: !0,
                        resetOnEnd: !1,
                        disableContextMenu: !0,
                        loadSprite: !0,
                        iconPrefix: "plyr",
                        iconUrl: "https://cdn.plyr.io/3.7.8/plyr.svg",
                        blankVideo: "https://cdn.plyr.io/static/blank.mp4",
                        quality: {
                            default: 576,
                            options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
                            forced: !1,
                            onChange: null
                        },
                        loop: {
                            active: !1
                        },
                        speed: {
                            selected: 1,
                            options: [.5, .75, 1, 1.25, 1.5, 1.75, 2, 4]
                        },
                        keyboard: {
                            focused: !0,
                            global: !1
                        },
                        tooltips: {
                            controls: !1,
                            seek: !0
                        },
                        captions: {
                            active: !1,
                            language: "auto",
                            update: !1
                        },
                        fullscreen: {
                            enabled: !0,
                            fallback: !0,
                            iosNative: !1
                        },
                        storage: {
                            enabled: !0,
                            key: "plyr"
                        },
                        controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "captions", "settings", "pip", "airplay", "fullscreen"],
                        settings: ["captions", "quality", "speed"],
                        i18n: {
                            restart: "Restart",
                            rewind: "Rewind {seektime}s",
                            play: "Play",
                            pause: "Pause",
                            fastForward: "Forward {seektime}s",
                            seek: "Seek",
                            seekLabel: "{currentTime} of {duration}",
                            played: "Played",
                            buffered: "Buffered",
                            currentTime: "Current time",
                            duration: "Duration",
                            volume: "Volume",
                            mute: "Mute",
                            unmute: "Unmute",
                            enableCaptions: "Enable captions",
                            disableCaptions: "Disable captions",
                            download: "Download",
                            enterFullscreen: "Enter fullscreen",
                            exitFullscreen: "Exit fullscreen",
                            frameTitle: "Player for {title}",
                            captions: "Captions",
                            settings: "Settings",
                            pip: "PIP",
                            menuBack: "Go back to previous menu",
                            speed: "Speed",
                            normal: "Normal",
                            quality: "Quality",
                            loop: "Loop",
                            start: "Start",
                            end: "End",
                            all: "All",
                            reset: "Reset",
                            disabled: "Disabled",
                            enabled: "Enabled",
                            advertisement: "Ad",
                            qualityBadge: {
                                2160: "4K",
                                1440: "HD",
                                1080: "HD",
                                720: "HD",
                                576: "SD",
                                480: "SD"
                            }
                        },
                        urls: {
                            download: null,
                            vimeo: {
                                sdk: "https://player.vimeo.com/api/player.js",
                                iframe: "https://player.vimeo.com/video/{0}?{1}",
                                api: "https://vimeo.com/api/oembed.json?url={0}"
                            },
                            youtube: {
                                sdk: "https://www.youtube.com/iframe_api",
                                api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}"
                            },
                            googleIMA: {
                                sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js"
                            }
                        },
                        listeners: {
                            seek: null,
                            play: null,
                            pause: null,
                            restart: null,
                            rewind: null,
                            fastForward: null,
                            mute: null,
                            volume: null,
                            captions: null,
                            download: null,
                            fullscreen: null,
                            pip: null,
                            airplay: null,
                            speed: null,
                            quality: null,
                            loop: null,
                            language: null
                        },
                        events: ["ended", "progress", "stalled", "playing", "waiting", "canplay", "canplaythrough", "loadstart", "loadeddata", "loadedmetadata", "timeupdate", "volumechange", "play", "pause", "error", "seeking", "seeked", "emptied", "ratechange", "cuechange", "download", "enterfullscreen", "exitfullscreen", "captionsenabled", "captionsdisabled", "languagechange", "controlshidden", "controlsshown", "ready", "statechange", "qualitychange", "adsloaded", "adscontentpause", "adscontentresume", "adstarted", "adsmidpoint", "adscomplete", "adsallcomplete", "adsimpression", "adsclick"],
                        selectors: {
                            editable: "input, textarea, select, [contenteditable]",
                            container: ".plyr",
                            controls: {
                                container: null,
                                wrapper: ".plyr__controls"
                            },
                            labels: "[data-plyr]",
                            buttons: {
                                play: '[data-plyr="play"]',
                                pause: '[data-plyr="pause"]',
                                restart: '[data-plyr="restart"]',
                                rewind: '[data-plyr="rewind"]',
                                fastForward: '[data-plyr="fast-forward"]',
                                mute: '[data-plyr="mute"]',
                                captions: '[data-plyr="captions"]',
                                download: '[data-plyr="download"]',
                                fullscreen: '[data-plyr="fullscreen"]',
                                pip: '[data-plyr="pip"]',
                                airplay: '[data-plyr="airplay"]',
                                settings: '[data-plyr="settings"]',
                                loop: '[data-plyr="loop"]'
                            },
                            inputs: {
                                seek: '[data-plyr="seek"]',
                                volume: '[data-plyr="volume"]',
                                speed: '[data-plyr="speed"]',
                                language: '[data-plyr="language"]',
                                quality: '[data-plyr="quality"]'
                            },
                            display: {
                                currentTime: ".plyr__time--current",
                                duration: ".plyr__time--duration",
                                buffer: ".plyr__progress__buffer",
                                loop: ".plyr__progress__loop",
                                volume: ".plyr__volume--display"
                            },
                            progress: ".plyr__progress",
                            captions: ".plyr__captions",
                            caption: ".plyr__caption"
                        },
                        classNames: {
                            type: "plyr--{0}",
                            provider: "plyr--{0}",
                            video: "plyr__video-wrapper",
                            embed: "plyr__video-embed",
                            videoFixedRatio: "plyr__video-wrapper--fixed-ratio",
                            embedContainer: "plyr__video-embed__container",
                            poster: "plyr__poster",
                            posterEnabled: "plyr__poster-enabled",
                            ads: "plyr__ads",
                            control: "plyr__control",
                            controlPressed: "plyr__control--pressed",
                            playing: "plyr--playing",
                            paused: "plyr--paused",
                            stopped: "plyr--stopped",
                            loading: "plyr--loading",
                            hover: "plyr--hover",
                            tooltip: "plyr__tooltip",
                            cues: "plyr__cues",
                            marker: "plyr__progress__marker",
                            hidden: "plyr__sr-only",
                            hideControls: "plyr--hide-controls",
                            isTouch: "plyr--is-touch",
                            uiSupported: "plyr--full-ui",
                            noTransition: "plyr--no-transition",
                            display: {
                                time: "plyr__time"
                            },
                            menu: {
                                value: "plyr__menu__value",
                                badge: "plyr__badge",
                                open: "plyr--menu-open"
                            },
                            captions: {
                                enabled: "plyr--captions-enabled",
                                active: "plyr--captions-active"
                            },
                            fullscreen: {
                                enabled: "plyr--fullscreen-enabled",
                                fallback: "plyr--fullscreen-fallback"
                            },
                            pip: {
                                supported: "plyr--pip-supported",
                                active: "plyr--pip-active"
                            },
                            airplay: {
                                supported: "plyr--airplay-supported",
                                active: "plyr--airplay-active"
                            },
                            previewThumbnails: {
                                thumbContainer: "plyr__preview-thumb",
                                thumbContainerShown: "plyr__preview-thumb--is-shown",
                                imageContainer: "plyr__preview-thumb__image-container",
                                timeContainer: "plyr__preview-thumb__time-container",
                                scrubbingContainer: "plyr__preview-scrubbing",
                                scrubbingContainerShown: "plyr__preview-scrubbing--is-shown"
                            }
                        },
                        attributes: {
                            embed: {
                                provider: "data-plyr-provider",
                                id: "data-plyr-embed-id",
                                hash: "data-plyr-embed-hash"
                            }
                        },
                        ads: {
                            enabled: !1,
                            publisherId: "",
                            tagUrl: ""
                        },
                        previewThumbnails: {
                            enabled: !1,
                            src: ""
                        },
                        vimeo: {
                            byline: !1,
                            portrait: !1,
                            title: !1,
                            speed: !0,
                            transparent: !1,
                            customControls: !0,
                            referrerPolicy: null,
                            premium: !1
                        },
                        youtube: {
                            rel: 0,
                            showinfo: 0,
                            iv_load_policy: 3,
                            modestbranding: 1,
                            customControls: !0,
                            noCookie: !1
                        },
                        mediaMetadata: {
                            title: "",
                            artist: "",
                            album: "",
                            artwork: []
                        },
                        markers: {
                            enabled: !1,
                            points: []
                        }
                    },
                    xe = "picture-in-picture",
                    Oe = "inline",
                    Me = {
                        html5: "html5",
                        youtube: "youtube",
                        vimeo: "vimeo"
                    },
                    Ne = "audio",
                    Fe = "video",
                    Be = () => {};
                class Ue {
                    constructor(e = !1) {
                        this.enabled = window.console && e, this.enabled && this.log("Debugging enabled")
                    }
                    get log() {
                        return this.enabled ? Function.prototype.bind.call(console.log, console) : Be
                    }
                    get warn() {
                        return this.enabled ? Function.prototype.bind.call(console.warn, console) : Be
                    }
                    get error() {
                        return this.enabled ? Function.prototype.bind.call(console.error, console) : Be
                    }
                }
                class $e {
                    constructor(t) {
                        e(this, "onChange", (() => {
                            if (!this.supported) return;
                            const e = this.player.elements.buttons.fullscreen;
                            S.element(e) && (e.pressed = this.active);
                            const t = this.target === this.player.media ? this.target : this.player.elements.container;
                            ee.call(this.player, t, this.active ? "enterfullscreen" : "exitfullscreen", !0)
                        })), e(this, "toggleFallback", ((e = !1) => {
                            if (e ? this.scrollPosition = {
                                    x: window.scrollX ? ? 0,
                                    y: window.scrollY ? ? 0
                                } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = e ? "hidden" : "", H(this.target, this.player.config.classNames.fullscreen.fallback, e), D.isIos) {
                                let t = document.head.querySelector('meta[name="viewport"]');
                                const i = "viewport-fit=cover";
                                t || (t = document.createElement("meta"), t.setAttribute("name", "viewport"));
                                const r = S.string(t.content) && t.content.includes(i);
                                e ? (this.cleanupViewport = !r, r || (t.content += `,${i}`)) : this.cleanupViewport && (t.content = t.content.split(",").filter((e => e.trim() !== i)).join(","))
                            }
                            this.onChange()
                        })), e(this, "trapFocus", (e => {
                            if (D.isIos || D.isIPadOS || !this.active || "Tab" !== e.key) return;
                            const t = document.activeElement,
                                i = V.call(this.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"),
                                [r] = i,
                                n = i[i.length - 1];
                            t !== n || e.shiftKey ? t === r && e.shiftKey && (n.focus(), e.preventDefault()) : (r.focus(), e.preventDefault())
                        })), e(this, "update", (() => {
                            if (this.supported) {
                                let e;
                                e = this.forceFallback ? "Fallback (forced)" : $e.nativeSupported ? "Native" : "Fallback", this.player.debug.log(`${e} fullscreen enabled`)
                            } else this.player.debug.log("Fullscreen not supported and fallback disabled");
                            H(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.supported)
                        })), e(this, "enter", (() => {
                            this.supported && (D.isIos && this.player.config.fullscreen.iosNative ? this.player.isVimeo ? this.player.embed.requestFullscreen() : this.target.webkitEnterFullscreen() : !$e.nativeSupported || this.forceFallback ? this.toggleFallback(!0) : this.prefix ? S.empty(this.prefix) || this.target[`${this.prefix}Request${this.property}`]() : this.target.requestFullscreen({
                                navigationUI: "hide"
                            }))
                        })), e(this, "exit", (() => {
                            if (this.supported)
                                if (D.isIos && this.player.config.fullscreen.iosNative) this.player.isVimeo ? this.player.embed.exitFullscreen() : this.target.webkitEnterFullscreen(), re(this.player.play());
                                else if (!$e.nativeSupported || this.forceFallback) this.toggleFallback(!1);
                            else if (this.prefix) {
                                if (!S.empty(this.prefix)) {
                                    const e = "moz" === this.prefix ? "Cancel" : "Exit";
                                    document[`${this.prefix}${e}${this.property}`]()
                                }
                            } else(document.cancelFullScreen || document.exitFullscreen).call(document)
                        })), e(this, "toggle", (() => {
                            this.active ? this.exit() : this.enter()
                        })), this.player = t, this.prefix = $e.prefix, this.property = $e.property, this.scrollPosition = {
                            x: 0,
                            y: 0
                        }, this.forceFallback = "force" === t.config.fullscreen.fallback, this.player.elements.fullscreen = t.config.fullscreen.container && function(e, t) {
                            const {
                                prototype: i
                            } = Element;
                            return (i.closest || function() {
                                let e = this;
                                do {
                                    if (G.matches(e, t)) return e;
                                    e = e.parentElement || e.parentNode
                                } while (null !== e && 1 === e.nodeType);
                                return null
                            }).call(e, t)
                        }(this.player.elements.container, t.config.fullscreen.container), Q.call(this.player, document, "ms" === this.prefix ? "MSFullscreenChange" : `${this.prefix}fullscreenchange`, (() => {
                            this.onChange()
                        })), Q.call(this.player, this.player.elements.container, "dblclick", (e => {
                            S.element(this.player.elements.controls) && this.player.elements.controls.contains(e.target) || this.player.listeners.proxy(e, this.toggle, "fullscreen")
                        })), Q.call(this, this.player.elements.container, "keydown", (e => this.trapFocus(e))), this.update()
                    }
                    static get nativeSupported() {
                        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)
                    }
                    get useNative() {
                        return $e.nativeSupported && !this.forceFallback
                    }
                    static get prefix() {
                        if (S.function(document.exitFullscreen)) return "";
                        let e = "";
                        return ["webkit", "moz", "ms"].some((t => !(!S.function(document[`${t}ExitFullscreen`]) && !S.function(document[`${t}CancelFullScreen`]) || (e = t, 0)))), e
                    }
                    static get property() {
                        return "moz" === this.prefix ? "FullScreen" : "Fullscreen"
                    }
                    get supported() {
                        return [this.player.config.fullscreen.enabled, this.player.isVideo, $e.nativeSupported || this.player.config.fullscreen.fallback, !this.player.isYouTube || $e.nativeSupported || !D.isIos || this.player.config.playsinline && !this.player.config.fullscreen.iosNative].every(Boolean)
                    }
                    get active() {
                        if (!this.supported) return !1;
                        if (!$e.nativeSupported || this.forceFallback) return j(this.target, this.player.config.classNames.fullscreen.fallback);
                        const e = this.prefix ? this.target.getRootNode()[`${this.prefix}${this.property}Element`] : this.target.getRootNode().fullscreenElement;
                        return e && e.shadowRoot ? e === this.target.getRootNode().host : e === this.target
                    }
                    get target() {
                        return D.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen ? ? this.player.elements.container
                    }
                }

                function He(e, t = 1) {
                    return new Promise(((i, r) => {
                        const n = new Image,
                            s = () => {
                                delete n.onload, delete n.onerror, (n.naturalWidth >= t ? i : r)(n)
                            };
                        Object.assign(n, {
                            onload: s,
                            onerror: s,
                            src: e
                        })
                    }))
                }
                const je = {
                    addStyleHook() {
                        H(this.elements.container, this.config.selectors.container.replace(".", ""), !0), H(this.elements.container, this.config.classNames.uiSupported, this.supported.ui)
                    },
                    toggleNativeControls(e = !1) {
                        e && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls")
                    },
                    build() {
                        if (this.listeners.media(), !this.supported.ui) return this.debug.warn(`Basic support only for ${this.provider} ${this.type}`), void je.toggleNativeControls.call(this, !0);
                        S.element(this.elements.controls) || (Re.inject.call(this), this.listeners.controls()), je.toggleNativeControls.call(this), this.isHTML5 && Ie.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, Re.updateVolume.call(this), Re.timeUpdate.call(this), Re.durationUpdate.call(this), je.checkPlaying.call(this), H(this.elements.container, this.config.classNames.pip.supported, Y.pip && this.isHTML5 && this.isVideo), H(this.elements.container, this.config.classNames.airplay.supported, Y.airplay && this.isHTML5), H(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout((() => {
                            ee.call(this, this.media, "ready")
                        }), 0), je.setTitle.call(this), this.poster && je.setPoster.call(this, this.poster, !1).catch((() => {})), this.config.duration && Re.durationUpdate.call(this), this.config.mediaMetadata && Re.setMediaMetadata.call(this)
                    },
                    setTitle() {
                        let e = Te.get("play", this.config);
                        if (S.string(this.config.title) && !S.empty(this.config.title) && (e += `, ${this.config.title}`), Array.from(this.elements.buttons.play || []).forEach((t => {
                                t.setAttribute("aria-label", e)
                            })), this.isEmbed) {
                            const e = q.call(this, "iframe");
                            if (!S.element(e)) return;
                            const t = S.empty(this.config.title) ? "video" : this.config.title,
                                i = Te.get("frameTitle", this.config);
                            e.setAttribute("title", i.replace("{title}", t))
                        }
                    },
                    togglePoster(e) {
                        H(this.elements.container, this.config.classNames.posterEnabled, e)
                    },
                    setPoster(e, t = !0) {
                        return t && this.poster ? Promise.reject(new Error("Poster already set")) : (this.media.setAttribute("data-poster", e), this.elements.poster.removeAttribute("hidden"), ie.call(this).then((() => He(e))).catch((t => {
                            throw e === this.poster && je.togglePoster.call(this, !1), t
                        })).then((() => {
                            if (e !== this.poster) throw new Error("setPoster cancelled by later call to setPoster")
                        })).then((() => (Object.assign(this.elements.poster.style, {
                            backgroundImage: `url('${e}')`,
                            backgroundSize: ""
                        }), je.togglePoster.call(this, !0), e))))
                    },
                    checkPlaying(e) {
                        H(this.elements.container, this.config.classNames.playing, this.playing), H(this.elements.container, this.config.classNames.paused, this.paused), H(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach((e => {
                            Object.assign(e, {
                                pressed: this.playing
                            }), e.setAttribute("aria-label", Te.get(this.playing ? "pause" : "play", this.config))
                        })), S.event(e) && "timeupdate" === e.type || je.toggleControls.call(this)
                    },
                    checkLoading(e) {
                        this.loading = ["stalled", "waiting"].includes(e.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout((() => {
                            H(this.elements.container, this.config.classNames.loading, this.loading), je.toggleControls.call(this)
                        }), this.loading ? 250 : 0)
                    },
                    toggleControls(e) {
                        const {
                            controls: t
                        } = this.elements;
                        if (t && this.config.hideControls) {
                            const i = this.touch && this.lastSeekTime + 2e3 > Date.now();
                            this.toggleControls(Boolean(e || this.loading || this.paused || t.pressed || t.hover || i))
                        }
                    },
                    migrateStyles() {
                        Object.values({ ...this.media.style
                        }).filter((e => !S.empty(e) && S.string(e) && e.startsWith("--plyr"))).forEach((e => {
                            this.elements.container.style.setProperty(e, this.media.style.getPropertyValue(e)), this.media.style.removeProperty(e)
                        })), S.empty(this.media.style) && this.media.removeAttribute("style")
                    }
                };
                class Ge {
                    constructor(t) {
                        e(this, "firstTouch", (() => {
                            const {
                                player: e
                            } = this, {
                                elements: t
                            } = e;
                            e.touch = !0, H(t.container, e.config.classNames.isTouch, !0)
                        })), e(this, "global", ((e = !0) => {
                            const {
                                player: t
                            } = this;
                            t.config.keyboard.global && X.call(t, window, "keydown keyup", this.handleKey, e, !1), X.call(t, document.body, "click", this.toggleMenu, e), Z.call(t, document.body, "touchstart", this.firstTouch)
                        })), e(this, "container", (() => {
                            const {
                                player: e
                            } = this, {
                                config: t,
                                elements: i,
                                timers: r
                            } = e;
                            !t.keyboard.global && t.keyboard.focused && Q.call(e, i.container, "keydown keyup", this.handleKey, !1), Q.call(e, i.container, "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen", (t => {
                                const {
                                    controls: n
                                } = i;
                                n && "enterfullscreen" === t.type && (n.pressed = !1, n.hover = !1);
                                let s = 0;
                                ["touchstart", "touchmove", "mousemove"].includes(t.type) && (je.toggleControls.call(e, !0), s = e.touch ? 3e3 : 2e3), clearTimeout(r.controls), r.controls = setTimeout((() => je.toggleControls.call(e, !1)), s)
                            }));
                            const n = () => {
                                    if (!e.isVimeo || e.config.vimeo.premium) return;
                                    const t = i.wrapper,
                                        {
                                            active: r
                                        } = e.fullscreen,
                                        [n, s] = de.call(e),
                                        a = ae(`aspect-ratio: ${n} / ${s}`);
                                    if (!r) return void(a ? (t.style.width = null, t.style.height = null) : (t.style.maxWidth = null, t.style.margin = null));
                                    const [o, l] = [Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)], c = o / l > n / s;
                                    a ? (t.style.width = c ? "auto" : "100%", t.style.height = c ? "100%" : "auto") : (t.style.maxWidth = c ? l / s * n + "px" : null, t.style.margin = c ? "0 auto" : null)
                                },
                                s = () => {
                                    clearTimeout(r.resized), r.resized = setTimeout(n, 50)
                                };
                            Q.call(e, i.container, "enterfullscreen exitfullscreen", (t => {
                                const {
                                    target: r
                                } = e.fullscreen;
                                r === i.container && (!e.isEmbed && S.empty(e.config.ratio) || (n(), ("enterfullscreen" === t.type ? Q : J).call(e, window, "resize", s)))
                            }))
                        })), e(this, "media", (() => {
                            const {
                                player: e
                            } = this, {
                                elements: t
                            } = e;
                            if (Q.call(e, e.media, "timeupdate seeking seeked", (t => Re.timeUpdate.call(e, t))), Q.call(e, e.media, "durationchange loadeddata loadedmetadata", (t => Re.durationUpdate.call(e, t))), Q.call(e, e.media, "ended", (() => {
                                    e.isHTML5 && e.isVideo && e.config.resetOnEnd && (e.restart(), e.pause())
                                })), Q.call(e, e.media, "progress playing seeking seeked", (t => Re.updateProgress.call(e, t))), Q.call(e, e.media, "volumechange", (t => Re.updateVolume.call(e, t))), Q.call(e, e.media, "playing play pause ended emptied timeupdate", (t => je.checkPlaying.call(e, t))), Q.call(e, e.media, "waiting canplay seeked playing", (t => je.checkLoading.call(e, t))), e.supported.ui && e.config.clickToPlay && !e.isAudio) {
                                const i = q.call(e, `.${e.config.classNames.video}`);
                                if (!S.element(i)) return;
                                Q.call(e, t.container, "click", (r => {
                                    ([t.container, i].includes(r.target) || i.contains(r.target)) && (e.touch && e.config.hideControls || (e.ended ? (this.proxy(r, e.restart, "restart"), this.proxy(r, (() => {
                                        re(e.play())
                                    }), "play")) : this.proxy(r, (() => {
                                        re(e.togglePlay())
                                    }), "play")))
                                }))
                            }
                            e.supported.ui && e.config.disableContextMenu && Q.call(e, t.wrapper, "contextmenu", (e => {
                                e.preventDefault()
                            }), !1), Q.call(e, e.media, "volumechange", (() => {
                                e.storage.set({
                                    volume: e.volume,
                                    muted: e.muted
                                })
                            })), Q.call(e, e.media, "ratechange", (() => {
                                Re.updateSetting.call(e, "speed"), e.storage.set({
                                    speed: e.speed
                                })
                            })), Q.call(e, e.media, "qualitychange", (t => {
                                Re.updateSetting.call(e, "quality", null, t.detail.quality)
                            })), Q.call(e, e.media, "ready qualitychange", (() => {
                                Re.setDownloadUrl.call(e)
                            }));
                            const i = e.config.events.concat(["keyup", "keydown"]).join(" ");
                            Q.call(e, e.media, i, (i => {
                                let {
                                    detail: r = {}
                                } = i;
                                "error" === i.type && (r = e.media.error), ee.call(e, t.container, i.type, !0, r)
                            }))
                        })), e(this, "proxy", ((e, t, i) => {
                            const {
                                player: r
                            } = this, n = r.config.listeners[i];
                            let s = !0;
                            S.function(n) && (s = n.call(r, e)), !1 !== s && S.function(t) && t.call(r, e)
                        })), e(this, "bind", ((e, t, i, r, n = !0) => {
                            const {
                                player: s
                            } = this, a = s.config.listeners[r], o = S.function(a);
                            Q.call(s, e, t, (e => this.proxy(e, i, r)), n && !o)
                        })), e(this, "controls", (() => {
                            const {
                                player: e
                            } = this, {
                                elements: t
                            } = e, i = D.isIE ? "change" : "input";
                            if (t.buttons.play && Array.from(t.buttons.play).forEach((t => {
                                    this.bind(t, "click", (() => {
                                        re(e.togglePlay())
                                    }), "play")
                                })), this.bind(t.buttons.restart, "click", e.restart, "restart"), this.bind(t.buttons.rewind, "click", (() => {
                                    e.lastSeekTime = Date.now(), e.rewind()
                                }), "rewind"), this.bind(t.buttons.fastForward, "click", (() => {
                                    e.lastSeekTime = Date.now(), e.forward()
                                }), "fastForward"), this.bind(t.buttons.mute, "click", (() => {
                                    e.muted = !e.muted
                                }), "mute"), this.bind(t.buttons.captions, "click", (() => e.toggleCaptions())), this.bind(t.buttons.download, "click", (() => {
                                    ee.call(e, e.media, "download")
                                }), "download"), this.bind(t.buttons.fullscreen, "click", (() => {
                                    e.fullscreen.toggle()
                                }), "fullscreen"), this.bind(t.buttons.pip, "click", (() => {
                                    e.pip = "toggle"
                                }), "pip"), this.bind(t.buttons.airplay, "click", e.airplay, "airplay"), this.bind(t.buttons.settings, "click", (t => {
                                    t.stopPropagation(), t.preventDefault(), Re.toggleMenu.call(e, t)
                                }), null, !1), this.bind(t.buttons.settings, "keyup", (t => {
                                    [" ", "Enter"].includes(t.key) && ("Enter" !== t.key ? (t.preventDefault(), t.stopPropagation(), Re.toggleMenu.call(e, t)) : Re.focusFirstMenuItem.call(e, null, !0))
                                }), null, !1), this.bind(t.settings.menu, "keydown", (t => {
                                    "Escape" === t.key && Re.toggleMenu.call(e, t)
                                })), this.bind(t.inputs.seek, "mousedown mousemove", (e => {
                                    const i = t.progress.getBoundingClientRect(),
                                        r = 100 / i.width * (e.pageX - i.left);
                                    e.currentTarget.setAttribute("seek-value", r)
                                })), this.bind(t.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", (t => {
                                    const i = t.currentTarget,
                                        r = "play-on-seeked";
                                    if (S.keyboardEvent(t) && !["ArrowLeft", "ArrowRight"].includes(t.key)) return;
                                    e.lastSeekTime = Date.now();
                                    const n = i.hasAttribute(r),
                                        s = ["mouseup", "touchend", "keyup"].includes(t.type);
                                    n && s ? (i.removeAttribute(r), re(e.play())) : !s && e.playing && (i.setAttribute(r, ""), e.pause())
                                })), D.isIos) {
                                const t = V.call(e, 'input[type="range"]');
                                Array.from(t).forEach((e => this.bind(e, i, (e => R(e.target)))))
                            }
                            this.bind(t.inputs.seek, i, (t => {
                                const i = t.currentTarget;
                                let r = i.getAttribute("seek-value");
                                S.empty(r) && (r = i.value), i.removeAttribute("seek-value"), e.currentTime = r / i.max * e.duration
                            }), "seek"), this.bind(t.progress, "mouseenter mouseleave mousemove", (t => Re.updateSeekTooltip.call(e, t))), this.bind(t.progress, "mousemove touchmove", (t => {
                                const {
                                    previewThumbnails: i
                                } = e;
                                i && i.loaded && i.startMove(t)
                            })), this.bind(t.progress, "mouseleave touchend click", (() => {
                                const {
                                    previewThumbnails: t
                                } = e;
                                t && t.loaded && t.endMove(!1, !0)
                            })), this.bind(t.progress, "mousedown touchstart", (t => {
                                const {
                                    previewThumbnails: i
                                } = e;
                                i && i.loaded && i.startScrubbing(t)
                            })), this.bind(t.progress, "mouseup touchend", (t => {
                                const {
                                    previewThumbnails: i
                                } = e;
                                i && i.loaded && i.endScrubbing(t)
                            })), D.isWebKit && Array.from(V.call(e, 'input[type="range"]')).forEach((t => {
                                this.bind(t, "input", (t => Re.updateRangeFill.call(e, t.target)))
                            })), e.config.toggleInvert && !S.element(t.display.duration) && this.bind(t.display.currentTime, "click", (() => {
                                0 !== e.currentTime && (e.config.invertTime = !e.config.invertTime, Re.timeUpdate.call(e))
                            })), this.bind(t.inputs.volume, i, (t => {
                                e.volume = t.target.value
                            }), "volume"), this.bind(t.controls, "mouseenter mouseleave", (i => {
                                t.controls.hover = !e.touch && "mouseenter" === i.type
                            })), t.fullscreen && Array.from(t.fullscreen.children).filter((e => !e.contains(t.container))).forEach((i => {
                                this.bind(i, "mouseenter mouseleave", (i => {
                                    t.controls && (t.controls.hover = !e.touch && "mouseenter" === i.type)
                                }))
                            })), this.bind(t.controls, "mousedown mouseup touchstart touchend touchcancel", (e => {
                                t.controls.pressed = ["mousedown", "touchstart"].includes(e.type)
                            })), this.bind(t.controls, "focusin", (() => {
                                const {
                                    config: i,
                                    timers: r
                                } = e;
                                H(t.controls, i.classNames.noTransition, !0), je.toggleControls.call(e, !0), setTimeout((() => {
                                    H(t.controls, i.classNames.noTransition, !1)
                                }), 0);
                                const n = this.touch ? 3e3 : 4e3;
                                clearTimeout(r.controls), r.controls = setTimeout((() => je.toggleControls.call(e, !1)), n)
                            })), this.bind(t.inputs.volume, "wheel", (t => {
                                const i = t.webkitDirectionInvertedFromDevice,
                                    [r, n] = [t.deltaX, -t.deltaY].map((e => i ? -e : e)),
                                    s = Math.sign(Math.abs(r) > Math.abs(n) ? r : n);
                                e.increaseVolume(s / 50);
                                const {
                                    volume: a
                                } = e.media;
                                (1 === s && a < 1 || -1 === s && a > 0) && t.preventDefault()
                            }), "volume", !1)
                        })), this.player = t, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.firstTouch = this.firstTouch.bind(this)
                    }
                    handleKey(e) {
                        const {
                            player: t
                        } = this, {
                            elements: i
                        } = t, {
                            key: r,
                            type: n,
                            altKey: s,
                            ctrlKey: a,
                            metaKey: o,
                            shiftKey: l
                        } = e, c = "keydown" === n, d = c && r === this.lastKey;
                        var u;
                        if (!(s || a || o || l) && r)
                            if (c) {
                                const n = document.activeElement;
                                if (S.element(n)) {
                                    const {
                                        editable: r
                                    } = t.config.selectors, {
                                        seek: s
                                    } = i.inputs;
                                    if (n !== s && G(n, r)) return;
                                    if (" " === e.key && G(n, 'button, [role^="menuitem"]')) return
                                }
                                switch ([" ", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "c", "f", "k", "l", "m"].includes(r) && (e.preventDefault(), e.stopPropagation()), r) {
                                    case "0":
                                    case "1":
                                    case "2":
                                    case "3":
                                    case "4":
                                    case "5":
                                    case "6":
                                    case "7":
                                    case "8":
                                    case "9":
                                        d || (u = parseInt(r, 10), t.currentTime = t.duration / 10 * u);
                                        break;
                                    case " ":
                                    case "k":
                                        d || re(t.togglePlay());
                                        break;
                                    case "ArrowUp":
                                        t.increaseVolume(.1);
                                        break;
                                    case "ArrowDown":
                                        t.decreaseVolume(.1);
                                        break;
                                    case "m":
                                        d || (t.muted = !t.muted);
                                        break;
                                    case "ArrowRight":
                                        t.forward();
                                        break;
                                    case "ArrowLeft":
                                        t.rewind();
                                        break;
                                    case "f":
                                        t.fullscreen.toggle();
                                        break;
                                    case "c":
                                        d || t.toggleCaptions();
                                        break;
                                    case "l":
                                        t.loop = !t.loop
                                }
                                "Escape" === r && !t.fullscreen.usingNative && t.fullscreen.active && t.fullscreen.toggle(), this.lastKey = r
                            } else this.lastKey = null
                    }
                    toggleMenu(e) {
                        Re.toggleMenu.call(this.player, e)
                    }
                }
                "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self && self;
                var Ve = function(e, t) {
                    return e(t = {
                        exports: {}
                    }, t.exports), t.exports
                }((function(e, t) {
                    e.exports = function() {
                        var e = function() {},
                            t = {},
                            i = {},
                            r = {};

                        function n(e, t) {
                            e = e.push ? e : [e];
                            var n, s, a, o = [],
                                l = e.length,
                                c = l;
                            for (n = function(e, i) {
                                    i.length && o.push(e), --c || t(o)
                                }; l--;) s = e[l], (a = i[s]) ? n(s, a) : (r[s] = r[s] || []).push(n)
                        }

                        function s(e, t) {
                            if (e) {
                                var n = r[e];
                                if (i[e] = t, n)
                                    for (; n.length;) n[0](e, t), n.splice(0, 1)
                            }
                        }

                        function a(t, i) {
                            t.call && (t = {
                                success: t
                            }), i.length ? (t.error || e)(i) : (t.success || e)(t)
                        }

                        function o(t, i, r, n) {
                            var s, a, l = document,
                                c = r.async,
                                d = (r.numRetries || 0) + 1,
                                u = r.before || e,
                                h = t.replace(/[\?|#].*$/, ""),
                                f = t.replace(/^(css|img)!/, "");
                            n = n || 0, /(^css!|\.css$)/.test(h) ? ((a = l.createElement("link")).rel = "stylesheet", a.href = f, (s = "hideFocus" in a) && a.relList && (s = 0, a.rel = "preload", a.as = "style")) : /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(h) ? (a = l.createElement("img")).src = f : ((a = l.createElement("script")).src = t, a.async = void 0 === c || c), a.onload = a.onerror = a.onbeforeload = function(e) {
                                var l = e.type[0];
                                if (s) try {
                                    a.sheet.cssText.length || (l = "e")
                                } catch (e) {
                                    18 != e.code && (l = "e")
                                }
                                if ("e" == l) {
                                    if ((n += 1) < d) return o(t, i, r, n)
                                } else if ("preload" == a.rel && "style" == a.as) return a.rel = "stylesheet";
                                i(t, l, e.defaultPrevented)
                            }, !1 !== u(t, a) && l.head.appendChild(a)
                        }

                        function l(e, t, i) {
                            var r, n, s = (e = e.push ? e : [e]).length,
                                a = s,
                                l = [];
                            for (r = function(e, i, r) {
                                    if ("e" == i && l.push(e), "b" == i) {
                                        if (!r) return;
                                        l.push(e)
                                    }--s || t(l)
                                }, n = 0; n < a; n++) o(e[n], r, i)
                        }

                        function c(e, i, r) {
                            var n, o;
                            if (i && i.trim && (n = i), o = (n ? r : i) || {}, n) {
                                if (n in t) throw "LoadJS";
                                t[n] = !0
                            }

                            function c(t, i) {
                                l(e, (function(e) {
                                    a(o, e), t && a({
                                        success: t,
                                        error: i
                                    }, e), s(n, e)
                                }), o)
                            }
                            if (o.returnPromise) return new Promise(c);
                            c()
                        }
                        return c.ready = function(e, t) {
                            return n(e, (function(e) {
                                a(t, e)
                            })), c
                        }, c.done = function(e) {
                            s(e, [])
                        }, c.reset = function() {
                            t = {}, i = {}, r = {}
                        }, c.isDefined = function(e) {
                            return e in t
                        }, c
                    }()
                }));

                function qe(e) {
                    return new Promise(((t, i) => {
                        Ve(e, {
                            success: t,
                            error: i
                        })
                    }))
                }

                function Ke(e) {
                    e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, ee.call(this, this.media, e ? "play" : "pause"))
                }
                const We = {
                    setup() {
                        const e = this;
                        H(e.elements.wrapper, e.config.classNames.embed, !0), e.options.speed = e.config.speed.options, ue.call(e), S.object(window.Vimeo) ? We.ready.call(e) : qe(e.config.urls.vimeo.sdk).then((() => {
                            We.ready.call(e)
                        })).catch((t => {
                            e.debug.warn("Vimeo SDK (player.js) failed to load", t)
                        }))
                    },
                    ready() {
                        const e = this,
                            t = e.config.vimeo,
                            {
                                premium: i,
                                referrerPolicy: r,
                                ...n
                            } = t;
                        let s = e.media.getAttribute("src"),
                            a = "";
                        S.empty(s) ? (s = e.media.getAttribute(e.config.attributes.embed.id), a = e.media.getAttribute(e.config.attributes.embed.hash)) : a = function(e) {
                            const t = e.match(/^.*(vimeo.com\/|video\/)(\d+)(\?.*&*h=|\/)+([\d,a-f]+)/);
                            return t && 5 === t.length ? t[4] : null
                        }(s);
                        const o = a ? {
                            h: a
                        } : {};
                        i && Object.assign(n, {
                            controls: !1,
                            sidedock: !1
                        });
                        const l = Ce({
                                loop: e.config.loop.active,
                                autoplay: e.autoplay,
                                muted: e.muted,
                                gesture: "media",
                                playsinline: e.config.playsinline,
                                ...o,
                                ...n
                            }),
                            c = (d = s, S.empty(d) ? null : S.number(Number(d)) ? d : d.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : d);
                        var d;
                        const u = O("iframe"),
                            h = me(e.config.urls.vimeo.iframe, c, l);
                        if (u.setAttribute("src", h), u.setAttribute("allowfullscreen", ""), u.setAttribute("allow", ["autoplay", "fullscreen", "picture-in-picture", "encrypted-media", "accelerometer", "gyroscope"].join("; ")), S.empty(r) || u.setAttribute("referrerPolicy", r), i || !t.customControls) u.setAttribute("data-poster", e.poster), e.media = B(u, e.media);
                        else {
                            const t = O("div", {
                                class: e.config.classNames.embedContainer,
                                "data-poster": e.poster
                            });
                            t.appendChild(u), e.media = B(t, e.media)
                        }
                        t.customControls || Ae(me(e.config.urls.vimeo.api, h)).then((t => {
                            !S.empty(t) && t.thumbnail_url && je.setPoster.call(e, t.thumbnail_url).catch((() => {}))
                        })), e.embed = new window.Vimeo.Player(u, {
                            autopause: e.config.autopause,
                            muted: e.muted
                        }), e.media.paused = !0, e.media.currentTime = 0, e.supported.ui && e.embed.disableTextTrack(), e.media.play = () => (Ke.call(e, !0), e.embed.play()), e.media.pause = () => (Ke.call(e, !1), e.embed.pause()), e.media.stop = () => {
                            e.pause(), e.currentTime = 0
                        };
                        let {
                            currentTime: f
                        } = e.media;
                        Object.defineProperty(e.media, "currentTime", {
                            get: () => f,
                            set(t) {
                                const {
                                    embed: i,
                                    media: r,
                                    paused: n,
                                    volume: s
                                } = e, a = n && !i.hasPlayed;
                                r.seeking = !0, ee.call(e, r, "seeking"), Promise.resolve(a && i.setVolume(0)).then((() => i.setCurrentTime(t))).then((() => a && i.pause())).then((() => a && i.setVolume(s))).catch((() => {}))
                            }
                        });
                        let m = e.config.speed.selected;
                        Object.defineProperty(e.media, "playbackRate", {
                            get: () => m,
                            set(t) {
                                e.embed.setPlaybackRate(t).then((() => {
                                    m = t, ee.call(e, e.media, "ratechange")
                                })).catch((() => {
                                    e.options.speed = [1]
                                }))
                            }
                        });
                        let {
                            volume: p
                        } = e.config;
                        Object.defineProperty(e.media, "volume", {
                            get: () => p,
                            set(t) {
                                e.embed.setVolume(t).then((() => {
                                    p = t, ee.call(e, e.media, "volumechange")
                                }))
                            }
                        });
                        let {
                            muted: g
                        } = e.config;
                        Object.defineProperty(e.media, "muted", {
                            get: () => g,
                            set(t) {
                                const i = !!S.boolean(t) && t;
                                e.embed.setMuted(!!i || e.config.muted).then((() => {
                                    g = i, ee.call(e, e.media, "volumechange")
                                }))
                            }
                        });
                        let y, {
                            loop: v
                        } = e.config;
                        Object.defineProperty(e.media, "loop", {
                            get: () => v,
                            set(t) {
                                const i = S.boolean(t) ? t : e.config.loop.active;
                                e.embed.setLoop(i).then((() => {
                                    v = i
                                }))
                            }
                        }), e.embed.getVideoUrl().then((t => {
                            y = t, Re.setDownloadUrl.call(e)
                        })).catch((e => {
                            this.debug.warn(e)
                        })), Object.defineProperty(e.media, "currentSrc", {
                            get: () => y
                        }), Object.defineProperty(e.media, "ended", {
                            get: () => e.currentTime === e.duration
                        }), Promise.all([e.embed.getVideoWidth(), e.embed.getVideoHeight()]).then((t => {
                            const [i, r] = t;
                            e.embed.ratio = he(i, r), ue.call(this)
                        })), e.embed.setAutopause(e.config.autopause).then((t => {
                            e.config.autopause = t
                        })), e.embed.getVideoTitle().then((t => {
                            e.config.title = t, je.setTitle.call(this)
                        })), e.embed.getCurrentTime().then((t => {
                            f = t, ee.call(e, e.media, "timeupdate")
                        })), e.embed.getDuration().then((t => {
                            e.media.duration = t, ee.call(e, e.media, "durationchange")
                        })), e.embed.getTextTracks().then((t => {
                            e.media.textTracks = t, Ie.setup.call(e)
                        })), e.embed.on("cuechange", (({
                            cues: t = []
                        }) => {
                            const i = t.map((e => function(e) {
                                const t = document.createDocumentFragment(),
                                    i = document.createElement("div");
                                return t.appendChild(i), i.innerHTML = e, t.firstChild.innerText
                            }(e.text)));
                            Ie.updateCues.call(e, i)
                        })), e.embed.on("loaded", (() => {
                            e.embed.getPaused().then((t => {
                                Ke.call(e, !t), t || ee.call(e, e.media, "playing")
                            })), S.element(e.embed.element) && e.supported.ui && e.embed.element.setAttribute("tabindex", -1)
                        })), e.embed.on("bufferstart", (() => {
                            ee.call(e, e.media, "waiting")
                        })), e.embed.on("bufferend", (() => {
                            ee.call(e, e.media, "playing")
                        })), e.embed.on("play", (() => {
                            Ke.call(e, !0), ee.call(e, e.media, "playing")
                        })), e.embed.on("pause", (() => {
                            Ke.call(e, !1)
                        })), e.embed.on("timeupdate", (t => {
                            e.media.seeking = !1, f = t.seconds, ee.call(e, e.media, "timeupdate")
                        })), e.embed.on("progress", (t => {
                            e.media.buffered = t.percent, ee.call(e, e.media, "progress"), 1 === parseInt(t.percent, 10) && ee.call(e, e.media, "canplaythrough"), e.embed.getDuration().then((t => {
                                t !== e.media.duration && (e.media.duration = t, ee.call(e, e.media, "durationchange"))
                            }))
                        })), e.embed.on("seeked", (() => {
                            e.media.seeking = !1, ee.call(e, e.media, "seeked")
                        })), e.embed.on("ended", (() => {
                            e.media.paused = !0, ee.call(e, e.media, "ended")
                        })), e.embed.on("error", (t => {
                            e.media.error = t, ee.call(e, e.media, "error")
                        })), t.customControls && setTimeout((() => je.build.call(e)), 0)
                    }
                };

                function Ye(e) {
                    e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, ee.call(this, this.media, e ? "play" : "pause"))
                }

                function ze(e) {
                    return e.noCookie ? "https://www.youtube-nocookie.com" : "http:" === window.location.protocol ? "http://www.youtube.com" : void 0
                }
                const Xe = {
                        setup() {
                            if (H(this.elements.wrapper, this.config.classNames.embed, !0), S.object(window.YT) && S.function(window.YT.Player)) Xe.ready.call(this);
                            else {
                                const e = window.onYouTubeIframeAPIReady;
                                window.onYouTubeIframeAPIReady = () => {
                                    S.function(e) && e(), Xe.ready.call(this)
                                }, qe(this.config.urls.youtube.sdk).catch((e => {
                                    this.debug.warn("YouTube API failed to load", e)
                                }))
                            }
                        },
                        getTitle(e) {
                            Ae(me(this.config.urls.youtube.api, e)).then((e => {
                                if (S.object(e)) {
                                    const {
                                        title: t,
                                        height: i,
                                        width: r
                                    } = e;
                                    this.config.title = t, je.setTitle.call(this), this.embed.ratio = he(r, i)
                                }
                                ue.call(this)
                            })).catch((() => {
                                ue.call(this)
                            }))
                        },
                        ready() {
                            const e = this,
                                t = e.config.youtube,
                                i = e.media && e.media.getAttribute("id");
                            if (!S.empty(i) && i.startsWith("youtube-")) return;
                            let r = e.media.getAttribute("src");
                            S.empty(r) && (r = e.media.getAttribute(this.config.attributes.embed.id));
                            const n = (s = r, S.empty(s) ? null : s.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : s);
                            var s;
                            const a = O("div", {
                                id: `${e.provider}-${Math.floor(1e4*Math.random())}`,
                                "data-poster": t.customControls ? e.poster : void 0
                            });
                            if (e.media = B(a, e.media), t.customControls) {
                                const t = e => `https://i.ytimg.com/vi/${n}/${e}default.jpg`;
                                He(t("maxres"), 121).catch((() => He(t("sd"), 121))).catch((() => He(t("hq")))).then((t => je.setPoster.call(e, t.src))).then((t => {
                                    t.includes("maxres") || (e.elements.poster.style.backgroundSize = "cover")
                                })).catch((() => {}))
                            }
                            e.embed = new window.YT.Player(e.media, {
                                videoId: n,
                                host: ze(t),
                                playerVars: I({}, {
                                    autoplay: e.config.autoplay ? 1 : 0,
                                    hl: e.config.hl,
                                    controls: e.supported.ui && t.customControls ? 0 : 1,
                                    disablekb: 1,
                                    playsinline: e.config.playsinline && !e.config.fullscreen.iosNative ? 1 : 0,
                                    cc_load_policy: e.captions.active ? 1 : 0,
                                    cc_lang_pref: e.config.captions.language,
                                    widget_referrer: window ? window.location.href : null
                                }, t),
                                events: {
                                    onError(t) {
                                        if (!e.media.error) {
                                            const i = t.data,
                                                r = {
                                                    2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",
                                                    5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",
                                                    100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",
                                                    101: "The owner of the requested video does not allow it to be played in embedded players.",
                                                    150: "The owner of the requested video does not allow it to be played in embedded players."
                                                }[i] || "An unknown error occurred";
                                            e.media.error = {
                                                code: i,
                                                message: r
                                            }, ee.call(e, e.media, "error")
                                        }
                                    },
                                    onPlaybackRateChange(t) {
                                        const i = t.target;
                                        e.media.playbackRate = i.getPlaybackRate(), ee.call(e, e.media, "ratechange")
                                    },
                                    onReady(i) {
                                        if (S.function(e.media.play)) return;
                                        const r = i.target;
                                        Xe.getTitle.call(e, n), e.media.play = () => {
                                            Ye.call(e, !0), r.playVideo()
                                        }, e.media.pause = () => {
                                            Ye.call(e, !1), r.pauseVideo()
                                        }, e.media.stop = () => {
                                            r.stopVideo()
                                        }, e.media.duration = r.getDuration(), e.media.paused = !0, e.media.currentTime = 0, Object.defineProperty(e.media, "currentTime", {
                                            get: () => Number(r.getCurrentTime()),
                                            set(t) {
                                                e.paused && !e.embed.hasPlayed && e.embed.mute(), e.media.seeking = !0, ee.call(e, e.media, "seeking"), r.seekTo(t)
                                            }
                                        }), Object.defineProperty(e.media, "playbackRate", {
                                            get: () => r.getPlaybackRate(),
                                            set(e) {
                                                r.setPlaybackRate(e)
                                            }
                                        });
                                        let {
                                            volume: s
                                        } = e.config;
                                        Object.defineProperty(e.media, "volume", {
                                            get: () => s,
                                            set(t) {
                                                s = t, r.setVolume(100 * s), ee.call(e, e.media, "volumechange")
                                            }
                                        });
                                        let {
                                            muted: a
                                        } = e.config;
                                        Object.defineProperty(e.media, "muted", {
                                            get: () => a,
                                            set(t) {
                                                const i = S.boolean(t) ? t : a;
                                                a = i, r[i ? "mute" : "unMute"](), r.setVolume(100 * s), ee.call(e, e.media, "volumechange")
                                            }
                                        }), Object.defineProperty(e.media, "currentSrc", {
                                            get: () => r.getVideoUrl()
                                        }), Object.defineProperty(e.media, "ended", {
                                            get: () => e.currentTime === e.duration
                                        });
                                        const o = r.getAvailablePlaybackRates();
                                        e.options.speed = o.filter((t => e.config.speed.options.includes(t))), e.supported.ui && t.customControls && e.media.setAttribute("tabindex", -1), ee.call(e, e.media, "timeupdate"), ee.call(e, e.media, "durationchange"), clearInterval(e.timers.buffering), e.timers.buffering = setInterval((() => {
                                            e.media.buffered = r.getVideoLoadedFraction(), (null === e.media.lastBuffered || e.media.lastBuffered < e.media.buffered) && ee.call(e, e.media, "progress"), e.media.lastBuffered = e.media.buffered, 1 === e.media.buffered && (clearInterval(e.timers.buffering), ee.call(e, e.media, "canplaythrough"))
                                        }), 200), t.customControls && setTimeout((() => je.build.call(e)), 50)
                                    },
                                    onStateChange(i) {
                                        const r = i.target;
                                        switch (clearInterval(e.timers.playing), e.media.seeking && [1, 2].includes(i.data) && (e.media.seeking = !1, ee.call(e, e.media, "seeked")), i.data) {
                                            case -1:
                                                ee.call(e, e.media, "timeupdate"), e.media.buffered = r.getVideoLoadedFraction(), ee.call(e, e.media, "progress");
                                                break;
                                            case 0:
                                                Ye.call(e, !1), e.media.loop ? (r.stopVideo(), r.playVideo()) : ee.call(e, e.media, "ended");
                                                break;
                                            case 1:
                                                t.customControls && !e.config.autoplay && e.media.paused && !e.embed.hasPlayed ? e.media.pause() : (Ye.call(e, !0), ee.call(e, e.media, "playing"), e.timers.playing = setInterval((() => {
                                                    ee.call(e, e.media, "timeupdate")
                                                }), 50), e.media.duration !== r.getDuration() && (e.media.duration = r.getDuration(), ee.call(e, e.media, "durationchange")));
                                                break;
                                            case 2:
                                                e.muted || e.embed.unMute(), Ye.call(e, !1);
                                                break;
                                            case 3:
                                                ee.call(e, e.media, "waiting")
                                        }
                                        ee.call(e, e.elements.container, "statechange", !1, {
                                            code: i.data
                                        })
                                    }
                                }
                            })
                        }
                    },
                    Qe = {
                        setup() {
                            this.media ? (H(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0), H(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0), this.isEmbed && H(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0), this.isVideo && (this.elements.wrapper = O("div", {
                                class: this.config.classNames.video
                            }), P(this.media, this.elements.wrapper), this.elements.poster = O("div", {
                                class: this.config.classNames.poster
                            }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? fe.setup.call(this) : this.isYouTube ? Xe.setup.call(this) : this.isVimeo && We.setup.call(this)) : this.debug.warn("No media element found!")
                        }
                    };
                class Je {
                    constructor(t) {
                        e(this, "load", (() => {
                            this.enabled && (S.object(window.google) && S.object(window.google.ima) ? this.ready() : qe(this.player.config.urls.googleIMA.sdk).then((() => {
                                this.ready()
                            })).catch((() => {
                                this.trigger("error", new Error("Google IMA SDK failed to load"))
                            })))
                        })), e(this, "ready", (() => {
                            var e;
                            this.enabled || ((e = this).manager && e.manager.destroy(), e.elements.displayContainer && e.elements.displayContainer.destroy(), e.elements.container.remove()), this.startSafetyTimer(12e3, "ready()"), this.managerPromise.then((() => {
                                this.clearSafetyTimer("onAdsManagerLoaded()")
                            })), this.listeners(), this.setupIMA()
                        })), e(this, "setupIMA", (() => {
                            this.elements.container = O("div", {
                                class: this.player.config.classNames.ads
                            }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media), this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, (e => this.onAdsManagerLoaded(e)), !1), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (e => this.onAdError(e)), !1), this.requestAds()
                        })), e(this, "requestAds", (() => {
                            const {
                                container: e
                            } = this.player.elements;
                            try {
                                const t = new google.ima.AdsRequest;
                                t.adTagUrl = this.tagUrl, t.linearAdSlotWidth = e.offsetWidth, t.linearAdSlotHeight = e.offsetHeight, t.nonLinearAdSlotWidth = e.offsetWidth, t.nonLinearAdSlotHeight = e.offsetHeight, t.forceNonLinearFullSlot = !1, t.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(t)
                            } catch (e) {
                                this.onAdError(e)
                            }
                        })), e(this, "pollCountdown", ((e = !1) => {
                            if (!e) return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute("data-badge-text");
                            this.countdownTimer = setInterval((() => {
                                const e = Le(Math.max(this.manager.getRemainingTime(), 0)),
                                    t = `${Te.get("advertisement",this.player.config)} - ${e}`;
                                this.elements.container.setAttribute("data-badge-text", t)
                            }), 100)
                        })), e(this, "onAdsManagerLoaded", (e => {
                            if (!this.enabled) return;
                            const t = new google.ima.AdsRenderingSettings;
                            t.restoreCustomPlaybackStateOnAdBreakComplete = !0, t.enablePreloading = !0, this.manager = e.getAdsManager(this.player, t), this.cuePoints = this.manager.getCuePoints(), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (e => this.onAdError(e))), Object.keys(google.ima.AdEvent.Type).forEach((e => {
                                this.manager.addEventListener(google.ima.AdEvent.Type[e], (e => this.onAdEvent(e)))
                            })), this.trigger("loaded")
                        })), e(this, "addCuePoints", (() => {
                            S.empty(this.cuePoints) || this.cuePoints.forEach((e => {
                                if (0 !== e && -1 !== e && e < this.player.duration) {
                                    const t = this.player.elements.progress;
                                    if (S.element(t)) {
                                        const i = 100 / this.player.duration * e,
                                            r = O("span", {
                                                class: this.player.config.classNames.cues
                                            });
                                        r.style.left = `${i.toString()}%`, t.appendChild(r)
                                    }
                                }
                            }))
                        })), e(this, "onAdEvent", (e => {
                            const {
                                container: t
                            } = this.player.elements, i = e.getAd(), r = e.getAdData();
                            switch ((e => {
                                ee.call(this.player, this.player.media, `ads${e.replace(/_/g,"").toLowerCase()}`)
                            })(e.type), e.type) {
                                case google.ima.AdEvent.Type.LOADED:
                                    this.trigger("loaded"), this.pollCountdown(!0), i.isLinear() || (i.width = t.offsetWidth, i.height = t.offsetHeight);
                                    break;
                                case google.ima.AdEvent.Type.STARTED:
                                    this.manager.setVolume(this.player.volume);
                                    break;
                                case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                                    this.player.ended ? this.loadAds() : this.loader.contentComplete();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
                                    this.pauseContent();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
                                    this.pollCountdown(), this.resumeContent();
                                    break;
                                case google.ima.AdEvent.Type.LOG:
                                    r.adError && this.player.debug.warn(`Non-fatal ad error: ${r.adError.getMessage()}`)
                            }
                        })), e(this, "onAdError", (e => {
                            this.cancel(), this.player.debug.warn("Ads error", e)
                        })), e(this, "listeners", (() => {
                            const {
                                container: e
                            } = this.player.elements;
                            let t;
                            this.player.on("canplay", (() => {
                                this.addCuePoints()
                            })), this.player.on("ended", (() => {
                                this.loader.contentComplete()
                            })), this.player.on("timeupdate", (() => {
                                t = this.player.currentTime
                            })), this.player.on("seeked", (() => {
                                const e = this.player.currentTime;
                                S.empty(this.cuePoints) || this.cuePoints.forEach(((i, r) => {
                                    t < i && i < e && (this.manager.discardAdBreak(), this.cuePoints.splice(r, 1))
                                }))
                            })), window.addEventListener("resize", (() => {
                                this.manager && this.manager.resize(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL)
                            }))
                        })), e(this, "play", (() => {
                            const {
                                container: e
                            } = this.player.elements;
                            this.managerPromise || this.resumeContent(), this.managerPromise.then((() => {
                                this.manager.setVolume(this.player.volume), this.elements.displayContainer.initialize();
                                try {
                                    this.initialized || (this.manager.init(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL), this.manager.start()), this.initialized = !0
                                } catch (e) {
                                    this.onAdError(e)
                                }
                            })).catch((() => {}))
                        })), e(this, "resumeContent", (() => {
                            this.elements.container.style.zIndex = "", this.playing = !1, re(this.player.media.play())
                        })), e(this, "pauseContent", (() => {
                            this.elements.container.style.zIndex = 3, this.playing = !0, this.player.media.pause()
                        })), e(this, "cancel", (() => {
                            this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds()
                        })), e(this, "loadAds", (() => {
                            this.managerPromise.then((() => {
                                this.manager && this.manager.destroy(), this.managerPromise = new Promise((e => {
                                    this.on("loaded", e), this.player.debug.log(this.manager)
                                })), this.initialized = !1, this.requestAds()
                            })).catch((() => {}))
                        })), e(this, "trigger", ((e, ...t) => {
                            const i = this.events[e];
                            S.array(i) && i.forEach((e => {
                                S.function(e) && e.apply(this, t)
                            }))
                        })), e(this, "on", ((e, t) => (S.array(this.events[e]) || (this.events[e] = []), this.events[e].push(t), this))), e(this, "startSafetyTimer", ((e, t) => {
                            this.player.debug.log(`Safety timer invoked from: ${t}`), this.safetyTimer = setTimeout((() => {
                                this.cancel(), this.clearSafetyTimer("startSafetyTimer()")
                            }), e)
                        })), e(this, "clearSafetyTimer", (e => {
                            S.nullOrUndefined(this.safetyTimer) || (this.player.debug.log(`Safety timer cleared from: ${e}`), clearTimeout(this.safetyTimer), this.safetyTimer = null)
                        })), this.player = t, this.config = t.config.ads, this.playing = !1, this.initialized = !1, this.elements = {
                            container: null,
                            displayContainer: null
                        }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise(((e, t) => {
                            this.on("loaded", e), this.on("error", t)
                        })), this.load()
                    }
                    get enabled() {
                        const {
                            config: e
                        } = this;
                        return this.player.isHTML5 && this.player.isVideo && e.enabled && (!S.empty(e.publisherId) || S.url(e.tagUrl))
                    }
                    get tagUrl() {
                        const {
                            config: e
                        } = this;
                        return S.url(e.tagUrl) ? e.tagUrl : `https://go.aniview.com/api/adserver6/vast/?${Ce({AV_PUBLISHERID:"58c25bb0073ef448b1087ad6",AV_CHANNELID:"5a0458dc28a06145e4519d21",AV_URL:window.location.hostname,cb:Date.now(),AV_WIDTH:640,AV_HEIGHT:480,AV_CDIM2:e.publisherId})}`
                    }
                }

                function Ze(e = 0, t = 0, i = 255) {
                    return Math.min(Math.max(e, t), i)
                }
                const et = e => {
                        const t = [];
                        return e.split(/\r\n\r\n|\n\n|\r\r/).forEach((e => {
                            const i = {};
                            e.split(/\r\n|\n|\r/).forEach((e => {
                                if (S.number(i.startTime)) {
                                    if (!S.empty(e.trim()) && S.empty(i.text)) {
                                        const t = e.trim().split("#xywh=");
                                        [i.text] = t, t[1] && ([i.x, i.y, i.w, i.h] = t[1].split(","))
                                    }
                                } else {
                                    const t = e.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/);
                                    t && (i.startTime = 60 * Number(t[1] || 0) * 60 + 60 * Number(t[2]) + Number(t[3]) + Number(`0.${t[4]}`), i.endTime = 60 * Number(t[6] || 0) * 60 + 60 * Number(t[7]) + Number(t[8]) + Number(`0.${t[9]}`))
                                }
                            })), i.text && t.push(i)
                        })), t
                    },
                    tt = (e, t) => {
                        const i = {};
                        return e > t.width / t.height ? (i.width = t.width, i.height = 1 / e * t.width) : (i.height = t.height, i.width = e * t.height), i
                    };
                class it {
                    constructor(t) {
                        e(this, "load", (() => {
                            this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled), this.enabled && this.getThumbnails().then((() => {
                                this.enabled && (this.render(), this.determineContainerAutoSizing(), this.listeners(), this.loaded = !0)
                            }))
                        })), e(this, "getThumbnails", (() => new Promise((e => {
                            const {
                                src: t
                            } = this.player.config.previewThumbnails;
                            if (S.empty(t)) throw new Error("Missing previewThumbnails.src config attribute");
                            const i = () => {
                                this.thumbnails.sort(((e, t) => e.height - t.height)), this.player.debug.log("Preview thumbnails", this.thumbnails), e()
                            };
                            if (S.function(t)) t((e => {
                                this.thumbnails = e, i()
                            }));
                            else {
                                const e = (S.string(t) ? [t] : t).map((e => this.getThumbnail(e)));
                                Promise.all(e).then(i)
                            }
                        })))), e(this, "getThumbnail", (e => new Promise((t => {
                            Ae(e).then((i => {
                                const r = {
                                    frames: et(i),
                                    height: null,
                                    urlPrefix: ""
                                };
                                r.frames[0].text.startsWith("/") || r.frames[0].text.startsWith("http://") || r.frames[0].text.startsWith("https://") || (r.urlPrefix = e.substring(0, e.lastIndexOf("/") + 1));
                                const n = new Image;
                                n.onload = () => {
                                    r.height = n.naturalHeight, r.width = n.naturalWidth, this.thumbnails.push(r), t()
                                }, n.src = r.urlPrefix + r.frames[0].text
                            }))
                        })))), e(this, "startMove", (e => {
                            if (this.loaded && S.event(e) && ["touchmove", "mousemove"].includes(e.type) && this.player.media.duration) {
                                if ("touchmove" === e.type) this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);
                                else {
                                    var t, i;
                                    const r = this.player.elements.progress.getBoundingClientRect(),
                                        n = 100 / r.width * (e.pageX - r.left);
                                    this.seekTime = this.player.media.duration * (n / 100), this.seekTime < 0 && (this.seekTime = 0), this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1), this.mousePosX = e.pageX, this.elements.thumb.time.innerText = Le(this.seekTime);
                                    const s = null === (t = this.player.config.markers) || void 0 === t || null === (i = t.points) || void 0 === i ? void 0 : i.find((({
                                        time: e
                                    }) => e === Math.round(this.seekTime)));
                                    s && this.elements.thumb.time.insertAdjacentHTML("afterbegin", `${s.label}<br>`)
                                }
                                this.showImageAtCurrentTime()
                            }
                        })), e(this, "endMove", (() => {
                            this.toggleThumbContainer(!1, !0)
                        })), e(this, "startScrubbing", (e => {
                            (S.nullOrUndefined(e.button) || !1 === e.button || 0 === e.button) && (this.mouseDown = !0, this.player.media.duration && (this.toggleScrubbingContainer(!0), this.toggleThumbContainer(!1, !0), this.showImageAtCurrentTime()))
                        })), e(this, "endScrubbing", (() => {
                            this.mouseDown = !1, Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime) ? this.toggleScrubbingContainer(!1) : Z.call(this.player, this.player.media, "timeupdate", (() => {
                                this.mouseDown || this.toggleScrubbingContainer(!1)
                            }))
                        })), e(this, "listeners", (() => {
                            this.player.on("play", (() => {
                                this.toggleThumbContainer(!1, !0)
                            })), this.player.on("seeked", (() => {
                                this.toggleThumbContainer(!1)
                            })), this.player.on("timeupdate", (() => {
                                this.lastTime = this.player.media.currentTime
                            }))
                        })), e(this, "render", (() => {
                            this.elements.thumb.container = O("div", {
                                class: this.player.config.classNames.previewThumbnails.thumbContainer
                            }), this.elements.thumb.imageContainer = O("div", {
                                class: this.player.config.classNames.previewThumbnails.imageContainer
                            }), this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);
                            const e = O("div", {
                                class: this.player.config.classNames.previewThumbnails.timeContainer
                            });
                            this.elements.thumb.time = O("span", {}, "00:00"), e.appendChild(this.elements.thumb.time), this.elements.thumb.imageContainer.appendChild(e), S.element(this.player.elements.progress) && this.player.elements.progress.appendChild(this.elements.thumb.container), this.elements.scrubbing.container = O("div", {
                                class: this.player.config.classNames.previewThumbnails.scrubbingContainer
                            }), this.player.elements.wrapper.appendChild(this.elements.scrubbing.container)
                        })), e(this, "destroy", (() => {
                            this.elements.thumb.container && this.elements.thumb.container.remove(), this.elements.scrubbing.container && this.elements.scrubbing.container.remove()
                        })), e(this, "showImageAtCurrentTime", (() => {
                            this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos();
                            const e = this.thumbnails[0].frames.findIndex((e => this.seekTime >= e.startTime && this.seekTime <= e.endTime)),
                                t = e >= 0;
                            let i = 0;
                            this.mouseDown || this.toggleThumbContainer(t), t && (this.thumbnails.forEach(((t, r) => {
                                this.loadedImages.includes(t.frames[e].text) && (i = r)
                            })), e !== this.showingThumb && (this.showingThumb = e, this.loadImage(i)))
                        })), e(this, "loadImage", ((e = 0) => {
                            const t = this.showingThumb,
                                i = this.thumbnails[e],
                                {
                                    urlPrefix: r
                                } = i,
                                n = i.frames[t],
                                s = i.frames[t].text,
                                a = r + s;
                            if (this.currentImageElement && this.currentImageElement.dataset.filename === s) this.showImage(this.currentImageElement, n, e, t, s, !1), this.currentImageElement.dataset.index = t, this.removeOldImages(this.currentImageElement);
                            else {
                                this.loadingImage && this.usingSprites && (this.loadingImage.onload = null);
                                const i = new Image;
                                i.src = a, i.dataset.index = t, i.dataset.filename = s, this.showingThumbFilename = s, this.player.debug.log(`Loading image: ${a}`), i.onload = () => this.showImage(i, n, e, t, s, !0), this.loadingImage = i, this.removeOldImages(i)
                            }
                        })), e(this, "showImage", ((e, t, i, r, n, s = !0) => {
                            this.player.debug.log(`Showing thumb: ${n}. num: ${r}. qual: ${i}. newimg: ${s}`), this.setImageSizeAndOffset(e, t), s && (this.currentImageContainer.appendChild(e), this.currentImageElement = e, this.loadedImages.includes(n) || this.loadedImages.push(n)), this.preloadNearby(r, !0).then(this.preloadNearby(r, !1)).then(this.getHigherQuality(i, e, t, n))
                        })), e(this, "removeOldImages", (e => {
                            Array.from(this.currentImageContainer.children).forEach((t => {
                                if ("img" !== t.tagName.toLowerCase()) return;
                                const i = this.usingSprites ? 500 : 1e3;
                                if (t.dataset.index !== e.dataset.index && !t.dataset.deleting) {
                                    t.dataset.deleting = !0;
                                    const {
                                        currentImageContainer: e
                                    } = this;
                                    setTimeout((() => {
                                        e.removeChild(t), this.player.debug.log(`Removing thumb: ${t.dataset.filename}`)
                                    }), i)
                                }
                            }))
                        })), e(this, "preloadNearby", ((e, t = !0) => new Promise((i => {
                            setTimeout((() => {
                                const r = this.thumbnails[0].frames[e].text;
                                if (this.showingThumbFilename === r) {
                                    let n;
                                    n = t ? this.thumbnails[0].frames.slice(e) : this.thumbnails[0].frames.slice(0, e).reverse();
                                    let s = !1;
                                    n.forEach((e => {
                                        const t = e.text;
                                        if (t !== r && !this.loadedImages.includes(t)) {
                                            s = !0, this.player.debug.log(`Preloading thumb filename: ${t}`);
                                            const {
                                                urlPrefix: e
                                            } = this.thumbnails[0], r = e + t, n = new Image;
                                            n.src = r, n.onload = () => {
                                                this.player.debug.log(`Preloaded thumb filename: ${t}`), this.loadedImages.includes(t) || this.loadedImages.push(t), i()
                                            }
                                        }
                                    })), s || i()
                                }
                            }), 300)
                        })))), e(this, "getHigherQuality", ((e, t, i, r) => {
                            if (e < this.thumbnails.length - 1) {
                                let n = t.naturalHeight;
                                this.usingSprites && (n = i.h), n < this.thumbContainerHeight && setTimeout((() => {
                                    this.showingThumbFilename === r && (this.player.debug.log(`Showing higher quality thumb for: ${r}`), this.loadImage(e + 1))
                                }), 300)
                            }
                        })), e(this, "toggleThumbContainer", ((e = !1, t = !1) => {
                            const i = this.player.config.classNames.previewThumbnails.thumbContainerShown;
                            this.elements.thumb.container.classList.toggle(i, e), !e && t && (this.showingThumb = null, this.showingThumbFilename = null)
                        })), e(this, "toggleScrubbingContainer", ((e = !1) => {
                            const t = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
                            this.elements.scrubbing.container.classList.toggle(t, e), e || (this.showingThumb = null, this.showingThumbFilename = null)
                        })), e(this, "determineContainerAutoSizing", (() => {
                            (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) && (this.sizeSpecifiedInCSS = !0)
                        })), e(this, "setThumbContainerSizeAndPos", (() => {
                            const {
                                imageContainer: e
                            } = this.elements.thumb;
                            if (this.sizeSpecifiedInCSS) {
                                if (e.clientHeight > 20 && e.clientWidth < 20) {
                                    const t = Math.floor(e.clientHeight * this.thumbAspectRatio);
                                    e.style.width = `${t}px`
                                } else if (e.clientHeight < 20 && e.clientWidth > 20) {
                                    const t = Math.floor(e.clientWidth / this.thumbAspectRatio);
                                    e.style.height = `${t}px`
                                }
                            } else {
                                const t = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);
                                e.style.height = `${this.thumbContainerHeight}px`, e.style.width = `${t}px`
                            }
                            this.setThumbContainerPos()
                        })), e(this, "setThumbContainerPos", (() => {
                            const e = this.player.elements.progress.getBoundingClientRect(),
                                t = this.player.elements.container.getBoundingClientRect(),
                                {
                                    container: i
                                } = this.elements.thumb,
                                r = t.left - e.left + 10,
                                n = t.right - e.left - i.clientWidth - 10,
                                s = this.mousePosX - e.left - i.clientWidth / 2,
                                a = Ze(s, r, n);
                            i.style.left = `${a}px`, i.style.setProperty("--preview-arrow-offset", s - a + "px")
                        })), e(this, "setScrubbingContainerSize", (() => {
                            const {
                                width: e,
                                height: t
                            } = tt(this.thumbAspectRatio, {
                                width: this.player.media.clientWidth,
                                height: this.player.media.clientHeight
                            });
                            this.elements.scrubbing.container.style.width = `${e}px`, this.elements.scrubbing.container.style.height = `${t}px`
                        })), e(this, "setImageSizeAndOffset", ((e, t) => {
                            if (!this.usingSprites) return;
                            const i = this.thumbContainerHeight / t.h;
                            e.style.height = e.naturalHeight * i + "px", e.style.width = e.naturalWidth * i + "px", e.style.left = `-${t.x*i}px`, e.style.top = `-${t.y*i}px`
                        })), this.player = t, this.thumbnails = [], this.loaded = !1, this.lastMouseMoveTime = Date.now(), this.mouseDown = !1, this.loadedImages = [], this.elements = {
                            thumb: {},
                            scrubbing: {}
                        }, this.load()
                    }
                    get enabled() {
                        return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled
                    }
                    get currentImageContainer() {
                        return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer
                    }
                    get usingSprites() {
                        return Object.keys(this.thumbnails[0].frames[0]).includes("w")
                    }
                    get thumbAspectRatio() {
                        return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height
                    }
                    get thumbContainerHeight() {
                        if (this.mouseDown) {
                            const {
                                height: e
                            } = tt(this.thumbAspectRatio, {
                                width: this.player.media.clientWidth,
                                height: this.player.media.clientHeight
                            });
                            return e
                        }
                        return this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4)
                    }
                    get currentImageElement() {
                        return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement
                    }
                    set currentImageElement(e) {
                        this.mouseDown ? this.currentScrubbingImageElement = e : this.currentThumbnailImageElement = e
                    }
                }
                const rt = {
                    insertElements(e, t) {
                        S.string(t) ? M(e, this.media, {
                            src: t
                        }) : S.array(t) && t.forEach((t => {
                            M(e, this.media, t)
                        }))
                    },
                    change(e) {
                        C(e, "sources.length") ? (fe.cancelRequests.call(this), this.destroy.call(this, (() => {
                            this.options.quality = [], N(this.media), this.media = null, S.element(this.elements.container) && this.elements.container.removeAttribute("class");
                            const {
                                sources: t,
                                type: i
                            } = e, [{
                                provider: r = Me.html5,
                                src: n
                            }] = t, s = "html5" === r ? i : "div", a = "html5" === r ? {} : {
                                src: n
                            };
                            Object.assign(this, {
                                provider: r,
                                type: i,
                                supported: Y.check(i, r, this.config.playsinline),
                                media: O(s, a)
                            }), this.elements.container.appendChild(this.media), S.boolean(e.autoplay) && (this.config.autoplay = e.autoplay), this.isHTML5 && (this.config.crossorigin && this.media.setAttribute("crossorigin", ""), this.config.autoplay && this.media.setAttribute("autoplay", ""), S.empty(e.poster) || (this.poster = e.poster), this.config.loop.active && this.media.setAttribute("loop", ""), this.config.muted && this.media.setAttribute("muted", ""), this.config.playsinline && this.media.setAttribute("playsinline", "")), je.addStyleHook.call(this), this.isHTML5 && rt.insertElements.call(this, "source", t), this.config.title = e.title, Qe.setup.call(this), this.isHTML5 && Object.keys(e).includes("tracks") && rt.insertElements.call(this, "track", e.tracks), (this.isHTML5 || this.isEmbed && !this.supported.ui) && je.build.call(this), this.isHTML5 && this.media.load(), S.empty(e.previewThumbnails) || (Object.assign(this.config.previewThumbnails, e.previewThumbnails), this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), this.config.previewThumbnails.enabled && (this.previewThumbnails = new it(this))), this.fullscreen.update()
                        }), !0)) : this.debug.warn("Invalid source format")
                    }
                };
                class nt {
                    constructor(t, i) {
                        if (e(this, "play", (() => S.function(this.media.play) ? (this.ads && this.ads.enabled && this.ads.managerPromise.then((() => this.ads.play())).catch((() => re(this.media.play()))), this.media.play()) : null)), e(this, "pause", (() => this.playing && S.function(this.media.pause) ? this.media.pause() : null)), e(this, "togglePlay", (e => (S.boolean(e) ? e : !this.playing) ? this.play() : this.pause())), e(this, "stop", (() => {
                                this.isHTML5 ? (this.pause(), this.restart()) : S.function(this.media.stop) && this.media.stop()
                            })), e(this, "restart", (() => {
                                this.currentTime = 0
                            })), e(this, "rewind", (e => {
                                this.currentTime -= S.number(e) ? e : this.config.seekTime
                            })), e(this, "forward", (e => {
                                this.currentTime += S.number(e) ? e : this.config.seekTime
                            })), e(this, "increaseVolume", (e => {
                                const t = this.media.muted ? 0 : this.volume;
                                this.volume = t + (S.number(e) ? e : 0)
                            })), e(this, "decreaseVolume", (e => {
                                this.increaseVolume(-e)
                            })), e(this, "airplay", (() => {
                                Y.airplay && this.media.webkitShowPlaybackTargetPicker()
                            })), e(this, "toggleControls", (e => {
                                if (this.supported.ui && !this.isAudio) {
                                    const t = j(this.elements.container, this.config.classNames.hideControls),
                                        i = void 0 === e ? void 0 : !e,
                                        r = H(this.elements.container, this.config.classNames.hideControls, i);
                                    if (r && S.array(this.config.controls) && this.config.controls.includes("settings") && !S.empty(this.config.settings) && Re.toggleMenu.call(this, !1), r !== t) {
                                        const e = r ? "controlshidden" : "controlsshown";
                                        ee.call(this, this.media, e)
                                    }
                                    return !r
                                }
                                return !1
                            })), e(this, "on", ((e, t) => {
                                Q.call(this, this.elements.container, e, t)
                            })), e(this, "once", ((e, t) => {
                                Z.call(this, this.elements.container, e, t)
                            })), e(this, "off", ((e, t) => {
                                J(this.elements.container, e, t)
                            })), e(this, "destroy", ((e, t = !1) => {
                                if (!this.ready) return;
                                const i = () => {
                                    document.body.style.overflow = "", this.embed = null, t ? (Object.keys(this.elements).length && (N(this.elements.buttons.play), N(this.elements.captions), N(this.elements.controls), N(this.elements.wrapper), this.elements.buttons.play = null, this.elements.captions = null, this.elements.controls = null, this.elements.wrapper = null), S.function(e) && e()) : (te.call(this), fe.cancelRequests.call(this), B(this.elements.original, this.elements.container), ee.call(this, this.elements.original, "destroyed", !0), S.function(e) && e.call(this.elements.original), this.ready = !1, setTimeout((() => {
                                        this.elements = null, this.media = null
                                    }), 200))
                                };
                                this.stop(), clearTimeout(this.timers.loading), clearTimeout(this.timers.controls), clearTimeout(this.timers.resized), this.isHTML5 ? (je.toggleNativeControls.call(this, !0), i()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), null !== this.embed && S.function(this.embed.destroy) && this.embed.destroy(), i()) : this.isVimeo && (null !== this.embed && this.embed.unload().then(i), setTimeout(i, 200))
                            })), e(this, "supports", (e => Y.mime.call(this, e))), this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = Y.touch, this.media = t, S.string(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || S.nodeList(this.media) || S.array(this.media)) && (this.media = this.media[0]), this.config = I({}, Pe, nt.defaults, i || {}, (() => {
                                try {
                                    return JSON.parse(this.media.getAttribute("data-plyr-config"))
                                } catch (e) {
                                    return {}
                                }
                            })()), this.elements = {
                                container: null,
                                fullscreen: null,
                                captions: null,
                                buttons: {},
                                display: {},
                                progress: {},
                                inputs: {},
                                settings: {
                                    popup: null,
                                    menu: null,
                                    panels: {},
                                    buttons: {}
                                }
                            }, this.captions = {
                                active: null,
                                currentTrack: -1,
                                meta: new WeakMap
                            }, this.fullscreen = {
                                active: !1
                            }, this.options = {
                                speed: [],
                                quality: []
                            }, this.debug = new Ue(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", Y), S.nullOrUndefined(this.media) || !S.element(this.media)) return void this.debug.error("Setup failed: no suitable element passed");
                        if (this.media.plyr) return void this.debug.warn("Target already setup");
                        if (!this.config.enabled) return void this.debug.error("Setup failed: disabled by config");
                        if (!Y.check().api) return void this.debug.error("Setup failed: no support");
                        const r = this.media.cloneNode(!0);
                        r.autoplay = !1, this.elements.original = r;
                        const n = this.media.tagName.toLowerCase();
                        let s = null,
                            a = null;
                        switch (n) {
                            case "div":
                                if (s = this.media.querySelector("iframe"), S.element(s)) {
                                    if (a = De(s.getAttribute("src")), this.provider = function(e) {
                                            return /^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(e) ? Me.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(e) ? Me.vimeo : null
                                        }(a.toString()), this.elements.container = this.media, this.media = s, this.elements.container.className = "", a.search.length) {
                                        const e = ["1", "true"];
                                        e.includes(a.searchParams.get("autoplay")) && (this.config.autoplay = !0), e.includes(a.searchParams.get("loop")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = e.includes(a.searchParams.get("playsinline")), this.config.youtube.hl = a.searchParams.get("hl")) : this.config.playsinline = !0
                                    }
                                } else this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider);
                                if (S.empty(this.provider) || !Object.values(Me).includes(this.provider)) return void this.debug.error("Setup failed: Invalid provider");
                                this.type = Fe;
                                break;
                            case "video":
                            case "audio":
                                this.type = n, this.provider = Me.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0), this.media.hasAttribute("autoplay") && (this.config.autoplay = !0), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = !0), this.media.hasAttribute("muted") && (this.config.muted = !0), this.media.hasAttribute("loop") && (this.config.loop.active = !0);
                                break;
                            default:
                                return void this.debug.error("Setup failed: unsupported type")
                        }
                        this.supported = Y.check(this.type, this.provider), this.supported.api ? (this.eventListeners = [], this.listeners = new Ge(this), this.storage = new Ee(this), this.media.plyr = this, S.element(this.elements.container) || (this.elements.container = O("div"), P(this.media, this.elements.container)), je.migrateStyles.call(this), je.addStyleHook.call(this), Qe.setup.call(this), this.config.debug && Q.call(this, this.elements.container, this.config.events.join(" "), (e => {
                            this.debug.log(`event: ${e.type}`)
                        })), this.fullscreen = new $e(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && je.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new Je(this)), this.isHTML5 && this.config.autoplay && this.once("canplay", (() => re(this.play()))), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new it(this))) : this.debug.error("Setup failed: no support")
                    }
                    get isHTML5() {
                        return this.provider === Me.html5
                    }
                    get isEmbed() {
                        return this.isYouTube || this.isVimeo
                    }
                    get isYouTube() {
                        return this.provider === Me.youtube
                    }
                    get isVimeo() {
                        return this.provider === Me.vimeo
                    }
                    get isVideo() {
                        return this.type === Fe
                    }
                    get isAudio() {
                        return this.type === Ne
                    }
                    get playing() {
                        return Boolean(this.ready && !this.paused && !this.ended)
                    }
                    get paused() {
                        return Boolean(this.media.paused)
                    }
                    get stopped() {
                        return Boolean(this.paused && 0 === this.currentTime)
                    }
                    get ended() {
                        return Boolean(this.media.ended)
                    }
                    set currentTime(e) {
                        if (!this.duration) return;
                        const t = S.number(e) && e > 0;
                        this.media.currentTime = t ? Math.min(e, this.duration) : 0, this.debug.log(`Seeking to ${this.currentTime} seconds`)
                    }
                    get currentTime() {
                        return Number(this.media.currentTime)
                    }
                    get buffered() {
                        const {
                            buffered: e
                        } = this.media;
                        return S.number(e) ? e : e && e.length && this.duration > 0 ? e.end(0) / this.duration : 0
                    }
                    get seeking() {
                        return Boolean(this.media.seeking)
                    }
                    get duration() {
                        const e = parseFloat(this.config.duration),
                            t = (this.media || {}).duration,
                            i = S.number(t) && t !== 1 / 0 ? t : 0;
                        return e || i
                    }
                    set volume(e) {
                        let t = e;
                        S.string(t) && (t = Number(t)), S.number(t) || (t = this.storage.get("volume")), S.number(t) || ({
                            volume: t
                        } = this.config), t > 1 && (t = 1), t < 0 && (t = 0), this.config.volume = t, this.media.volume = t, !S.empty(e) && this.muted && t > 0 && (this.muted = !1)
                    }
                    get volume() {
                        return Number(this.media.volume)
                    }
                    set muted(e) {
                        let t = e;
                        S.boolean(t) || (t = this.storage.get("muted")), S.boolean(t) || (t = this.config.muted), this.config.muted = t, this.media.muted = t
                    }
                    get muted() {
                        return Boolean(this.media.muted)
                    }
                    get hasAudio() {
                        return !this.isHTML5 || !!this.isAudio || Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length)
                    }
                    set speed(e) {
                        let t = null;
                        S.number(e) && (t = e), S.number(t) || (t = this.storage.get("speed")), S.number(t) || (t = this.config.speed.selected);
                        const {
                            minimumSpeed: i,
                            maximumSpeed: r
                        } = this;
                        t = Ze(t, i, r), this.config.speed.selected = t, setTimeout((() => {
                            this.media && (this.media.playbackRate = t)
                        }), 0)
                    }
                    get speed() {
                        return Number(this.media.playbackRate)
                    }
                    get minimumSpeed() {
                        return this.isYouTube ? Math.min(...this.options.speed) : this.isVimeo ? .5 : .0625
                    }
                    get maximumSpeed() {
                        return this.isYouTube ? Math.max(...this.options.speed) : this.isVimeo ? 2 : 16
                    }
                    set quality(e) {
                        const t = this.config.quality,
                            i = this.options.quality;
                        if (!i.length) return;
                        let r = [!S.empty(e) && Number(e), this.storage.get("quality"), t.selected, t.default].find(S.number),
                            n = !0;
                        if (!i.includes(r)) {
                            const e = se(i, r);
                            this.debug.warn(`Unsupported quality option: ${r}, using ${e} instead`), r = e, n = !1
                        }
                        t.selected = r, this.media.quality = r, n && this.storage.set({
                            quality: r
                        })
                    }
                    get quality() {
                        return this.media.quality
                    }
                    set loop(e) {
                        const t = S.boolean(e) ? e : this.config.loop.active;
                        this.config.loop.active = t, this.media.loop = t
                    }
                    get loop() {
                        return Boolean(this.media.loop)
                    }
                    set source(e) {
                        rt.change.call(this, e)
                    }
                    get source() {
                        return this.media.currentSrc
                    }
                    get download() {
                        const {
                            download: e
                        } = this.config.urls;
                        return S.url(e) ? e : this.source
                    }
                    set download(e) {
                        S.url(e) && (this.config.urls.download = e, Re.setDownloadUrl.call(this))
                    }
                    set poster(e) {
                        this.isVideo ? je.setPoster.call(this, e, !1).catch((() => {})) : this.debug.warn("Poster can only be set for video")
                    }
                    get poster() {
                        return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null
                    }
                    get ratio() {
                        if (!this.isVideo) return null;
                        const e = ce(de.call(this));
                        return S.array(e) ? e.join(":") : e
                    }
                    set ratio(e) {
                        this.isVideo ? S.string(e) && le(e) ? (this.config.ratio = ce(e), ue.call(this)) : this.debug.error(`Invalid aspect ratio specified (${e})`) : this.debug.warn("Aspect ratio can only be set for video")
                    }
                    set autoplay(e) {
                        this.config.autoplay = S.boolean(e) ? e : this.config.autoplay
                    }
                    get autoplay() {
                        return Boolean(this.config.autoplay)
                    }
                    toggleCaptions(e) {
                        Ie.toggle.call(this, e, !1)
                    }
                    set currentTrack(e) {
                        Ie.set.call(this, e, !1), Ie.setup.call(this)
                    }
                    get currentTrack() {
                        const {
                            toggled: e,
                            currentTrack: t
                        } = this.captions;
                        return e ? t : -1
                    }
                    set language(e) {
                        Ie.setLanguage.call(this, e, !1)
                    }
                    get language() {
                        return (Ie.getCurrentTrack.call(this) || {}).language
                    }
                    set pip(e) {
                        if (!Y.pip) return;
                        const t = S.boolean(e) ? e : !this.pip;
                        S.function(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(t ? xe : Oe), S.function(this.media.requestPictureInPicture) && (!this.pip && t ? this.media.requestPictureInPicture() : this.pip && !t && document.exitPictureInPicture())
                    }
                    get pip() {
                        return Y.pip ? S.empty(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === xe : null
                    }
                    setPreviewThumbnails(e) {
                        this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), Object.assign(this.config.previewThumbnails, e), this.config.previewThumbnails.enabled && (this.previewThumbnails = new it(this))
                    }
                    static supported(e, t) {
                        return Y.check(e, t)
                    }
                    static loadSprite(e, t) {
                        return we(e, t)
                    }
                    static setup(e, t = {}) {
                        let i = null;
                        return S.string(e) ? i = Array.from(document.querySelectorAll(e)) : S.nodeList(e) ? i = Array.from(e) : S.array(e) && (i = e.filter(S.element)), S.empty(i) ? null : i.map((e => new nt(e, t)))
                    }
                }
                var st;
                return nt.defaults = (st = Pe, JSON.parse(JSON.stringify(st))), nt
            }())
        },
        73855: function(e, t, i) {
            ! function(e) {
                var t = function() {
                        try {
                            return !!Symbol.iterator
                        } catch (e) {
                            return !1
                        }
                    }(),
                    i = function(e) {
                        var i = {
                            next: function() {
                                var t = e.shift();
                                return {
                                    done: void 0 === t,
                                    value: t
                                }
                            }
                        };
                        return t && (i[Symbol.iterator] = function() {
                            return i
                        }), i
                    },
                    r = function(e) {
                        return encodeURIComponent(e).replace(/%20/g, "+")
                    },
                    n = function(e) {
                        return decodeURIComponent(String(e).replace(/\+/g, " "))
                    };
                (function() {
                    try {
                        var t = e.URLSearchParams;
                        return "a=1" === new t("?a=1").toString() && "function" == typeof t.prototype.set && "function" == typeof t.prototype.entries
                    } catch (e) {
                        return !1
                    }
                })() || function() {
                    var n = function(e) {
                            Object.defineProperty(this, "_entries", {
                                writable: !0,
                                value: {}
                            });
                            var t = typeof e;
                            if ("undefined" === t);
                            else if ("string" === t) "" !== e && this._fromString(e);
                            else if (e instanceof n) {
                                var i = this;
                                e.forEach((function(e, t) {
                                    i.append(t, e)
                                }))
                            } else {
                                if (null === e || "object" !== t) throw new TypeError("Unsupported input's type for URLSearchParams");
                                if ("[object Array]" === Object.prototype.toString.call(e))
                                    for (var r = 0; r < e.length; r++) {
                                        var s = e[r];
                                        if ("[object Array]" !== Object.prototype.toString.call(s) && 2 === s.length) throw new TypeError("Expected [string, any] as entry at index " + r + " of URLSearchParams's input");
                                        this.append(s[0], s[1])
                                    } else
                                        for (var a in e) e.hasOwnProperty(a) && this.append(a, e[a])
                            }
                        },
                        s = n.prototype;
                    s.append = function(e, t) {
                        e in this._entries ? this._entries[e].push(String(t)) : this._entries[e] = [String(t)]
                    }, s.delete = function(e) {
                        delete this._entries[e]
                    }, s.get = function(e) {
                        return e in this._entries ? this._entries[e][0] : null
                    }, s.getAll = function(e) {
                        return e in this._entries ? this._entries[e].slice(0) : []
                    }, s.has = function(e) {
                        return e in this._entries
                    }, s.set = function(e, t) {
                        this._entries[e] = [String(t)]
                    }, s.forEach = function(e, t) {
                        var i;
                        for (var r in this._entries)
                            if (this._entries.hasOwnProperty(r)) {
                                i = this._entries[r];
                                for (var n = 0; n < i.length; n++) e.call(t, i[n], r, this)
                            }
                    }, s.keys = function() {
                        var e = [];
                        return this.forEach((function(t, i) {
                            e.push(i)
                        })), i(e)
                    }, s.values = function() {
                        var e = [];
                        return this.forEach((function(t) {
                            e.push(t)
                        })), i(e)
                    }, s.entries = function() {
                        var e = [];
                        return this.forEach((function(t, i) {
                            e.push([i, t])
                        })), i(e)
                    }, t && (s[Symbol.iterator] = s.entries), s.toString = function() {
                        var e = [];
                        return this.forEach((function(t, i) {
                            e.push(r(i) + "=" + r(t))
                        })), e.join("&")
                    }, e.URLSearchParams = n
                }();
                var s = e.URLSearchParams.prototype;
                "function" != typeof s.sort && (s.sort = function() {
                    var e = this,
                        t = [];
                    this.forEach((function(i, r) {
                        t.push([r, i]), e._entries || e.delete(r)
                    })), t.sort((function(e, t) {
                        return e[0] < t[0] ? -1 : e[0] > t[0] ? 1 : 0
                    })), e._entries && (e._entries = {});
                    for (var i = 0; i < t.length; i++) this.append(t[i][0], t[i][1])
                }), "function" != typeof s._fromString && Object.defineProperty(s, "_fromString", {
                    enumerable: !1,
                    configurable: !1,
                    writable: !1,
                    value: function(e) {
                        if (this._entries) this._entries = {};
                        else {
                            var t = [];
                            this.forEach((function(e, i) {
                                t.push(i)
                            }));
                            for (var i = 0; i < t.length; i++) this.delete(t[i])
                        }
                        var r, s = (e = e.replace(/^\?/, "")).split("&");
                        for (i = 0; i < s.length; i++) r = s[i].split("="), this.append(n(r[0]), r.length > 1 ? n(r[1]) : "")
                    }
                })
            }(void 0 !== i.g ? i.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : this),
            function(e) {
                if (function() {
                        try {
                            var t = new e.URL("b", "http://a");
                            return t.pathname = "c d", "http://a/c%20d" === t.href && t.searchParams
                        } catch (e) {
                            return !1
                        }
                    }() || function() {
                        var t = e.URL,
                            i = function(t, i) {
                                "string" != typeof t && (t = String(t)), i && "string" != typeof i && (i = String(i));
                                var r, n = document;
                                if (i && (void 0 === e.location || i !== e.location.href)) {
                                    i = i.toLowerCase(), (r = (n = document.implementation.createHTMLDocument("")).createElement("base")).href = i, n.head.appendChild(r);
                                    try {
                                        if (0 !== r.href.indexOf(i)) throw new Error(r.href)
                                    } catch (e) {
                                        throw new Error("URL unable to set base " + i + " due to " + e)
                                    }
                                }
                                var s = n.createElement("a");
                                s.href = t, r && (n.body.appendChild(s), s.href = s.href);
                                var a = n.createElement("input");
                                if (a.type = "url", a.value = t, ":" === s.protocol || !/:/.test(s.href) || !a.checkValidity() && !i) throw new TypeError("Invalid URL");
                                Object.defineProperty(this, "_anchorElement", {
                                    value: s
                                });
                                var o = new e.URLSearchParams(this.search),
                                    l = !0,
                                    c = !0,
                                    d = this;
                                ["append", "delete", "set"].forEach((function(e) {
                                    var t = o[e];
                                    o[e] = function() {
                                        t.apply(o, arguments), l && (c = !1, d.search = o.toString(), c = !0)
                                    }
                                })), Object.defineProperty(this, "searchParams", {
                                    value: o,
                                    enumerable: !0
                                });
                                var u = void 0;
                                Object.defineProperty(this, "_updateSearchParams", {
                                    enumerable: !1,
                                    configurable: !1,
                                    writable: !1,
                                    value: function() {
                                        this.search !== u && (u = this.search, c && (l = !1, this.searchParams._fromString(this.search), l = !0))
                                    }
                                })
                            },
                            r = i.prototype;
                        ["hash", "host", "hostname", "port", "protocol"].forEach((function(e) {
                            ! function(e) {
                                Object.defineProperty(r, e, {
                                    get: function() {
                                        return this._anchorElement[e]
                                    },
                                    set: function(t) {
                                        this._anchorElement[e] = t
                                    },
                                    enumerable: !0
                                })
                            }(e)
                        })), Object.defineProperty(r, "search", {
                            get: function() {
                                return this._anchorElement.search
                            },
                            set: function(e) {
                                this._anchorElement.search = e, this._updateSearchParams()
                            },
                            enumerable: !0
                        }), Object.defineProperties(r, {
                            toString: {
                                get: function() {
                                    var e = this;
                                    return function() {
                                        return e.href
                                    }
                                }
                            },
                            href: {
                                get: function() {
                                    return this._anchorElement.href.replace(/\?$/, "")
                                },
                                set: function(e) {
                                    this._anchorElement.href = e, this._updateSearchParams()
                                },
                                enumerable: !0
                            },
                            pathname: {
                                get: function() {
                                    return this._anchorElement.pathname.replace(/(^\/?)/, "/")
                                },
                                set: function(e) {
                                    this._anchorElement.pathname = e
                                },
                                enumerable: !0
                            },
                            origin: {
                                get: function() {
                                    var e = {
                                            "http:": 80,
                                            "https:": 443,
                                            "ftp:": 21
                                        }[this._anchorElement.protocol],
                                        t = this._anchorElement.port != e && "" !== this._anchorElement.port;
                                    return this._anchorElement.protocol + "//" + this._anchorElement.hostname + (t ? ":" + this._anchorElement.port : "")
                                },
                                enumerable: !0
                            },
                            password: {
                                get: function() {
                                    return ""
                                },
                                set: function(e) {},
                                enumerable: !0
                            },
                            username: {
                                get: function() {
                                    return ""
                                },
                                set: function(e) {},
                                enumerable: !0
                            }
                        }), i.createObjectURL = function(e) {
                            return t.createObjectURL.apply(t, arguments)
                        }, i.revokeObjectURL = function(e) {
                            return t.revokeObjectURL.apply(t, arguments)
                        }, e.URL = i
                    }(), void 0 !== e.location && !("origin" in e.location)) {
                    var t = function() {
                        return e.location.protocol + "//" + e.location.hostname + (e.location.port ? ":" + e.location.port : "")
                    };
                    try {
                        Object.defineProperty(e.location, "origin", {
                            get: t,
                            enumerable: !0
                        })
                    } catch (i) {
                        setInterval((function() {
                            e.location.origin = t()
                        }), 100)
                    }
                }
            }(void 0 !== i.g ? i.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : this)
        },
        17383: function(e) {
            e.exports = function(e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }, e.exports.__esModule = !0, e.exports.default = e.exports
        },
        43693: function(e) {
            e.exports = function(e, t, i) {
                return t in e ? Object.defineProperty(e, t, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = i, e
            }, e.exports.__esModule = !0, e.exports.default = e.exports
        },
        4633: function(e, t, i) {
            var r = i(73738).default;

            function n() {
                "use strict";
                e.exports = n = function() {
                    return t
                }, e.exports.__esModule = !0, e.exports.default = e.exports;
                var t = {},
                    i = Object.prototype,
                    s = i.hasOwnProperty,
                    a = "function" == typeof Symbol ? Symbol : {},
                    o = a.iterator || "@@iterator",
                    l = a.asyncIterator || "@@asyncIterator",
                    c = a.toStringTag || "@@toStringTag";

                function d(e, t, i) {
                    return Object.defineProperty(e, t, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), e[t]
                }
                try {
                    d({}, "")
                } catch (e) {
                    d = function(e, t, i) {
                        return e[t] = i
                    }
                }

                function u(e, t, i, r) {
                    var n = t && t.prototype instanceof m ? t : m,
                        s = Object.create(n.prototype),
                        a = new S(r || []);
                    return s._invoke = function(e, t, i) {
                        var r = "suspendedStart";
                        return function(n, s) {
                            if ("executing" === r) throw new Error("Generator is already running");
                            if ("completed" === r) {
                                if ("throw" === n) throw s;
                                return R()
                            }
                            for (i.method = n, i.arg = s;;) {
                                var a = i.delegate;
                                if (a) {
                                    var o = w(a, i);
                                    if (o) {
                                        if (o === f) continue;
                                        return o
                                    }
                                }
                                if ("next" === i.method) i.sent = i._sent = i.arg;
                                else if ("throw" === i.method) {
                                    if ("suspendedStart" === r) throw r = "completed", i.arg;
                                    i.dispatchException(i.arg)
                                } else "return" === i.method && i.abrupt("return", i.arg);
                                r = "executing";
                                var l = h(e, t, i);
                                if ("normal" === l.type) {
                                    if (r = i.done ? "completed" : "suspendedYield", l.arg === f) continue;
                                    return {
                                        value: l.arg,
                                        done: i.done
                                    }
                                }
                                "throw" === l.type && (r = "completed", i.method = "throw", i.arg = l.arg)
                            }
                        }
                    }(e, i, a), s
                }

                function h(e, t, i) {
                    try {
                        return {
                            type: "normal",
                            arg: e.call(t, i)
                        }
                    } catch (e) {
                        return {
                            type: "throw",
                            arg: e
                        }
                    }
                }
                t.wrap = u;
                var f = {};

                function m() {}

                function p() {}

                function g() {}
                var y = {};
                d(y, o, (function() {
                    return this
                }));
                var v = Object.getPrototypeOf,
                    b = v && v(v(L([])));
                b && b !== i && s.call(b, o) && (y = b);
                var T = g.prototype = m.prototype = Object.create(y);

                function E(e) {
                    ["next", "throw", "return"].forEach((function(t) {
                        d(e, t, (function(e) {
                            return this._invoke(t, e)
                        }))
                    }))
                }

                function A(e, t) {
                    function i(n, a, o, l) {
                        var c = h(e[n], e, a);
                        if ("throw" !== c.type) {
                            var d = c.arg,
                                u = d.value;
                            return u && "object" == r(u) && s.call(u, "__await") ? t.resolve(u.__await).then((function(e) {
                                i("next", e, o, l)
                            }), (function(e) {
                                i("throw", e, o, l)
                            })) : t.resolve(u).then((function(e) {
                                d.value = e, o(d)
                            }), (function(e) {
                                return i("throw", e, o, l)
                            }))
                        }
                        l(c.arg)
                    }
                    var n;
                    this._invoke = function(e, r) {
                        function s() {
                            return new t((function(t, n) {
                                i(e, r, t, n)
                            }))
                        }
                        return n = n ? n.then(s, s) : s()
                    }
                }

                function w(e, t) {
                    var i = e.iterator[t.method];
                    if (void 0 === i) {
                        if (t.delegate = null, "throw" === t.method) {
                            if (e.iterator.return && (t.method = "return", t.arg = void 0, w(e, t), "throw" === t.method)) return f;
                            t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
                        }
                        return f
                    }
                    var r = h(i, e.iterator, t.arg);
                    if ("throw" === r.type) return t.method = "throw", t.arg = r.arg, t.delegate = null, f;
                    var n = r.arg;
                    return n ? n.done ? (t[e.resultName] = n.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, f) : n : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, f)
                }

                function _(e) {
                    var t = {
                        tryLoc: e[0]
                    };
                    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                }

                function k(e) {
                    var t = e.completion || {};
                    t.type = "normal", delete t.arg, e.completion = t
                }

                function S(e) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], e.forEach(_, this), this.reset(!0)
                }

                function L(e) {
                    if (e) {
                        var t = e[o];
                        if (t) return t.call(e);
                        if ("function" == typeof e.next) return e;
                        if (!isNaN(e.length)) {
                            var i = -1,
                                r = function t() {
                                    for (; ++i < e.length;)
                                        if (s.call(e, i)) return t.value = e[i], t.done = !1, t;
                                    return t.value = void 0, t.done = !0, t
                                };
                            return r.next = r
                        }
                    }
                    return {
                        next: R
                    }
                }

                function R() {
                    return {
                        value: void 0,
                        done: !0
                    }
                }
                return p.prototype = g, d(T, "constructor", g), d(g, "constructor", p), p.displayName = d(g, c, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === p || "GeneratorFunction" === (t.displayName || t.name))
                }, t.mark = function(e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : (e.__proto__ = g, d(e, c, "GeneratorFunction")), e.prototype = Object.create(T), e
                }, t.awrap = function(e) {
                    return {
                        __await: e
                    }
                }, E(A.prototype), d(A.prototype, l, (function() {
                    return this
                })), t.AsyncIterator = A, t.async = function(e, i, r, n, s) {
                    void 0 === s && (s = Promise);
                    var a = new A(u(e, i, r, n), s);
                    return t.isGeneratorFunction(i) ? a : a.next().then((function(e) {
                        return e.done ? e.value : a.next()
                    }))
                }, E(T), d(T, c, "Generator"), d(T, o, (function() {
                    return this
                })), d(T, "toString", (function() {
                    return "[object Generator]"
                })), t.keys = function(e) {
                    var t = [];
                    for (var i in e) t.push(i);
                    return t.reverse(),
                        function i() {
                            for (; t.length;) {
                                var r = t.pop();
                                if (r in e) return i.value = r, i.done = !1, i
                            }
                            return i.done = !0, i
                        }
                }, t.values = L, S.prototype = {
                    constructor: S,
                    reset: function(e) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(k), !e)
                            for (var t in this) "t" === t.charAt(0) && s.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
                    },
                    stop: function() {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    },
                    dispatchException: function(e) {
                        if (this.done) throw e;
                        var t = this;

                        function i(i, r) {
                            return a.type = "throw", a.arg = e, t.next = i, r && (t.method = "next", t.arg = void 0), !!r
                        }
                        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                            var n = this.tryEntries[r],
                                a = n.completion;
                            if ("root" === n.tryLoc) return i("end");
                            if (n.tryLoc <= this.prev) {
                                var o = s.call(n, "catchLoc"),
                                    l = s.call(n, "finallyLoc");
                                if (o && l) {
                                    if (this.prev < n.catchLoc) return i(n.catchLoc, !0);
                                    if (this.prev < n.finallyLoc) return i(n.finallyLoc)
                                } else if (o) {
                                    if (this.prev < n.catchLoc) return i(n.catchLoc, !0)
                                } else {
                                    if (!l) throw new Error("try statement without catch or finally");
                                    if (this.prev < n.finallyLoc) return i(n.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(e, t) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var r = this.tryEntries[i];
                            if (r.tryLoc <= this.prev && s.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                var n = r;
                                break
                            }
                        }
                        n && ("break" === e || "continue" === e) && n.tryLoc <= t && t <= n.finallyLoc && (n = null);
                        var a = n ? n.completion : {};
                        return a.type = e, a.arg = t, n ? (this.method = "next", this.next = n.finallyLoc, f) : this.complete(a)
                    },
                    complete: function(e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), f
                    },
                    finish: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var i = this.tryEntries[t];
                            if (i.finallyLoc === e) return this.complete(i.completion, i.afterLoc), k(i), f
                        }
                    },
                    catch: function(e) {
                        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                            var i = this.tryEntries[t];
                            if (i.tryLoc === e) {
                                var r = i.completion;
                                if ("throw" === r.type) {
                                    var n = r.arg;
                                    k(i)
                                }
                                return n
                            }
                        }
                        throw new Error("illegal catch attempt")
                    },
                    delegateYield: function(e, t, i) {
                        return this.delegate = {
                            iterator: L(e),
                            resultName: t,
                            nextLoc: i
                        }, "next" === this.method && (this.arg = void 0), f
                    }
                }, t
            }
            e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports
        },
        73738: function(e) {
            function t(i) {
                return e.exports = t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                }, e.exports.__esModule = !0, e.exports.default = e.exports, t(i)
            }
            e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
        },
        54756: function(e, t, i) {
            var r = i(4633)();
            e.exports = r;
            try {
                regeneratorRuntime = r
            } catch (e) {
                "object" == typeof globalThis ? globalThis.regeneratorRuntime = r : Function("r", "regeneratorRuntime = r")(r)
            }
        }
    }
]);